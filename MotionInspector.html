<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Motion Inspector</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Generator:%20Adobe%20Illustrator%2027.9.0,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%206.00%20Build%200)%20--%3e%3csvg%20version='1.1'%20id='Layer_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%20150%20150'%20style='enable-background:new%200%200%20150%20150;'%20xml:space='preserve'%3e%3cstyle%20type='text/css'%3e%20.st0{fill:%23FF385C;fill-rule:evenodd;clip-rule:evenodd;}%20%3c/style%3e%3cg%20id='Layer_1_00000076594398665045771890000013973700932976003724_'%3e%3cg%3e%3cpath%20class='st0'%20d='M131.3,118c-1.1,7.2-5.9,13.5-12.9,16.2c-3.4,1.3-7.1,1.9-10.7,1.3c-3.6-0.4-7.1-1.6-10.7-3.6%20c-5.1-2.8-10.2-7.2-16-13.5c9.3-11.3,15-21.7,17-31c0.9-4.3,1.2-8.3,0.7-11.9c-0.5-3.5-1.7-6.7-3.8-9.5%20c-4.3-6.3-11.7-9.9-19.8-9.9c-8.2,0-15.6,3.8-19.8,9.9c-1.9,2.8-3.2,6-3.8,9.5c-0.5,3.6-0.4,7.6,0.7,11.9c2.1,9.3,7.9,19.7,17,31%20c-5.8,6.4-10.9,10.7-16,13.5c-3.6,2-7.2,3.2-10.7,3.6c-3.8,0.4-7.4,0-10.7-1.3c-6.8-2.8-11.8-9-12.9-16.2c-0.5-3.6-0.1-7,1.2-10.9%20c0.5-1.3,1.1-2.8,1.9-4.4c1.1-2.3,2.1-4.7,3.2-7l0.1-0.3c9.7-20.9,20.1-42,30.8-62.9l0.4-0.8c1.1-2.1,2.3-4.3,3.4-6.4%20c1.2-2.1,2.4-4.3,4-6.2c3-3.5,6.8-5.2,11.3-5.2c4.4,0,8.3,1.9,11.3,5.2c1.6,1.9,2.8,4,4,6.2c1.1,2.1,2.3,4.3,3.4,6.4l0.4,0.9%20c10.9,20.8,21.2,42,30.8,62.9l0.1,0.1c1.1,2.3,2.1,4.7,3.2,7.1c0.7,1.6,1.3,3.1,1.9,4.4C131.4,111.1,131.8,114.6,131.3,118z%20M74.9,111.6c-7.6-9.7-12.5-18.5-14.2-26c-0.7-3.1-0.9-6-0.5-8.6c0.4-2.1,1.1-4.2,2.3-5.9c2.7-3.8,7.2-6,12.5-6%20c5.1,0,9.8,2.3,12.5,6c1.2,1.7,1.9,3.6,2.3,5.9c0.4,2.5,0.3,5.5-0.5,8.6C87.4,93.1,82.6,102,74.9,111.6z%20M138.5,104.2%20c-0.7-1.7-1.3-3.5-2-5.1c-1.1-2.4-2.1-4.8-3.4-7.2l-0.1-0.1c-9.8-20.9-20.2-42.2-31.1-63.2l-0.4-0.9c-1.1-2.1-2.3-4.3-3.5-6.6%20c-1.3-2.5-3-5.2-5.1-7.8C88.2,8,81.9,5,74.8,5c-7,0-13.4,3-18.1,8.3c-2.1,2.5-3.6,5.2-5.1,7.8c-1.2,2.1-2.3,4.4-3.5,6.6l-0.4,0.8%20C37.1,49.7,26.7,70.8,16.9,91.9l-0.1,0.3c-1.1,2.3-2.1,4.7-3.2,7.1c-0.7,1.6-1.5,3.2-2,5.1c-1.9,5.1-2.4,10.1-1.6,15%20c1.5,10.5,8.6,19.3,18.4,23.3c3.6,1.5,7.5,2.3,11.5,2.3c1.2,0,2.4-0.1,3.8-0.3c4.7-0.5,9.5-2.1,14.1-4.7%20c5.8-3.2,11.4-7.9,17.4-14.5c6.2,6.7,11.8,11.4,17.4,14.5c4.7,2.5,9.4,4.2,14.1,4.7c1.2,0.1,2.4,0.3,3.8,0.3c4,0,7.9-0.8,11.5-2.3%20c9.8-3.9,16.9-12.9,18.4-23.3C140.8,114.4,140.3,109.5,138.5,104.2z'/%3e%3c/g%3e%3c/g%3e%3cg%20id='Dimensions'%3e%3c/g%3e%3c/svg%3e">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #171717;
      color: #e0e0e0;
      padding: 20px;
      overflow-x: auto;
      overflow-y: hidden;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .container {
      max-width: 100%;
    }

    .header-section {
      padding: 0 20px 0 20px;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      margin-bottom: 16px;
      transform: translateY(-2px);
      position: relative;
      z-index: 100; /* Ensure tooltips appear above video section */
    }

    h1 {
      font-family: 'Airbnb Cereal VF', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 26px;
      font-weight: 300;
      margin: 0;
      letter-spacing: 0;
      color: #ffffff;
    }

    h1[contenteditable="true"] {
      cursor: text;
      outline: none;
      padding: 0 12px 0 20px;
      margin: -2px -12px -2px -20px;
      border-radius: 8px;
      height: 44px;
      display: flex;
      align-items: center;
      min-width: 190px; /* fits "Motion Inspector" */
      max-width: calc(100% - 20px); /* 20px gap before toggle */
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    h1[contenteditable="true"]:hover {
      background: #222222;
    }

    h1[contenteditable="true"]:focus {
      background: #252525;
      outline: 1px solid #4a90e2;
      outline-offset: 2px;
    }

    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-self: end;
    }

    .btn {
      height: 40px;
      padding: 0 16px;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      box-sizing: border-box;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .btn-primary {
      background: #4a90e2;
      color: white;
    }

    .btn-primary:hover {
      background: #357abd;
    }

    .btn-secondary {
      background: #333;
      color: #e0e0e0;
      border: 1px solid #525252;
      padding-bottom: 2px;
    }

    .btn-secondary:hover {
      background: #444;
    }

    .btn-circular {
      width: 40px;
      height: 40px;
      padding: 0;
      border: 1px solid #525252;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .btn-circular svg {
      display: block;
    }

    .btn-circular::after {
      content: attr(data-tooltip);
      position: absolute;
      top: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      color: #fff;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 10000;
    }

    .btn-circular:hover::after {
      opacity: 1;
    }

    /* View mode segmented control */
    .view-mode-control {
      display: inline-flex;
      background: #2a2a2a;
      border-radius: 20px;
      padding: 4px;
      gap: 4px;
      position: relative;
    }

    .view-mode-btn {
      padding: 8px 16px;
      width: 80px;
      background: transparent;
      border: none;
      border-radius: 16px;
      color: #888;
      font-size: 13px;
      font-weight: 500;
      line-height: 16px;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
      position: relative;
      box-sizing: border-box;
    }

    /* Create divider with pseudo-element on first button */
    .view-mode-btn:first-child::after {
      content: '';
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 1px;
      height: 20px;
      background: #fff;
    }

    /* Hide divider when first button is selected */
    .view-mode-btn:first-child.selected::after {
      display: none;
    }

    /* Hide divider when second button is selected (using ~ general sibling) */
    .view-mode-btn.selected ~ .view-mode-btn:first-child::after,
    .view-mode-btn:first-child:has(~ .view-mode-btn.selected)::after {
      display: none;
    }

    .view-mode-btn:hover {
      background: #3a3a3a;
    }

    .view-mode-btn.selected {
      background: #444;
      color: #ffffff;
      box-shadow: inset 0 0 0 1px #555;
      z-index: 1;
    }

    /* Make emojis in buttons 2px larger */
    .btn-emoji {
      font-size: 15px;
    }

    #videoInput {
      display: none;
    }

    .main-content {
      display: grid;
      grid-template-columns: 1fr 20px max(560px, min(55vh, 45vw));
      gap: 0;
      grid-auto-rows: max-content;
      position: relative;
    }

    .main-content.split-layout {
      grid-template-columns: 1fr 20px 1fr;
    }

    .resize-handle {
      cursor: col-resize;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      user-select: none;
    }

    .resize-handle::before {
      content: '';
      position: absolute;
      top: 50%;
      left: calc(50% + 1px);
      transform: translate(-50%, -50%);
      width: 4px;
      height: 40px;
      background: #4a4a4a;
      border-radius: 2px;
      transition: background 0.2s;
    }

    .resize-handle:hover::before,
    .resize-handle.dragging::before {
      background: #4a90e2;
    }

    .video-section {
      background: #000;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0;
      height: calc(100vh - 96px);
      max-height: calc(100vh - 96px);
      min-width: 560px; /* Fixed minimum - JS controls actual width via grid */
      padding: 48px;
      box-sizing: border-box;
      position: relative;
    }

    .video-section:not(:has(video[src])) {
      min-height: calc(100vh - 96px);
    }

    .video-section.drag-over {
      border: 2px dashed #4a90e2;
      background: rgba(74, 144, 226, 0.1);
    }

    .video-section.drag-over .video-empty-state-btn,
    .video-section.drag-over .video-overlay {
      display: none !important;
    }

    .video-drop-text {
      display: none;
      font-size: 13px;
      font-weight: 500;
      color: #4a90e2;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    .video-section.drag-over .video-drop-text {
      display: block;
    }

    .video-container {
      display: none;
      flex: 1;
      min-height: 0;
    }

    .video-container.has-video {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      position: relative;
    }

    .video-container.has-video.width-constrained {
      align-items: center;
    }

    .video-wrapper {
      position: relative;
      display: inline-block;
      max-width: 100%;
      padding: 10px;
      background: #282828;
      border-radius: 46px;
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.25);
      line-height: 0;
      box-sizing: border-box;
    }

    video {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 37px;
      background: #000;
      position: relative;
      z-index: 1;
      overflow: hidden;
    }

    .video-overlay {
      position: absolute;
      top: 11px;
      left: 11px;
      width: calc(100% - 22px);
      height: calc(100% - 22px);
      background: rgba(0, 0, 0, 0);
      border-radius: 36px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      opacity: 0;
      transition: all 0.15s ease;
      pointer-events: none;
      z-index: 2;
    }

    /* Only show overlay when hovering video or overlay itself, not description */
    .video-wrapper:has(video:hover) .video-overlay,
    .video-wrapper:has(.video-overlay:hover) .video-overlay {
      background: rgba(0, 0, 0, 0.9);
      opacity: 1;
      pointer-events: auto;
    }

    .video-overlay-btn {
      padding: 8px 16px;
      border-radius: 8px;
      background: #222;
      color: #e0e0e0;
      border: 1px solid #444;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s ease;
      min-width: 176px;
      min-height: 40px;
      box-sizing: border-box;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }

    .video-overlay-btn:hover {
      background: #444;
      border-color: #555;
    }

    .video-fullscreen-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.15s ease, background 0.15s ease;
      z-index: 5;
    }

    .video-fullscreen-btn svg {
      width: 20px;
      height: 20px;
      fill: white;
    }

    .video-wrapper:hover .video-fullscreen-btn {
      opacity: 1;
    }

    .video-fullscreen-btn:hover {
      background: rgba(0, 0, 0, 0.9);
      border-color: rgba(255, 255, 255, 0.4);
    }

    /* In edit mode, hide fullscreen button when hovering video (overlay shows) */
    .video-wrapper:has(video:hover) .video-fullscreen-btn.edit-mode,
    .video-wrapper:has(.video-overlay:hover) .video-fullscreen-btn.edit-mode {
      opacity: 0;
      pointer-events: none;
    }

    .video-nav-arrow {
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: rgba(40, 40, 40, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.7);
      font-size: 18px;
      line-height: 1;
      display: none;
      align-items: center;
      justify-content: center;
      padding-bottom: 2px;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
      z-index: 10;
    }

    .video-nav-arrow.visible {
      display: flex;
    }

    .video-nav-arrow:hover:not(.disabled) {
      background: rgba(60, 60, 60, 0.95);
      color: rgba(255, 255, 255, 0.9);
    }

    .video-nav-arrow.visible.disabled {
      display: flex;
      background: rgba(30, 30, 30, 0.9);
      border-color: rgba(255, 255, 255, 0.05);
      color: rgba(255, 255, 255, 0.15);
      cursor: default;
      pointer-events: none;
    }

    .video-nav-arrow.left {
      left: 24px;
      transform: translate(-50%, -50%);
      padding-right: 1px;
    }

    .video-nav-arrow.right {
      right: 24px;
      transform: translate(50%, -50%);
      padding-left: 1px;
    }

    .video-empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      aspect-ratio: 393 / 852;
      height: calc(100vh - 158px);
      max-height: 85%;
      max-width: 90%;
      border: 2px dashed rgba(255, 255, 255, 0.18);
      border-radius: 37px;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      flex-shrink: 0;
    }

    .video-empty-state:hover {
      border-color: rgba(255, 255, 255, 0.2);
      background: rgba(255, 255, 255, 0.02);
    }

    .video-empty-state.hidden {
      display: none;
    }

    .video-empty-state-btn {
      padding: 8px 16px;
      border-radius: 8px;
      background: #222;
      color: #e0e0e0;
      border: 1px solid #444;
      font-size: 13px;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s ease;
      position: relative;
      z-index: 1;
      min-height: 40px;
      box-sizing: border-box;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }

    .video-empty-state:hover .video-empty-state-btn {
      background: #444;
      border-color: #555;
    }

    .video-description {
      position: absolute;
      top: 100%;
      left: 10px;
      right: 10px;
      text-align: center;
      margin-top: 7px;
    }

    .video-description-input {
      width: 100%;
      height: 22px;
      background: transparent;
      border: none;
      color: rgba(255, 255, 255, 0.7);
      font-family: 'Airbnb Cereal VF', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 13px;
      font-weight: 300;
      text-align: center;
      padding: 2px 8px;
      margin: 0;
      resize: none;
      outline: none;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      line-height: 18px;
      border-radius: 4px;
      cursor: text;
      box-sizing: border-box;
    }

    .video-description-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    .video-description-input:hover {
      background: #222222;
    }

    .video-description-input:hover::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    .video-description-input:focus {
      background: #252525;
      outline: 1px solid #4a90e2;
      outline-offset: 2px;
    }

    .video-description-input:focus::placeholder {
      color: transparent;
    }

    body[data-mode='read'] .video-description-input {
      pointer-events: auto;
      color: rgba(255, 255, 255, 0.7);
      cursor: text;
      user-select: text;
      -webkit-user-select: text;
    }

    body[data-mode='read'] #pageTitle {
      user-select: text;
      -webkit-user-select: text;
      cursor: text;
    }

    body[data-mode='read'] .video-description-input::placeholder {
      color: transparent;
    }

    body[data-mode='read'] .video-description-input:hover {
      background: transparent;
      outline: none;
    }

    body[data-mode='read'] .video-description:has(.video-description-input:placeholder-shown) {
      display: none;
    }

    .playback-controls {
      display: none;
    }

    .timeline-wrapper {
      display: flex;
      flex-direction: column;
      height: calc(100vh - 96px); /* Same height as video section */
      min-height: calc(100vh - 96px);
      position: relative;
      --description-height: 50px; /* Default height of description container + margin */
    }

    .timeline-description-container {
      background: #1f1f1f;
      border-radius: 8px;
      padding: 6px 12px 6px 20px;
      border: none;
      margin-bottom: 10px;
      min-height: 40px;
      box-sizing: border-box;
      flex-shrink: 0;
      position: relative;
      z-index: 2;
      display: flex;
      align-items: center;
      transition: background-color 0.15s ease;
    }

    body:not([data-mode='read']) .timeline-description-container:hover {
      background: #262626;
    }

    .timeline-description-input {
      width: 100%;
      min-height: 16px;
      background: transparent;
      border: none;
      color: rgba(255, 255, 255, 0.7);
      font-family: 'Airbnb Cereal VF', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 13px;
      font-weight: 300;
      text-align: left;
      padding: 0;
      margin: 0;
      resize: none;
      outline: none;
      overflow: hidden;
      line-height: 18px;
      cursor: text;
      box-sizing: border-box;
    }

    .timeline-description-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    .timeline-description-input:focus::placeholder {
      color: transparent;
    }

    body[data-mode='read'] .timeline-description-input {
      pointer-events: auto;
      cursor: text;
      user-select: text;
      -webkit-user-select: text;
    }

    body[data-mode='read'] .timeline-description-input::placeholder {
      color: transparent;
    }

    /* Hide description container if all tabs have empty descriptions */
    body[data-mode='read'].no-descriptions .timeline-description-container {
      display: none;
    }

    body[data-mode='read'].no-descriptions .timeline-wrapper {
      --description-height: 0px;
    }

    body[data-mode='read'].no-descriptions .timeline-wrapper::before {
      top: 0;
    }

    .tabs-container {
      padding-top: 6px; /* Gap between backing container top and tabs */
      flex-shrink: 0;
    }

    /* Backing container behind tabs and timeline */
    .timeline-wrapper::before {
      content: '';
      position: absolute;
      top: var(--description-height); /* Below description container */
      left: 0;
      right: 0;
      bottom: 0;
      background: #1a1a1a;
      border: 1px solid #2e2e2e;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      pointer-events: none;
      z-index: 0;
    }

    .timeline-section {
      background: #282828;
      border-radius: 8px;
      padding: 8px;
      overflow: visible;
      border: 1px solid #3e3e3e;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    .timeline-section:has(#timelineContent:empty) {
      min-height: calc(100vh - 96px);
    }

    #timelineContent {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    .playhead-time {
      font-size: 12.5px;
      color: #7db3ea;
      font-weight: 500;
      height: 44px;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 0 12px;
      border-bottom: 1px solid #333;
      box-sizing: border-box;
      background: transparent;
    }

    .playhead-time #playPauseBtn {
      padding: 0;
      background: #4a90e2;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      color: white;
      cursor: pointer;
      font-size: 11px;
      width: 52px;
      height: 29px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
    }

    .playhead-time #playPauseBtn:hover {
      background: #5a9ee8;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .playhead-time #playPauseBtn .icon {
      font-size: 12px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: translate(1px, 0px) scale(0.95);
    }

    .playhead-time #playPauseBtn .icon svg {
      width: 10px;
      height: 12px;
      fill: white;
    }

    .playhead-time #playPauseBtn .icon.pause {
      font-size: 16px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: none;
    }

    .playhead-time #playPauseBtn .icon.pause svg {
      width: 10px;
      height: 12px;
    }

    .settings-btn {
      padding: 0;
      background: #333;
      border: 1px solid #555;
      border-radius: 50%;
      width: 29px;
      height: 29px;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
      opacity: 0.8;
      transition: opacity 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: -2px;
    }

    .settings-btn:hover {
      opacity: 1;
      background: #3a3a3a;
    }

    .settings-btn:active,
    .settings-btn:focus {
      outline: none;
    }

    .settings-btn svg {
      width: 14px;
      height: 16px;
    }

    .settings-btn.active {
      opacity: 1;
      border-color: #555;
    }

    .settings-popup {
      position: fixed;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 14px 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      z-index: 10000;
      min-width: 180px;
      opacity: 0;
      transform: scale(0.95);
      transform-origin: top center;
      pointer-events: none;
      transition: opacity 0.15s ease, transform 0.15s ease;
    }

    .settings-popup.visible {
      opacity: 1;
      transform: scale(1);
      pointer-events: auto;
    }

    .settings-popup::before {
      content: '';
      position: absolute;
      top: -6px;
      left: 69px;
      width: 10px;
      height: 10px;
      background: #2a2a2a;
      border-left: 1px solid #444;
      border-top: 1px solid #444;
      transform: rotate(45deg);
    }

    .settings-section {
      margin-bottom: 20px;
    }

    .settings-section:last-child {
      margin-bottom: 0;
    }

    .settings-label {
      font-size: 12px;
      color: #ffffff;
      margin-bottom: 10px;
    }

    .settings-options {
      display: flex;
      gap: 6px;
    }

    .settings-option {
      padding: 4px 0;
      width: 46px;
      text-align: center;
      background: #3a3a3a;
      border: 1px solid transparent;
      border-radius: 20px;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.15s;
    }

    .settings-option:hover {
      background: #4a4a4a;
    }

    .settings-option.selected {
      background: #666;
      border: 1px solid #888;
      color: white;
    }

    .settings-toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .settings-toggle-label {
      font-size: 12px;
      color: #ffffff;
      margin-right: 12px;
    }

    .toggle-switch {
      position: relative;
      width: 36px;
      height: 20px;
      background: #444;
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .toggle-switch.active {
      background: #4a90e2;
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 16px;
      height: 16px;
      background: white;
      border-radius: 50%;
      transition: transform 0.2s;
    }

    .toggle-switch.active::after {
      transform: translateX(16px);
    }

    /* Help tooltips (export only) */
    .help-btn {
      font-size: 16px;
      font-weight: 400;
      color: white;
    }

    .help-btn.active {
      background: #4a90e2;
      border-color: #4a90e2;
      color: white;
    }

    .help-tooltip {
      position: fixed;
      background: #2a2a2a;
      border: 1px solid #666;
      border-radius: 8px;
      padding: 10px 14px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      z-index: 10001;
      font-size: 14px;
      color: white;
      line-height: 1.4;
      opacity: 0;
      visibility: hidden;
      transform: scale(0.95);
      transition: opacity 0.15s ease, visibility 0.15s ease, transform 0.15s ease;
    }

    .help-tooltip.visible {
      opacity: 1;
      visibility: visible;
      transform: scale(1);
    }

    .help-tooltip.arrow-up-center { transform-origin: top center; }
    .help-tooltip.arrow-down-center { transform-origin: bottom center; }
    .help-tooltip.arrow-right { transform-origin: right center; }
    .help-tooltip.arrow-left { transform-origin: left center; }

    .help-tooltip a {
      color: #4a90e2;
      text-decoration: none;
    }

    .help-tooltip a:hover {
      text-decoration: underline;
    }

    .help-tooltip::before {
      content: '';
      position: absolute;
      width: 10px;
      height: 10px;
      background: #2a2a2a;
      border-left: 1px solid #666;
      border-top: 1px solid #666;
    }

    .help-tooltip.arrow-up::before {
      top: -6px;
      left: 20px;
      transform: rotate(45deg);
    }

    .help-tooltip.arrow-down::before {
      bottom: -6px;
      left: 20px;
      transform: rotate(225deg);
    }

    .help-tooltip.arrow-left::before {
      left: -6px;
      top: 50%;
      margin-top: -5px;
      transform: rotate(-45deg);
    }

    .help-tooltip.arrow-right::before {
      right: -6px;
      top: 50%;
      margin-top: -5px;
      transform: rotate(135deg);
    }

    .help-tooltip.arrow-up-right::before {
      top: -6px;
      right: 20px;
      left: auto;
      transform: rotate(45deg);
    }

    .help-tooltip.arrow-up-center::before {
      top: -6px;
      left: 50%;
      margin-left: -5px;
      transform: rotate(45deg);
    }

    .help-tooltip.arrow-down-center::before {
      bottom: -6px;
      left: 50%;
      margin-left: -5px;
      transform: rotate(225deg);
    }

    .help-scrim {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s ease, visibility 0.2s ease;
      pointer-events: none;
    }

    .help-scrim.visible {
      opacity: 1;
      visibility: visible;
    }

    .help-scrim svg {
      width: 100%;
      height: 100%;
    }

    /* Zoom controls */
    .zoom-controls {
      position: absolute;
      top: 8px;
      right: 16px;
      display: flex;
      align-items: center;
      background: #2a2a2a;
      border-radius: 6px;
      border: 1px solid #444;
      z-index: 101;
      overflow: visible;
    }

    .zoom-controls::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      right: calc(100% + 1px);
      width: 40px;
      background: linear-gradient(to right, transparent 0%, #0a0a0a 100%);
      pointer-events: none;
    }

    .zoom-btn {
      width: 28px;
      height: 24px;
      background: transparent;
      border: none;
      color: #fff;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .zoom-btn:hover:not(:disabled) {
      background: #3a3a3a;
    }

    .zoom-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .zoom-btn:first-child {
      border-right: 1px solid #444;
    }

    .zoom-duration {
      font-size: 11px;
      color: #fff;
      white-space: nowrap;
      font-variant-numeric: tabular-nums;
      max-width: 0;
      opacity: 0;
      overflow: hidden;
      padding: 0;
      margin: 0;
      border-right: none;
    }

    .zoom-controls:hover .zoom-duration,
    .zoom-controls.input-focused .zoom-duration {
      max-width: 200px;
      opacity: 1;
      padding: 0 8px;
      margin-right: 4px;
      border-right: 1px solid #444;
    }

    .zoom-duration-input {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: #fff;
      font-size: 11px;
      font-family: inherit;
      font-variant-numeric: tabular-nums;
      min-width: 3ch;
      text-align: center;
      outline: none;
      padding: 3px 5px;
      margin: -2px 2px;
      border-radius: 6px;
      box-sizing: content-box;
    }

    .zoom-duration-input:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .zoom-duration-input:focus {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Color picker */
    .color-picker-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      cursor: pointer;
      margin-right: 8px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      transition: border-color 0.15s ease;
      flex-shrink: 0;
    }

    .color-picker-dot:hover {
      border-color: rgba(255, 255, 255, 0.7);
    }

    .color-picker-panel {
      position: absolute;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      opacity: 0;
      transform: scale(0.95) translateY(4px);
      transform-origin: 42px bottom;
      pointer-events: none;
      transition: opacity 0.15s ease, transform 0.15s ease;
    }

    .color-picker-panel.visible {
      opacity: 1;
      transform: scale(1);
      pointer-events: auto;
    }

    .color-picker-panel::before {
      content: '';
      position: absolute;
      bottom: -6px;
      left: 36px;
      width: 12px;
      height: 12px;
      background: #2a2a2a;
      border-right: 1px solid #444;
      border-bottom: 1px solid #444;
      transform: rotate(45deg);
    }

    .color-picker-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 12px;
    }

    .color-option {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.15s ease;
      border: 2px solid transparent;
    }

    .color-option:hover {
      transform: scale(1.1);
    }

    .color-option.selected {
      border-color: rgba(255, 255, 255, 0.7);
      box-shadow: 0 0 0 2px #2a2a2a, 0 0 0 4px rgba(255, 255, 255, 0.3);
    }

    /* Easing autocomplete dropdown */
    .easing-autocomplete {
      position: absolute;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      min-width: 200px;
      max-height: 300px;
      overflow-y: auto;
      opacity: 0;
      transform: scale(0.95);
      transform-origin: top center;
      pointer-events: none;
      transition: opacity 0.15s ease, transform 0.15s ease;
    }

    .easing-autocomplete.visible {
      opacity: 1;
      transform: scale(1);
      pointer-events: auto;
    }

    .easing-autocomplete.anchor-bottom {
      transform-origin: bottom center;
    }

    .easing-autocomplete-item {
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 4px;
      font-size: 12px;
      color: #e0e0e0;
      transition: background 0.15s ease;
      font-family: 'SFMono-Regular', ui-monospace, Menlo, Monaco, 'Roboto Mono', monospace;
    }

    .easing-autocomplete-item:hover {
      background: #3a3a3a;
    }

    .easing-autocomplete-item.spring-preset {
      color: #9fd4ff;
    }

    .easing-autocomplete-item.curve-preset {
      color: #ffb38a;
    }

    /* ===== TABS STYLING ===== */
    .tabs-container {
      position: relative;
      z-index: 100;
      margin-bottom: -1px; /* Overlap border with timeline-section */
    }

    .tabs-bar {
      display: flex;
      gap: 4px;
      background: transparent;
      align-items: flex-end;
      position: relative;
      padding-left: 20px; /* Align tabs with timeline content */
    }

    .tabs-bar-left {
      display: flex;
      gap: 4px;
      align-items: flex-end;
    }

    .tab {
      position: relative;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 12px;
      background: #2a2a2a;
      border: none;
      border-bottom: 1px solid #3e3e3e;
      border-radius: 6px 6px 0 0;
      cursor: grab;
      transition: background 0.15s ease, box-shadow 0.15s ease;
      min-width: 164px;
      max-width: 264px;
      z-index: 1;
      height: 30px;
      box-sizing: border-box;
      box-shadow: inset 0 -4px 6px -3px rgba(0, 0, 0, 0.25);
    }

    .tab.active {
      background: #282828;
      border: 1px solid #3e3e3e;
      border-bottom-color: #282828;
      z-index: 10;
      box-shadow: none;
    }

    .tab.active::before,
    .tab.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      width: 6px;
      height: 6px;
      pointer-events: none;
    }

    .tab.active::before {
      left: -6px;
      background: radial-gradient(circle at top left, transparent 5px, #3e3e3e 5px, #3e3e3e 6px, #282828 6px);
    }

    .tab.active::after {
      right: -6px;
      background: radial-gradient(circle at top right, transparent 5px, #3e3e3e 5px, #3e3e3e 6px, #282828 6px);
    }

    .tab:hover:not(.active) {
      background: #333;
    }

    .tab.dragging {
      opacity: 0.5;
      cursor: grabbing !important;
      z-index: 100; /* Appear above other tabs while dragging */
    }

    /* In read/export mode, tabs aren't draggable */
    body[data-mode="read"] .tab,
    body[data-mode="read"] .tab-name {
      cursor: pointer;
    }

    .tab.drag-over-left {
      border-left: 3px solid #4a9eff;
      padding-left: 9px; /* Adjust for border width */
    }

    .tab.drag-over-right {
      border-right: 3px solid #4a9eff;
      padding-right: 9px; /* Adjust for border width */
    }

    .tab-name {
      flex: 1;
      color: #888;
      font-size: 11px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: grab;
      user-select: none;
      outline: none;
      padding: 2px 4px;
      border-radius: 3px;
    }

    .tab-name[contenteditable="true"] {
      user-select: text;
      background: rgba(255, 255, 255, 0.1);
      cursor: text;
    }

    .tab.active .tab-name {
      color: #ffffff;
    }

    .tab-close {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      background: transparent;
      border: none;
      color: #888;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      padding: 0;
      flex-shrink: 0;
      margin-left: 16px;
      margin-right: -6px;
    }

    .tab-close:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }

    .tab-add-btn {
      position: relative;
      padding: 0;
      background: transparent;
      border: none;
      color: #888;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.15s ease;
      min-width: auto;
      height: 26px;
      width: 26px;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
      margin-left: 0;
      top: -3px;
    }

    .tab-add-btn:hover {
      color: #fff;
    }
    /* ===== END TABS STYLING ===== */

    /* DevTools-style timeline */
    .timeline-outer-wrapper {
      flex: 1;
      min-height: 0;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      overflow-y: auto;
      overflow-x: hidden;
      position: relative;
      display: flex;
      flex-direction: column;
    }

    .timeline-outer-wrapper:has(+ #detailPanel:not(:empty)) {
      border-radius: 4px 4px 6px 6px;
    }

    /* Dark theme scrollbar styling for timeline */
    .timeline-outer-wrapper::-webkit-scrollbar {
      width: 8px;
    }

    .timeline-outer-wrapper::-webkit-scrollbar-track {
      background: #0a0a0a;
      border-radius: 0 4px 4px 0;
    }

    .timeline-outer-wrapper::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 4px;
      border: 1px solid #111;
    }

    .timeline-outer-wrapper::-webkit-scrollbar-thumb:hover {
      background: #666;
    }

    .timeline-header-row {
      display: grid;
      grid-template-columns: 180px 1fr;
      gap: 0;
      position: sticky;
      top: 0;
      z-index: 100;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      flex-shrink: 0;
    }

    .timeline-container {
      display: grid;
      grid-template-columns: 180px 1fr;
      gap: 0;
      position: relative;
      flex: 1;
    }

    .timeline-content-column {
      position: relative;
      background: #1a1a1a;
    }

    /* Dark theme scrollbar styling */
    .timeline-container::-webkit-scrollbar {
      width: 12px;
    }

    .timeline-container::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 0 6px 6px 0;
    }

    .timeline-container::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 6px;
      border: 2px solid #1a1a1a;
    }

    .timeline-container::-webkit-scrollbar-thumb:hover {
      background: #fff;
    }

    .timeline-labels-column {
      background: #0a0a0a;
      overflow: visible;
    }

    .timeline-bottom-divider {
      border-top: 1px solid #4a4a4a;
      margin-top: 15px;
      height: 15px;
      position: relative;
    }

    .timeline-bottom-track {
      border-top: 1px solid #4a4a4a;
      margin-top: 15px;
      height: 15px;
      border-bottom: none;
    }

    .timeline-bottom-track .table-cell {
      border-right: none !important;
    }

    .timeline-ruler {
      height: 44px;
      background: transparent;
      border-bottom: 1px solid #333;
      margin-bottom: 0;
      box-sizing: border-box;
      padding-right: 80px;
      position: relative;
    }

    .timeline-tick {
      font-size: 11px;
      color: #e0e0e0;
      padding-left: 6px;
      display: flex;
      align-items: center;
      height: 100%;
      white-space: nowrap;
    }

    .timeline-rows {
      position: relative;
    }

    .timeline-row {
      min-height: 32px;
      border-bottom: 1px solid #2a2a2a; /* Match vertical grid lines */
      position: relative;
    }

    .timeline-row:hover .timeline-label,
    .timeline-row:hover .timeline-track {
      background: #282828;
    }
    .timeline-row:hover .timeline-label-text {
      color: #ffffff;
      opacity: 1;
    }

    /* Table mode hover effect */
    body.table-view-active .timeline-label.table-hover {
      background: #121212;
      color: #ffffff;
    }
    body.table-view-active .timeline-label.table-hover .timeline-label-text {
      color: #ffffff;
      opacity: 1;
    }

    body.table-view-active .timeline-track.table-row.table-hover,
    body.table-view-active .timeline-track.table-row.table-hover .table-cell {
      background: #1e1e1e;
    }

    .timeline-label.layer-header {
      font-weight: 600;
      font-size: 12.5px;
      border-bottom: 1px solid #222222; /* Left column slightly darker */
      height: 32px;
    }

    .timeline-track.layer-header {
      background: transparent;
      font-weight: 600;
      border-bottom: 1px solid #2a2a2a; /* Match vertical grid lines */
      height: 32px;
    }

    /* Default: 16px section gap for short specs without scrollbar */
    .timeline-label.layer-header.has-divider,
    .timeline-track.layer-header.has-divider {
      border-top: 1px solid #555;
      margin-top: 15px;
    }

    .timeline-label.layer-header.has-divider {
      padding-top: 0;
      padding-bottom: 0;
    }

    /* Compact: 0px section gap for longer specs with scrollbar */
    .timeline-outer-wrapper.has-scroll .timeline-label.layer-header.has-divider,
    .timeline-outer-wrapper.has-scroll .timeline-track.layer-header.has-divider {
      margin-top: 0;
    }

    .timeline-label.layer-header:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .timeline-label.layer-header.selected {
      background: rgba(255, 255, 255, 0.08);
    }

    .timeline-label.layer-header.selected .timeline-label-text {
      font-weight: 700;
    }

    .timeline-track.layer-header:hover {
      background: transparent;
    }

    .timeline-label {
      padding: 8px 12px;
      font-size: 12px;
      color: #ffffff;
      display: flex;
      align-items: center;
      justify-content: space-between;
      white-space: nowrap;
      overflow: visible;
      text-overflow: ellipsis;
      height: 32px;
      border-bottom: 1px solid #222222; /* Left column slightly darker */
      position: relative;
      box-sizing: border-box;
      cursor: grab;
    }

    .timeline-label:active {
      cursor: grabbing;
    }

    .timeline-label-text {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: #ffffff;
    }

    .timeline-label-text[contenteditable="true"] {
      outline: 1px solid #3a3a3a;
      outline-offset: 2px;
      background: #252525;
      padding: 2px 4px;
      margin: -2px -4px;
      border-radius: 3px;
      cursor: text;
      overflow: visible;
      white-space: normal;
    }

    .timeline-label:hover .timeline-label-text {
      color: #ffffff;
      opacity: 1;
    }

    .timeline-label-add-btn {
      position: absolute;
      right: 8px;
      bottom: 0;
      transform: translateY(50%);
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #2a2a2a;
      border: 1px solid #555;
      color: #ccc;
      font-size: 16px;
      font-weight: bold;
      line-height: 23px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      transition: opacity 0.15s ease, background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
      pointer-events: none;
      opacity: 0;
    }

    .timeline-label-add-btn.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .timeline-label-add-btn:hover {
      background: #4a4a4a;
      border-color: #666;
      color: #fff;
    }

    /* Section divider add button */
    .section-divider-add-btn {
      position: absolute;
      left: 50%;
      top: 0;
      transform: translate(-50%, -50%);
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #2a2a2a;
      border: 1px solid #555;
      color: #ccc;
      font-size: 16px;
      font-weight: bold;
      line-height: 23px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      transition: opacity 0.15s ease, background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
      pointer-events: none;
      opacity: 0;
    }

    .section-divider-add-btn.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .section-divider-add-btn:hover {
      background: #4a4a4a;
      border-color: #666;
      color: #fff;
    }

    .timeline-label.dragging {
      opacity: 0.5;
    }

    .timeline-bar.dragging-vertical {
      opacity: 0.5;
      cursor: grabbing !important;
    }

    /* Drop indicators - only on labels, extended to span full timeline width */
    .timeline-label.drag-over-top::before,
    .timeline-label.drag-over-bottom::after {
      content: '';
      position: absolute;
      left: 0;
      right: -3000px; /* Extend across entire timeline width */
      height: 2px;
      background: #4a90e2;
      z-index: 1000;
      pointer-events: none;
    }

    /* Track indicators for label-based dragging */
    .timeline-track.drag-over-top::before,
    .timeline-track.drag-over-bottom::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: #4a90e2;
      z-index: 1000;
      pointer-events: none;
    }

    .timeline-label.drag-over-top::before,
    .timeline-track.drag-over-top::before {
      top: -1px;
    }

    .timeline-label.drag-over-bottom::after,
    .timeline-track.drag-over-bottom::after {
      bottom: -1px;
    }

    .timeline-bottom-divider.drag-over-top,
    .timeline-bottom-track.drag-over-top {
      border-top-color: #4a90e2;
      border-top-width: 2px;
    }

    .timeline-label.indented {
      padding-left: 32px;
      color: #b0b0b0;
      position: relative;
    }

    /* Child layer's own animations - extra indent to show hierarchy */
    .timeline-label.indented.child-anim {
      padding-left: 48px;
    }

    .timeline-label.indented .timeline-label-text {
      opacity: 0.75;
    }

    .timeline-label.indented:hover .timeline-label-text {
      color: #ffffff;
      opacity: 1;
    }

    .timeline-label.indented.selected {
      color: #ffffff;
      background: rgba(255, 255, 255, 0.08);
    }

    .timeline-label.indented.selected .timeline-label-text {
      color: #ffffff;
      opacity: 1;
    }

    /* Hover state when hovering the corresponding timeline bar */
    .timeline-label.indented.bar-hover .timeline-label-text {
      color: #ffffff;
      opacity: 1;
    }

    /* Hover state for child layer header when hovering attached bar */
    .timeline-label.child-layer-header.bar-hover {
      color: #ffffff;
    }

    /* Selected state for child layer header */
    .timeline-label.child-layer-header.selected {
      background: rgba(255, 255, 255, 0.08);
    }

    .timeline-label.child-layer-header.selected .timeline-label-text {
      color: #ffffff;
      font-weight: 700;
    }

    /* ===== Child Layer Nesting Connectors ===== */

    /* Vertical line on rows that are part of a parent with children */
    .timeline-label.indented.has-child-line::before {
      content: '';
      position: absolute;
      left: 15px;
      top: -4px;
      bottom: -9px; /* Extend to bridge 8px margin gap before first child layer */
      width: 1px;
      background: #fff;
      z-index: 0;
    }

    /* Child layer header - same indent as other param rows */
    .timeline-label.child-layer-header {
      padding-left: 32px;
      font-weight: 600;
      font-size: 12.5px;
      color: #ffffff;
      position: relative;
    }

    /* All child layer headers get top margin and border (visual separation) */
    .timeline-label.child-layer-header {
      margin-top: 15px;
      border-top: 1px solid #222222; /* Left column slightly darker */
    }

    .timeline-label.child-layer-header:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    /* Delete button above the tree connector line */
    .timeline-label.child-layer-header .param-action-btn {
      z-index: 5;
    }

    /* Attached to text in timeline mode - dashed border bar positioned like other bars */
    .timeline-track.child-layer-header:not(.table-row) {
      position: relative;
      margin-top: 15px;
      border-top: 1px solid #2a2a2a; /* Match other grid lines */
    }

    /* In table mode, child layer header should use normal table row layout */
    body.table-view-active .timeline-track.child-layer-header.table-row {
      display: grid;
      margin-top: 15px;
      border-top: 1px solid #2a2a2a; /* Right column lighter */
      position: relative;
    }

    /* Extend vertical grid lines through the gap above all child layers in table mode */
    body.table-view-active .timeline-track.child-layer-header.table-row::before {
      content: '';
      position: absolute;
      top: -15px;
      left: 0;
      right: 0;
      height: 15px;
      background: linear-gradient(to right,
        transparent calc(100% - var(--table-easing-width, 200px) - 160px - 1px),
        #2e2e2e calc(100% - var(--table-easing-width, 200px) - 160px - 1px),
        #2e2e2e calc(100% - var(--table-easing-width, 200px) - 160px),
        transparent calc(100% - var(--table-easing-width, 200px) - 160px),
        transparent calc(100% - var(--table-easing-width, 200px) - 80px - 1px),
        #2e2e2e calc(100% - var(--table-easing-width, 200px) - 80px - 1px),
        #2e2e2e calc(100% - var(--table-easing-width, 200px) - 80px),
        transparent calc(100% - var(--table-easing-width, 200px) - 80px),
        transparent calc(100% - var(--table-easing-width, 200px) - 1px),
        #2e2e2e calc(100% - var(--table-easing-width, 200px) - 1px),
        #2e2e2e calc(100% - var(--table-easing-width, 200px)),
        transparent calc(100% - var(--table-easing-width, 200px))
      );
      pointer-events: none;
    }

    /* Vertical line segment connecting from top to the curve (all child headers have 15px margin-top) */
    .timeline-label.child-layer-header::before {
      content: '';
      position: absolute;
      left: 15px;
      top: -21px;
      height: calc(50% - 10px + 21px);
      width: 1px;
      background: #fff;
      z-index: 0;
    }

    /* Curved branch connector (L-shape with rounded corner) */
    .timeline-label.child-layer-header::after {
      content: '';
      position: absolute;
      left: 15px;
      top: calc(50% - 10px);
      width: 9px;
      height: 10px;
      border-left: 1px solid #fff;
      border-bottom: 1px solid #fff;
      border-bottom-left-radius: 5px;
      background: transparent;
      z-index: 0;
    }

    /* When there are more siblings below, extend vertical line to bottom */
    .timeline-label.child-layer-header.has-siblings::before {
      height: auto;
      top: -21px;
      bottom: -16px; /* Extend through the 15px gap to next child header */
    }

    /* Continue vertical line through child rows when more children below */
    .timeline-label.indented.child-continues::before {
      content: '';
      position: absolute;
      left: 15px;
      top: -6px;
      bottom: -16px; /* Extend through the 15px gap to next child header */
      width: 1px;
      background: #fff;
      z-index: 0;
    }

    /* Child layer headers - grab cursor when draggable in edit mode */
    .timeline-label.child-layer-header[draggable="true"] {
      cursor: grab;
    }

    .timeline-label.child-layer-header[draggable="true"]:active {
      cursor: grabbing;
    }

    .timeline-label.child-layer-header[draggable="false"] {
      cursor: default;
    }

    /* Child layer header drag indicators - override tree connector pseudo-elements with drag indicator */
    .timeline-label.child-layer-header.drag-over-top::before {
      content: '';
      position: absolute;
      left: 0;
      right: -3000px;
      top: -1px;
      height: 2px;
      width: auto;
      background: #4a90e2;
      border: none;
      border-radius: 0;
      z-index: 1000;
      pointer-events: none;
    }

    .timeline-label.child-layer-header.drag-over-bottom::after {
      content: '';
      position: absolute;
      left: 0;
      right: -3000px;
      bottom: -1px;
      top: auto;
      height: 2px;
      width: auto;
      background: #4a90e2;
      border: none;
      border-radius: 0;
      z-index: 1000;
      pointer-events: none;
    }

    /* Child layer header track (right column) drag indicators */
    .timeline-track.child-layer-header.drag-over-top::before {
      content: '';
      position: absolute;
      left: -3000px;
      right: 0;
      top: -1px;
      height: 2px;
      width: auto;
      background: #4a90e2;
      border: none;
      border-radius: 0;
      z-index: 1000;
      pointer-events: none;
    }

    .timeline-track.child-layer-header.drag-over-bottom::after {
      content: '';
      position: absolute;
      left: -3000px;
      right: 0;
      bottom: -1px;
      top: auto;
      height: 2px;
      width: auto;
      background: #4a90e2;
      border: none;
      border-radius: 0;
      z-index: 1000;
      pointer-events: none;
    }

    /* Child animation row drag indicators (for dropping child-layers after siblings) */
    .timeline-label.child-anim.drag-over-bottom::after {
      content: '';
      position: absolute;
      left: 0;
      right: -3000px;
      bottom: -1px;
      top: auto;
      height: 2px;
      width: auto;
      background: #4a90e2;
      border: none;
      border-radius: 0;
      z-index: 1000;
      pointer-events: none;
    }

    /* Red circle button for parameters */
    .param-action-btn {
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3d2a2a;
      border: 1px solid rgba(231, 76, 60, 0.4);
      box-shadow: 0 0 0 2px #0a0a0a;
      cursor: pointer;
      opacity: 0;
      pointer-events: none;
      padding: 0;
      transition: opacity 0.15s ease, background 0.15s ease, border-color 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: #e74c3c;
      line-height: 1;
    }

    .param-action-btn::before {
      content: '';
      font-weight: bold;
      position: relative;
      top: 0.5px;
    }

    .param-action-btn:hover {
      background: #4d2f2f;
      border-color: rgba(231, 76, 60, 0.6);
    }

    .param-action-btn.visible {
      opacity: 1;
      pointer-events: auto;
    }

    /* Hide delete button when dragging */
    .timeline-label.dragging .param-action-btn {
      opacity: 0;
      pointer-events: none;
    }

    .timeline-track {
      position: relative;
      height: 32px;
      border-bottom: 1px solid #2a2a2a; /* Match vertical grid lines */
      display: flex;
      align-items: center;
      padding-right: 80px;
      margin-right: -80px;
      overflow: visible; /* Changed from hidden to allow drop indicators to extend */
      box-sizing: border-box;
    }

    .table-row {
      display: grid;
      grid-template-columns: minmax(220px, 1fr) 80px 80px var(--table-easing-width, 200px);
      align-items: center;
      padding: 0 12px;
      padding-right: 0;
      margin-right: 0;
      column-gap: 0;
    }

    .timeline-ruler.table-row {
      display: grid;
      grid-template-columns: minmax(220px, 1fr) 80px 80px var(--table-easing-width, 200px);
      padding-right: 0;
    }

    .timeline-ruler.table-row.table-row--header {
      border-left: 1px solid #222222;
      margin-left: -1px;
    }

    .timeline-track.table-row {
      display: grid;
      grid-template-columns: minmax(220px, 1fr) 80px 80px var(--table-easing-width, 200px);
      padding-right: 0;
      margin-right: 0;
    }

    .table-cell {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      height: 100%;
      font-size: 12px;
      padding: 0 12px;
      box-sizing: border-box;
      user-select: text;
      cursor: text;
    }

    .table-cell.editable-cell[contenteditable="true"] {
      cursor: text;
      outline: none;
    }

    .table-cell.editable-cell[contenteditable="true"]:focus {
      background: #252525;
      outline: 1px solid #3a3a3a;
      outline-offset: -1px;
    }

    .table-cell.editable-cell[contenteditable="true"]:hover:not(:focus) {
      background: #222222;
    }

    .table-cell--desc {
      display: flex;
      align-items: center;
      height: 100%;
      padding-left: 0;
      padding-right: 12px;
      border-right: 1px solid #2e2e2e; /* Lighter for data rows */
      color: #c0c0c0;
      white-space: normal;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .table-desc-text {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      line-height: 1.4;
      word-break: break-word;
      overflow-wrap: anywhere;
      max-height: calc(1.4em * 2);
      width: 100%;
    }

    .table-cell--delay,
    .table-cell--duration {
      border-right: 1px solid #2e2e2e; /* Lighter for data rows */
      color: #c0c0c0;
      font-family: 'SFMono-Regular', ui-monospace, Menlo, Monaco, 'Roboto Mono', monospace;
    }

    .table-cell--easing {
      color: #c0c0c0;
      font-size: 12px;
      white-space: nowrap;
      padding-right: 12px;
    }

    .table-cell--easing .num {
      color: #6DB3E8;
      font-family: monospace;
      display: inline;
      white-space: pre;
    }

    .table-row--header .table-cell {
      font-weight: 600;
      color: #ffffff;
      font-family: inherit;
      font-size: 12.5px;
    }

    .table-row--header .table-cell--easing {
      font-size: 12.5px;
      font-family: inherit;
    }

    .table-row--header .table-cell--desc,
    .table-row--header .table-cell--delay,
    .table-row--header .table-cell--duration {
      border-right: 1px solid #222222;
    }

    .table-row--layer .table-cell {
      font-weight: 600;
      color: inherit;
      border-right: 1px solid #2e2e2e; /* Lighter for data rows */
    }

    .table-row--layer .table-cell:last-child {
      border-right: none;
    }

    .table-row:not(.table-row--header) .table-desc-text {
      font-size: 12px;
      color: #d8d8d8;
    }

    .table-row:not(.table-row--header) .table-cell--delay,
    .table-row:not(.table-row--header) .table-cell--duration {
      font-family: 'SFMono-Regular', ui-monospace, Menlo, Monaco, 'Roboto Mono', monospace;
      font-size: 12px;
      color: #d8d8d8;
    }

    .table-row:not(.table-row--header) .table-cell--easing {
      font-size: 12px;
      color: #d8d8d8;
    }

    /* Child layer description (Scales to fit / Attached to) in light blue */
    .table-row--child-layer .table-cell--desc .table-desc-text {
      color: #6DB3E8;
    }

    .timeline-track.table-row.table-row--layer {
      margin-top: 0;
      padding-top: 0;
      border-top: none;
    }

    /* Default: 16px section gap for short specs */
    .timeline-track.table-row.table-row--layer.has-divider {
      margin-top: 15px;
      padding-top: 0;
      border-top: 1px solid #555;
    }

    body.table-view-active .timeline-label.layer-header.has-divider {
      margin-top: 15px;
      padding-top: 0;
      border-top: 1px solid #555;
    }

    /* Compact: 0px section gap for specs with scrollbar */
    .timeline-outer-wrapper.has-scroll .timeline-track.table-row.table-row--layer.has-divider,
    body.table-view-active .timeline-outer-wrapper.has-scroll .timeline-label.layer-header.has-divider {
      margin-top: 0;
    }

    body.table-view-active .timeline-label.layer-header {
      border-bottom: 1px solid #222222; /* Left column slightly darker */
      padding: 0 12px;
    }

    body.table-view-active .timeline-label {
      height: 32px;
      border-bottom: 1px solid #222222; /* Left column slightly darker */
      box-sizing: border-box;
    }

    body.table-view-active .timeline-label.layer-header {
      border-bottom: 1px solid #222222; /* Left column slightly darker */
    }

    body.table-view-active .timeline-label.indented {
      padding-left: 32px;
      border-bottom: 1px solid #222222; /* Left column slightly darker */
    }

    body.table-view-active .timeline-label.indented.child-anim {
      padding-left: 48px;
    }

    /* Child layer header in table mode */
    body.table-view-active .timeline-label.child-layer-header {
      padding: 0 12px;
      padding-left: 32px;
    }

    body.table-view-active .timeline-label.child-layer-header:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    body.table-view-active .timeline-track.table-row {
      height: 32px;
    }

    .table-gap-label {
      height: 8px;
      min-height: 8px;
      border-top: none;
      border-bottom: none;
      background: #0a0a0a;
      padding: 0;
      cursor: default;
      display: flex;
      align-items: center;
    }

    .table-gap-row {
      height: 8px;
      min-height: 8px !important;
      border-top: 1px solid #222222;
      border-bottom: none !important;
    }

    .table-gap-row .table-cell {
      padding: 0;
      border-right: 1px solid #222222;
      height: 100%;
      min-height: inherit;
    }

    .table-gap-row .table-cell:last-child {
      border-right: none;
    }

    .timeline-bar {
      position: absolute;
      height: 24px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      padding: 0 8px;
      font-size: 11px;
      color: white;
      cursor: grab;
      transition: all 0.1s;
      z-index: 1;
      white-space: nowrap;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.25);
    }

    .timeline-bar:active {
      cursor: grabbing;
    }

    .timeline-bar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 6px;
      pointer-events: none;
      z-index: 10;
    }

    .timeline-bar:hover,
    .timeline-bar.dragging-resize {
      filter: brightness(1.2);
      z-index: 1;
    }

    .timeline-bar.selected {
      filter: brightness(1.15);
      z-index: 2;
      box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.4);
    }

    /* Highlight the track row when its bar is selected */
    .timeline-track:has(.timeline-bar.selected) {
      background: rgba(255, 255, 255, 0.04);
    }

    .timeline-bar.selected.bar-spring {
      box-shadow: none;
    }

    .timeline-bar.selected.bar-spring::before {
      background: rgba(255, 255, 255, 0.4);
      padding: 2px;
    }

    /* Attached bar style - dashed border that fades out */
    .timeline-bar.bar-attached {
      border: none;
      box-shadow: none;
      background: #1a1a1a;
      color: #bbb;
      cursor: pointer;
      min-width: fit-content;
      white-space: nowrap;
      padding-right: 40px;
    }

    /* Fading dashed border using ::before with mask */
    .timeline-bar.bar-attached::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      border: 1px dashed rgba(255, 255, 255, 0.4);
      pointer-events: none;
      -webkit-mask-image: linear-gradient(90deg, #fff 0%, #fff 50%, transparent 100%);
      mask-image: linear-gradient(90deg, #fff 0%, #fff 50%, transparent 100%);
    }

    .timeline-bar.bar-attached:hover {
      filter: brightness(1.3);
    }

    .timeline-bar.bar-attached .timeline-bar-text[contenteditable="true"] {
      cursor: pointer;
    }

    .timeline-bar.bar-attached.selected {
      color: #fff;
      box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.5);
      filter: none;
    }

    .timeline-bar-text {
      position: relative;
      z-index: 5;
    }

    .timeline-bar-text[contenteditable="true"] {
      cursor: grab;
      outline: none;
      user-select: none;
      white-space: nowrap;
    }

    .timeline-bar-text[contenteditable="true"]:focus {
      cursor: text;
      user-select: text;
      outline: 1px solid #4a90e2;
      outline-offset: 2px;
      background: #252525;
      border-radius: 3px;
      padding: 2px 4px;
      margin: -2px -4px;
    }

    /* Resize handles */
    .timeline-bar-resize-handle {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 8px;
      cursor: ew-resize !important;
      z-index: 15;
    }

    .timeline-bar-resize-handle.left {
      left: 0;
    }

    .timeline-bar-resize-handle.right {
      right: 0;
    }

    /* Text fade overlays - match each bar's background color */
    .timeline-bar.has-text-overflow::after {
      content: '';
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 40px;
      pointer-events: none;
      z-index: 10;
      border-radius: 0 6px 6px 0;
    }

    .timeline-bar.has-text-overflow.bar-opacity::after {
      background: linear-gradient(to right, rgba(5, 110, 83, 0) 0%, rgba(5, 110, 83, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-scale::after {
      background: linear-gradient(to right, rgba(125, 41, 160, 0) 0%, rgba(125, 41, 160, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-rotation::after {
      background: linear-gradient(to right, rgba(125, 41, 160, 0) 0%, rgba(125, 41, 160, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-position-x::after,
    .timeline-bar.has-text-overflow.bar-position-y::after {
      background: linear-gradient(to right, rgba(5, 110, 150, 0) 0%, rgba(5, 110, 150, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-width::after,
    .timeline-bar.has-text-overflow.bar-height::after {
      background: linear-gradient(to right, rgba(202, 49, 125, 0) 0%, rgba(202, 49, 125, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-blur::after {
      background: linear-gradient(to right, rgba(89, 89, 89, 0) 0%, rgba(89, 89, 89, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-transform::after {
      background: linear-gradient(to right, rgba(108, 28, 144, 0) 0%, rgba(108, 28, 144, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-default::after {
      background: linear-gradient(to right, rgba(5, 110, 150, 0) 0%, rgba(5, 110, 150, 1) 100%);
    }

    /* Spring bars already fade out, so hide text overflow gradient overlay */
    .timeline-bar.bar-spring.has-text-overflow::after {
      display: none;
    }

    /* Allow text to extend beyond spring bar */
    .timeline-bar.bar-spring {
      overflow: visible;
    }

    /* Property-specific colors (1.2x brighter defaults) */
    .bar-opacity { background: #056e53; }
    .bar-scale { background: #7d29a0; }
    .bar-rotation { background: #6c1c90; }
    .bar-position-x { background: #056e96; }
    .bar-position-y { background: #056e96; }
    .bar-width { background: #ca317d; }
    .bar-height { background: #ca317d; }
    .bar-blur { background: #595959; }
    .bar-transform { background: #6c1c90; }
    .bar-default { background: #056e96; }

    /* Spring gradient fade-out (1.2x brighter defaults) */
    .bar-spring.bar-opacity { background: linear-gradient(90deg, #056e53 0%, #056e53 50%, rgba(5, 110, 83, 0) 100%); }
    .bar-spring.bar-scale { background: linear-gradient(90deg, #7d29a0 0%, #7d29a0 50%, rgba(125, 41, 160, 0) 100%); }
    .bar-spring.bar-rotation { background: linear-gradient(90deg, #6c1c90 0%, #6c1c90 50%, rgba(108, 28, 144, 0) 100%); }
    .bar-spring.bar-position-x { background: linear-gradient(90deg, #056e96 0%, #056e96 50%, rgba(5, 110, 150, 0) 100%); }
    .bar-spring.bar-position-y { background: linear-gradient(90deg, #056e96 0%, #056e96 50%, rgba(5, 110, 150, 0) 100%); }
    .bar-spring.bar-width { background: linear-gradient(90deg, #ca317d 0%, #ca317d 50%, rgba(202, 49, 125, 0) 100%); }
    .bar-spring.bar-height { background: linear-gradient(90deg, #ca317d 0%, #ca317d 50%, rgba(202, 49, 125, 0) 100%); }
    .bar-spring.bar-blur { background: linear-gradient(90deg, #595959 0%, #595959 50%, rgba(89, 89, 89, 0) 100%); }
    .bar-spring.bar-transform { background: linear-gradient(90deg, #6c1c90 0%, #6c1c90 50%, rgba(108, 28, 144, 0) 100%); }
    .bar-spring.bar-default { background: linear-gradient(90deg, #056e96 0%, #056e96 50%, rgba(5, 110, 150, 0) 100%); }

    /* Spring bars - remove base box-shadow, use gradient border instead */
    .bar-spring { box-shadow: none; }

    /* Spring gradient borders that fade out with the fill */
    .bar-spring::before {
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0);
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.25) 50%, rgba(255, 255, 255, 0) 100%);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      padding: 1px;
    }

    .playhead {
      position: fixed;
      width: 2px;
      background: #4a90e2;
      z-index: 200;
      cursor: ew-resize;
      box-shadow: -2px 0 0 0 #1a1a1a, 2px 0 0 0 #1a1a1a;
      pointer-events: none;
    }

    .playhead::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: -10px;
      right: -10px;
      cursor: ew-resize;
      pointer-events: auto;
    }


    .playhead-handle {
      position: absolute;
      top: -1px;
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 8px;
      background: #4a90e2;
      color: #ffffff;
      font-size: 11px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      cursor: ew-resize;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      pointer-events: auto;
      transition: all 0.2s;
      white-space: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }

    .playhead-handle:hover {
      background: #5a9ee8;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
    }

    .detail-panel {
      margin-top: 10px;
      padding: 14px 20px 20px 20px;
      background: #2a2a2a;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-left-width: 3px;
      font-size: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      flex-shrink: 0;
      position: relative;
      z-index: 400;
    }

    .detail-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .detail-panel-title {
      font-weight: 700;
      color: #ffffff;
      font-size: 14px;
      display: flex;
      align-items: center;
      position: relative;
    }

    .detail-title-input {
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      padding: 2px 6px;
      margin-left: -7px;
      font-size: 14px;
      font-weight: 700;
      color: #ffffff;
      font-family: inherit;
      outline: none;
      transition: border-color 0.2s, background-color 0.2s;
      box-sizing: border-box;
      max-width: 200px;
      min-width: 40px;
    }

    .detail-title-input:hover {
      border-color: #555;
      background: rgba(255, 255, 255, 0.03);
    }

    .detail-title-input:focus {
      border-color: #4a90e2;
      background: rgba(255, 255, 255, 0.05);
    }

    .detail-title-input-property {
      margin-left: 2px;
      max-width: 500px;
    }

    .detail-panel-close {
      background: #333;
      border: none;
      color: #e0e0e0;
      font-size: 16px;
      cursor: pointer;
      padding: 0;
      padding-top: 2px;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s;
    }

    .detail-panel-close:hover {
      background: #444;
    }

    .detail-panel-actions {
      display: flex;
      gap: 14px;
      align-items: center;
    }

    .detail-panel-action-btn {
      background: #333;
      border: 1px solid #555;
      color: #e0e0e0;
      font-size: 12px;
      cursor: pointer;
      padding: 6px 12px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      transition: all 0.2s;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      gap: 4px;
    }

    .detail-panel-action-btn:hover {
      background: #444;
      border-color: #666;
    }

    .detail-panel-action-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .detail-panel-action-btn:disabled:hover {
      background: #333;
      border-color: #555;
    }

    .detail-panel-action-btn .arrow {
      font-size: 10px;
    }

    .detail-panel-action-btn.delete {
      background: #333;
      border-color: #664444;
      font-size: 12px;
      font-weight: 500;
      padding: 6px 10px;
      color: #e0e0e0;
    }

    .detail-panel-action-btn.delete:hover {
      background: #444;
      border-color: #775555;
      color: #ffffff;
    }

    .detail-panel-action-btn.delete:disabled:hover {
      background: #333;
      border-color: #664444;
      color: #e0e0e0;
    }

    .detail-panel-separator {
      color: #666;
      font-size: 12px;
      margin: 0 4px;
    }

    .parent-selector-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .parent-selector-label {
      font-size: 11px;
      color: #888;
      white-space: nowrap;
    }

    .parent-selector {
      background: #333;
      border: 1px solid #555;
      color: #e0e0e0;
      font-size: 12px;
      cursor: pointer;
      padding: 4px 28px 4px 8px;
      height: 28px;
      border-radius: 6px;
      transition: all 0.2s;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      min-width: 100px;
      max-width: 160px;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6' viewBox='0 0 10 6'%3E%3Cpath fill='%23888' d='M0 0l5 6 5-6z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
    }

    .parent-selector:hover {
      background-color: #444;
      border-color: #666;
    }

    .parent-selector:focus {
      outline: none;
      border-color: #4a90e2;
    }

    .parent-selector option {
      background: #2a2a2a;
      color: #e0e0e0;
    }

    .detail-description {
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid #333;
      font-size: 13px;
      color: #ffffff;
    }

    .detail-description.no-border {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }

    .detail-description-input {
      width: 100%;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      padding: 6px 8px;
      margin-left: -8px;
      font-size: 13px;
      color: #ffffff;
      font-family: inherit;
      outline: none;
      transition: border-color 0.2s, background-color 0.2s;
      box-sizing: border-box;
    }

    .detail-description-input:hover {
      border-color: #555;
      background: rgba(255, 255, 255, 0.03);
    }

    .detail-description-input:focus {
      border-color: #4a90e2;
      background: rgba(255, 255, 255, 0.05);
    }

    .detail-value-input {
      width: 100%;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      padding: 4px 6px;
      margin-left: -6px;
      font-size: 12px;
      color: #ffffff;
      font-family: 'SFMono-Regular', ui-monospace, Menlo, Monaco, 'Roboto Mono', monospace;
      outline: none;
      transition: border-color 0.2s, background-color 0.2s;
      box-sizing: border-box;
      white-space: normal;
      word-wrap: break-word;
      overflow-wrap: break-word;
      min-height: 24px;
      resize: none;
    }

    .detail-value-input:hover {
      border-color: #555;
      background: rgba(255, 255, 255, 0.03);
    }

    .detail-value-input:focus {
      border-color: #4a90e2;
      background: rgba(255, 255, 255, 0.05);
    }

    .detail-value-input.invalid {
      border-color: #a82929;
    }

    /* Scrollbar styling for textarea inputs */
    .detail-value-input::-webkit-scrollbar {
      width: 8px;
    }

    .detail-value-input::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 4px;
    }

    .detail-value-input::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 4px;
      border: 2px solid #1a1a1a;
    }

    .detail-value-input::-webkit-scrollbar-thumb:hover {
      background: #fff;
    }

    .detail-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1.5fr 1fr 1fr;
      gap: 20px;
      align-items: start;
    }

    .detail-item {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .detail-label {
      color: #999;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      font-weight: 600;
    }

    .detail-value {
      color: #e0e0e0;
      font-weight: 400;
      font-size: 12px;
      line-height: 1.4;
      font-family: 'SFMono-Regular', ui-monospace, Menlo, Monaco, 'Roboto Mono', monospace;
    }

    .detail-value .num {
      color: #6DB3E8 !important;
    }

    .detail-value.easing-editable {
      cursor: text;
      font-size: 12px;
      color: #ffffff;
      line-height: 1.2;
      padding: 4px 6px;
      margin-left: -6px;
    }

    .detail-value.easing-editable:hover {
      background: #222222;
    }

    .spring-params, .bezier-curve {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 13px;
      line-height: 1.4;
      color: #e0e0e0;
    }

    .bezier-curve {
      color: #e0e0e0;
    }

    .spring-link {
      color: #e0e0e0;
      text-decoration: underline;
      cursor: pointer;
      transition: color 0.2s;
    }

    .spring-link:hover {
      color: #ffffff;
    }

    .empty-state {
      padding: 40px 20px;
      color: #666;
      opacity: 0.4;
    }

    .empty-timeline-ruler {
      height: 32px;
      background: #1f1f1f;
      border-bottom: 1px solid #333;
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 60px;
      font-size: 11px;
      color: #555;
    }

    .empty-timeline-tracks {
      padding: 20px;
    }

    .empty-timeline-row {
      display: flex;
      align-items: center;
      height: 32px;
      margin-bottom: 8px;
    }

    .empty-timeline-label {
      width: 150px;
      height: 24px;
      background: #222;
      border-radius: 4px;
      margin-right: 20px;
    }

    .empty-timeline-bar {
      height: 24px;
      background: #252525;
      border-radius: 4px;
      flex: 1;
      max-width: 70%;
    }

    /* Edit/Read Mode System */
    body[data-mode="read"] .edit-only {
      display: none !important;
    }

    body[data-mode="edit"] .read-only {
      display: none !important;
    }

    body[data-mode="read"] .timeline-label,
    body[data-mode="read"] .timeline-label:active,
    body[data-mode="read"] .timeline-bar,
    body[data-mode="read"] .timeline-bar:active {
      cursor: default !important;
    }

    .export-only {
      display: none !important;
    }

    body[data-mode="read"] .export-only {
      display: inline !important;
    }

    /* Adjust grid layout in read mode when resize handle is hidden */
    body[data-mode="read"] .main-content {
      grid-template-columns: 1fr max(560px, min(55vh, 45vw));
      gap: 20px;
    }

  </style>
</head>
<body>
  <div class="container">
    <div class="header-section">
      <h1 id="pageTitle" contenteditable="false">Motion Inspector</h1>
      <div class="view-mode-control">
        <button class="view-mode-btn selected" data-view="timeline" onclick="switchToView('timeline')">Timeline</button>
        <button class="view-mode-btn" data-view="table" onclick="switchToView('table')">Table</button>
      </div>
      <div class="controls">
        <input type="file" id="videoInput" accept="video/*" class="edit-only main-only">
        <button class="btn btn-secondary edit-only main-only" onclick="pasteSpec()">
          <span class="btn-emoji"></span>&nbsp;&nbsp;Paste Spec
        </button>
        <button class="btn btn-secondary edit-only main-only" onclick="exportZip()">
          <span class="btn-emoji"></span>&nbsp;&nbsp;Export Zip
        </button>
      </div>
    </div>

    <div class="main-content">
      <div class="timeline-wrapper">
        <div class="timeline-description-container">
          <textarea id="timelineDescription" class="timeline-description-input" placeholder="Add optional description" rows="1" oninput="try { saveTimelineDescription(this.value); } catch(e) { } try { autoResizeTextarea(this); } catch(e) { }" onfocus="this.select()"></textarea>
        </div>
        <div class="tabs-container">
          <div class="tabs-bar">
            <!-- Tabs will be rendered here by JavaScript -->
          </div>
        </div>
        <div class="timeline-section">
          <div id="timelineContent"></div>
        </div>
      </div>

      <div class="resize-handle edit-only" id="resizeHandle"></div>

      <div class="video-section">
        <div class="video-nav-arrow left" id="videoNavLeft" onclick="switchVideo(-1)"></div>
        <div class="video-nav-arrow right" id="videoNavRight" onclick="switchVideo(1)"></div>
        <div class="video-drop-text">Drop to add video</div>
        <div id="videoEmptyState" class="video-empty-state edit-only" onclick="document.getElementById('videoInput').click()">
          <div class="video-empty-state-btn">
            <span></span>
            <span>Add Video</span>
          </div>
        </div>
        <div id="videoContainer" class="video-container">
          <div class="video-wrapper">
            <video id="videoPlayer"></video>
            <button class="video-fullscreen-btn edit-mode" onclick="toggleVideoFullscreen()" title="Fullscreen">
              <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
            </button>
            <div class="video-overlay edit-only" id="videoOverlay">
              <div class="video-overlay-btn" id="replaceVideoBtn" onclick="document.getElementById('videoInput').click()">
                <span></span>
                <span>Replace Video</span>
              </div>
              <div class="video-overlay-btn" id="addAnotherVideoBtn" onclick="addAnotherVideo()">
                <span style="filter: brightness(10);"></span>
                <span>Add Another Video</span>
              </div>
              <div class="video-overlay-btn" id="deleteVideoBtn" onclick="deleteVideo()" style="display: none;">
                <span></span>
                <span>Delete Video</span>
              </div>
            </div>
            <div class="video-description">
              <textarea id="videoDescription" class="video-description-input" placeholder="Add optional description" rows="1" oninput="saveDescription(this.value)" onfocus="this.select()" onkeydown="if(event.key==='Enter'){event.preventDefault();this.blur();}"></textarea>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== TABS DATA STRUCTURE =====

    // Generate unique video ID
    function generateVideoId() {
      return 'v_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    // Generate unique layer ID
    function generateLayerId() {
      return 'l_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    // Ensure all layers have unique IDs (for backward compatibility with old specs)
    function ensureLayerIds(specData) {
      if (!specData || !specData.layers) return;
      specData.layers.forEach(layer => {
        if (!layer.id) {
          layer.id = generateLayerId();
        }
      });
      // Migrate parenting from parentName to parentId if needed
      specData.layers.forEach(layer => {
        if (layer.parenting && layer.parenting.parentName && !layer.parenting.parentId) {
          // Find parent layer by name and get its ID
          const parentLayer = specData.layers.find(l => l.layerName === layer.parenting.parentName);
          if (parentLayer && parentLayer.id) {
            layer.parenting.parentId = parentLayer.id;
          }
        }
      });
      // Set parentingDescription from fitToShape info if layer has parenting and fitToShape animations
      specData.layers.forEach(layer => {
        if (layer.parenting && !layer.parentingDescription && layer.animations) {
          const fitToShapeAnim = layer.animations.find(a => a.fitToShape || a.isFitToShape);
          if (fitToShapeAnim && fitToShapeAnim.fitToShape) {
            const alignment = getAlignmentText(fitToShapeAnim.fitToShape.alignment);
            const scaleTo = getScaleToText(fitToShapeAnim.fitToShape.scaleTo);
            layer.parentingDescription = `Scales to fit ${scaleTo} of ${fitToShapeAnim.fitToShape.containerLayerName}  Aligned ${alignment}`;
          }
        }
      });
    }

    // Get layer by ID
    function getLayerById(specData, layerId) {
      if (!specData || !specData.layers) return null;
      return specData.layers.find(l => l.id === layerId);
    }

    // Get layer index by ID
    function getLayerIndexById(specData, layerId) {
      if (!specData || !specData.layers) return -1;
      return specData.layers.findIndex(l => l.id === layerId);
    }

    // Spring preset physics parameters
    const springPresetParams = {
      'Standard Spring': { mass: 1, stiffness: 175, damping: 26 },
      'Slow Spring': { mass: 1, stiffness: 100, damping: 20 },
      'Fast Spring': { mass: 1, stiffness: 300, damping: 35 },
      'Slow Bounce Spring': { mass: 1, stiffness: 100, damping: 14 },
      'Medium Bounce Spring': { mass: 1, stiffness: 175, damping: 18.5 },
      'Fast Bounce Spring': { mass: 1, stiffness: 250, damping: 22 }
    };

    // Parse spring parameters from text like "Stiffness: 100, Damping: 10, Mass: 1"
    function parseSpringParams(text) {
      if (!text) return null;
      const lower = text.toLowerCase();

      // Try to extract stiffness, damping, mass
      const stiffnessMatch = lower.match(/stiffness[:\s]+(\d+\.?\d*)/);
      const dampingMatch = lower.match(/damping[:\s]+(\d+\.?\d*)/);
      const massMatch = lower.match(/mass[:\s]+(\d+\.?\d*)/);

      if (stiffnessMatch && dampingMatch) {
        return {
          stiffness: parseFloat(stiffnessMatch[1]),
          damping: parseFloat(dampingMatch[1]),
          mass: massMatch ? parseFloat(massMatch[1]) : 1 // Default mass to 1
        };
      }
      return null;
    }

    // Calculate spring duration from physics parameters (in ms)
    function calculateSpringDuration(stiffness, damping, mass) {
      // Natural frequency (rad/s)
      const omega = Math.sqrt(stiffness / mass);
      // Damping ratio
      const zeta = damping / (2 * Math.sqrt(stiffness * mass));

      // Settling time to ~1% of final value
      // For underdamped (zeta < 1): t  -ln(0.01) / (zeta * omega)
      // For overdamped/critical: use similar approximation
      const threshold = 0.01; // 1% settling
      let duration;

      if (zeta < 1) {
        // Underdamped - oscillates
        duration = -Math.log(threshold) / (zeta * omega);
      } else {
        // Critically damped or overdamped
        duration = -Math.log(threshold) / (zeta * omega);
      }

      // Convert to milliseconds and clamp to reasonable range
      duration = duration * 1000;
      return Math.max(200, Math.min(duration, 3000)); // Clamp between 200ms and 3000ms
    }

    // Get current video's ID (returns 'default' if no video, for pre-video color storage)
    function getCurrentVideoId() {
      const tab = getCurrentTab();
      if (!tab || !tab.videos || tab.videos.length === 0) return 'default';
      const video = tab.videos[tab.currentVideoIndex || 0];
      return video ? video.id : 'default';
    }

    // Get animation color for a specific video
    function getAnimationColorForVideo(anim, videoId) {
      if (!anim || !videoId) return null;
      if (anim.customColorPerVideo && anim.customColorPerVideo[videoId]) {
        return anim.customColorPerVideo[videoId];
      }
      return null;
    }

    // Set animation color for a specific video
    function setAnimationColorForVideo(anim, videoId, color) {
      if (!anim || !videoId) return;
      if (!anim.customColorPerVideo) {
        anim.customColorPerVideo = {};
      }
      anim.customColorPerVideo[videoId] = color;
    }

    // Copy all animation colors from one video to another
    function copyColorsToVideo(specData, fromVideoId, toVideoId) {
      if (!specData || !specData.layers || !fromVideoId || !toVideoId) return;
      specData.layers.forEach(layer => {
        layer.animations.forEach(anim => {
          const color = getAnimationColorForVideo(anim, fromVideoId);
          if (color) {
            setAnimationColorForVideo(anim, toVideoId, color);
          }
        });
      });
    }

    // Create default spec template
    function createDefaultSpec() {
      return {
        compName: "Motion Inspector",
        workArea: {
          duration: 1000
        },
        layers: [
          {
            id: generateLayerId(),
            layerName: "Section 1",
            animations: [
              {
                property: "Add parameter",
                description: "Add description",
                timing: {
                  delay: 0,
                  duration: 300
                },
                easing: {
                  type: "-",
                  cubicBezier: ""
                },
                values: {
                  formatted: {
                    startValue: "-",
                    endValue: "-"
                  }
                }
              }
            ]
          }
        ]
      };
    }

    // Initialize with Tab 1
    const initialSpec = createDefaultSpec();
    groupAnimations(initialSpec);
    ensureLayerIds(initialSpec);
    let tabs = [
      {
        id: 1,
        name: "Tab 1",
        specData: initialSpec,
        videos: [], // Array of { src, file, description }
        currentVideoIndex: 0
      }
    ];
    let currentTabIndex = 0; // Start with Tab 1 active
    let nextTabId = 2;
    const MAX_TABS = 6;
    const MAX_VIDEOS_PER_TAB = 2;

    // Helper functions to get current tab data
    function getCurrentTab() {
      if (currentTabIndex === -1) return null;
      return tabs[currentTabIndex];
    }

    function getCurrentSpecData() {
      if (currentTabIndex === -1) return null;
      return tabs[currentTabIndex].specData;
    }

    function getCurrentVideoSrc() {
      if (currentTabIndex === -1) return null;
      const tab = tabs[currentTabIndex];
      if (!tab.videos || tab.videos.length === 0) return null;
      const video = tab.videos[tab.currentVideoIndex];
      return video ? video.src : null;
    }

    function getCurrentVideo() {
      if (currentTabIndex === -1) return null;
      const tab = tabs[currentTabIndex];
      if (!tab.videos || tab.videos.length === 0) return null;
      return tab.videos[tab.currentVideoIndex];
    }

    function setCurrentSpecData(data) {
      if (currentTabIndex === -1) return;
      tabs[currentTabIndex].specData = data;
    }

    function setCurrentVideoSrc(src) {
      if (currentTabIndex === -1) return;
      const tab = tabs[currentTabIndex];
      if (!tab.videos || tab.videos.length === 0) {
        // Create first video entry and migrate colors from 'default'
        const newVideoId = generateVideoId();
        tab.videos = [{ id: newVideoId, src: src, file: null, description: '' }];
        tab.currentVideoIndex = 0;
        // Copy any colors set before video was added
        copyColorsToVideo(tab.specData, 'default', newVideoId);
      } else {
        tab.videos[tab.currentVideoIndex].src = src;
      }
    }

    function setCurrentUploadedVideoFile(file) {
      if (currentTabIndex === -1) return;
      const tab = tabs[currentTabIndex];
      if (!tab.videos || tab.videos.length === 0) {
        // Create first video entry and migrate colors from 'default'
        const newVideoId = generateVideoId();
        tab.videos = [{ id: newVideoId, src: null, file: file, description: '' }];
        tab.currentVideoIndex = 0;
        // Copy any colors set before video was added
        copyColorsToVideo(tab.specData, 'default', newVideoId);
      } else {
        tab.videos[tab.currentVideoIndex].file = file;
      }
    }

    // Sync legacy variables with current tab
    function syncLegacyVariables() {
      if (currentTabIndex === -1) {
        specData = null;
        uploadedVideoFile = null;
      } else {
        specData = getCurrentSpecData();
        const currentVideo = getCurrentVideo();
        uploadedVideoFile = currentVideo ? currentVideo.file : null;
      }
    }

    // Save description to current video
    function saveDescription(value) {
      if (currentTabIndex === -1) return;
      const tab = tabs[currentTabIndex];
      if (!tab.videos || tab.videos.length === 0) return;
      tab.videos[tab.currentVideoIndex].description = value;
    }

    // Load description from current video
    function loadDescription() {
      const textarea = document.getElementById('videoDescription');
      if (!textarea) return;
      const currentVideo = getCurrentVideo();
      textarea.value = currentVideo ? (currentVideo.description || '') : '';
      // Don't auto-resize for single-line description field
    }

    // Save timeline description to current tab's specData
    function saveTimelineDescription(value) {
      const specData = getCurrentSpecData();
      if (!specData) return;
      specData.description = value;
    }

    // Load timeline description from current tab's specData
    function loadTimelineDescription() {
      const textarea = document.getElementById('timelineDescription');
      if (!textarea) return;
      const specData = getCurrentSpecData();
      textarea.value = specData && specData.description ? specData.description : '';
      autoResizeTextarea(textarea);
    }

    // Auto-resize textarea to fit content
    function autoResizeTextarea(textarea) {
      if (!textarea) return;
      textarea.style.height = 'auto';
      textarea.style.height = textarea.scrollHeight + 'px';

      // Update backing container position based on description container height
      const descContainer = textarea.closest('.timeline-description-container');
      const timelineWrapper = document.querySelector('.timeline-wrapper');
      if (descContainer && timelineWrapper) {
        const descHeight = descContainer.offsetHeight + 10; // +10 for margin-bottom
        timelineWrapper.style.setProperty('--description-height', descHeight + 'px');
      }

      // Update playhead position after timeline resizes
      if (typeof updatePlayhead === 'function') {
        requestAnimationFrame(updatePlayhead);
      }
    }

    // Switch between videos in current tab
    function switchVideo(direction) {
      if (currentTabIndex === -1) return;
      const tab = tabs[currentTabIndex];
      if (!tab.videos || tab.videos.length <= 1) return;

      const newIndex = tab.currentVideoIndex + direction;
      if (newIndex < 0 || newIndex >= tab.videos.length) return;

      const videoElement = document.getElementById('videoPlayer');
      const newVideo = tab.videos[newIndex];

      if (videoElement && newVideo) {
        tab.currentVideoIndex = newIndex;
        videoElement.src = newVideo.src;

        const onVideoReady = () => {
          videoElement.currentTime = 0;
          // Triple RAF to ensure layout is fully updated after potential padding change
          requestAnimationFrame(() => {
            updateVideoAlignment();
            positionVideoNavArrows();
            requestAnimationFrame(() => {
              updateVideoAlignment();
              requestAnimationFrame(() => {
                updateVideoAlignment();
              });
            });
          });
        };

        if (videoElement.readyState >= 1) {
          onVideoReady();
        } else {
          videoElement.addEventListener('loadedmetadata', onVideoReady, { once: true });
        }
      }

      loadDescription();
      updateVideoNavigation();
      updateVideoOverlayButtons();
      syncLegacyVariables();

      // Re-render timeline/table to show per-video colors
      refreshActiveView();
    }

    // Update navigation arrow states
    function updateVideoNavigation() {
      const leftArrow = document.getElementById('videoNavLeft');
      const rightArrow = document.getElementById('videoNavRight');
      if (!leftArrow || !rightArrow) return;

      const tab = getCurrentTab();
      if (!tab || !tab.videos || tab.videos.length <= 1) {
        // Hide arrows if only one or no videos
        leftArrow.classList.remove('visible');
        rightArrow.classList.remove('visible');
        return;
      }

      // Show arrows
      leftArrow.classList.add('visible');
      rightArrow.classList.add('visible');

      // Update disabled states
      if (tab.currentVideoIndex === 0) {
        leftArrow.classList.add('disabled');
      } else {
        leftArrow.classList.remove('disabled');
      }

      if (tab.currentVideoIndex >= tab.videos.length - 1) {
        rightArrow.classList.add('disabled');
      } else {
        rightArrow.classList.remove('disabled');
      }

      // Position arrows centered in gaps
      positionVideoNavArrows();
    }

    // Position arrows centered between bezel and container edge
    function positionVideoNavArrows() {
      const leftArrow = document.getElementById('videoNavLeft');
      const rightArrow = document.getElementById('videoNavRight');
      const videoSection = document.querySelector('.video-section');
      const videoWrapper = document.querySelector('.video-wrapper');

      if (!leftArrow || !rightArrow || !videoSection || !videoWrapper) return;

      const sectionRect = videoSection.getBoundingClientRect();
      const wrapperRect = videoWrapper.getBoundingClientRect();

      // Calculate gap on each side
      const leftGap = wrapperRect.left - sectionRect.left;
      const rightGap = sectionRect.right - wrapperRect.right;

      // Position arrows at center of each gap
      leftArrow.style.left = (leftGap / 2) + 'px';
      rightArrow.style.right = (rightGap / 2) + 'px';
    }

    // Watch for bezel size changes and reposition arrows automatically
    const videoWrapperObserver = new ResizeObserver(() => {
      positionVideoNavArrows();
    });
    const videoWrapper = document.querySelector('.video-wrapper');
    if (videoWrapper) {
      videoWrapperObserver.observe(videoWrapper);
    }

    // Also watch the video section for size changes
    const videoSectionObserver = new ResizeObserver(() => {
      positionVideoNavArrows();
    });
    const videoSection = document.querySelector('.video-section');
    if (videoSection) {
      videoSectionObserver.observe(videoSection);

      // Setup drag and drop on video section
      videoSection.addEventListener('dragenter', (e) => {
        e.preventDefault();
        e.stopPropagation();
        videoSection.classList.add('drag-over');
      });

      videoSection.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = 'copy';
        videoSection.classList.add('drag-over');
      });

      videoSection.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        // Only remove class if leaving the video section entirely
        if (!videoSection.contains(e.relatedTarget)) {
          videoSection.classList.remove('drag-over');
        }
      });

      videoSection.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        videoSection.classList.remove('drag-over');

        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('video/')) {
          loadVideoFile(file);
        }
      });
    }

    // Prevent browser from opening dropped files anywhere on the page
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
    });
    document.addEventListener('drop', (e) => {
      // Only prevent if not handled by video section
      if (!e.defaultPrevented) {
        e.preventDefault();
      }
    });

    // Update overlay buttons based on video count
    function updateVideoOverlayButtons() {
      const addBtn = document.getElementById('addAnotherVideoBtn');
      const deleteBtn = document.getElementById('deleteVideoBtn');
      if (!addBtn || !deleteBtn) return;

      const tab = getCurrentTab();
      const videoCount = tab && tab.videos ? tab.videos.length : 0;

      if (videoCount >= MAX_VIDEOS_PER_TAB) {
        // At max videos - show delete, hide add
        addBtn.style.display = 'none';
        deleteBtn.style.display = 'flex';
      } else {
        // Can add more - show add, hide delete
        addBtn.style.display = 'flex';
        deleteBtn.style.display = 'none';
      }
    }

    // Add another video to current tab
    function addAnotherVideo() {
      if (currentTabIndex === -1) return;
      const tab = tabs[currentTabIndex];

      if (tab.videos && tab.videos.length >= MAX_VIDEOS_PER_TAB) {
        alert(`Maximum of ${MAX_VIDEOS_PER_TAB} videos per tab allowed`);
        return;
      }

      // Create a hidden file input for the new video
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'video/*';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const url = URL.createObjectURL(file);

        // Add new video to array
        if (!tab.videos) tab.videos = [];
        const currentVideoId = getCurrentVideoId();
        const newVideoId = generateVideoId();
        tab.videos.push({ id: newVideoId, src: url, file: file, description: '' });
        // Copy colors from current video to new video
        if (currentVideoId) {
          copyColorsToVideo(getCurrentSpecData(), currentVideoId, newVideoId);
        }
        tab.currentVideoIndex = tab.videos.length - 1;

        // Update video player
        const videoElement = document.getElementById('videoPlayer');
        if (videoElement) {
          videoElement.src = url;

          const onVideoLoaded = () => {
            videoElement.currentTime = 0;
            // Triple RAF to ensure layout is fully updated after potential padding change
            requestAnimationFrame(() => {
              updateVideoAlignment();
              requestAnimationFrame(() => {
                updateVideoAlignment();
                requestAnimationFrame(() => {
                  updateVideoAlignment();
                });
              });
            });
          };

          if (videoElement.readyState >= 1) {
            onVideoLoaded();
          } else {
            videoElement.addEventListener('loadedmetadata', onVideoLoaded, { once: true });
          }
        }

        // Update description field
        loadDescription();

        // Update navigation and buttons
        updateVideoNavigation();
        updateVideoOverlayButtons();

        syncLegacyVariables();
      };
      input.click();
    }

    // Delete current video from tab
    function deleteVideo() {
      if (currentTabIndex === -1) return;
      const tab = tabs[currentTabIndex];

      if (!tab.videos || tab.videos.length <= 1) {
        // Can't delete the only video - would need to use replace instead
        return;
      }

      // Confirm deletion
      if (!confirm('Are you sure you want to delete this video?')) {
        return;
      }

      // Remove current video
      tab.videos.splice(tab.currentVideoIndex, 1);

      // Adjust index if needed
      if (tab.currentVideoIndex >= tab.videos.length) {
        tab.currentVideoIndex = tab.videos.length - 1;
      }

      // Update video player
      const videoElement = document.getElementById('videoPlayer');
      const newVideo = tab.videos[tab.currentVideoIndex];
      if (videoElement && newVideo) {
        videoElement.src = newVideo.src || '';

        const onVideoReady = () => {
          videoElement.currentTime = 0;
          requestAnimationFrame(() => {
            updateVideoAlignment();
            positionVideoNavArrows();
            requestAnimationFrame(() => {
              updateVideoAlignment();
              requestAnimationFrame(() => {
                updateVideoAlignment();
              });
            });
          });
        };

        if (videoElement.readyState >= 1) {
          onVideoReady();
        } else {
          videoElement.addEventListener('loadedmetadata', onVideoReady, { once: true });
        }
      }

      // Update description field
      loadDescription();

      // Update navigation and buttons
      updateVideoNavigation();
      updateVideoOverlayButtons();

      syncLegacyVariables();
    }

    // Maintain legacy references for backward compatibility
    let specData = initialSpec; // Start with Tab 1's spec
    let uploadedVideoFile = null;
    let videoDuration = 0;
    let isDraggingPlayhead = false;
    let selectedAnimation = null;
    let selectedParentedLayerIndex = null; // Track selected child layer for info box refresh
    let selectedSectionHeaderIndex = null; // Track selected section header for info box
    const isExportMode = false;
    let isEditMode = true; // Can be toggled in exported files
    let animationFrameId = null;
    let lastDraggedSpecTimeMs = null;
    let viewDuration = null; // Current zoom level (visible duration in ms)
    let lastDraggedVideoTime = null;
    let justFinishedDragging = false;
    let pendingVideoSeek = null;
    let videoSeekScheduled = false;
    let viewMode = 'timeline'; // 'timeline' or 'table'
    let savedVideoSectionWidth = null;
    let isBarTextBeingEdited = false; // Flag to prevent bar dragging during text editing
    let videoSectionWidthRatio = null; // Ratio of video section width to total width (0-1)

    // Undo/Redo system
    const undoStack = [];
    const redoStack = [];
    const MAX_UNDO_HISTORY = 50;

    function saveSnapshot() {
      // Deep clone current specData
      const snapshot = JSON.parse(JSON.stringify(specData));
      undoStack.push(snapshot);
      if (undoStack.length > MAX_UNDO_HISTORY) undoStack.shift();
      redoStack.length = 0; // Clear redo stack on new change
    }

    function undo() {
      if (undoStack.length === 0) return;
      // Save current state to redo stack
      redoStack.push(JSON.parse(JSON.stringify(specData)));
      // Restore previous state
      specData = undoStack.pop();
      // Update tab's specData reference
      const tab = getCurrentTab();
      if (tab) tab.specData = specData;
      refreshActiveView();
      // Force recheck spacing since content may have changed
      requestAnimationFrame(() => {
        requestAnimationFrame(() => updateSectionSpacing(true));
      });
    }

    function redo() {
      if (redoStack.length === 0) return;
      // Save current state to undo stack
      undoStack.push(JSON.parse(JSON.stringify(specData)));
      // Restore redo state
      specData = redoStack.pop();
      // Update tab's specData reference
      const tab = getCurrentTab();
      if (tab) tab.specData = specData;
      refreshActiveView();
      // Force recheck spacing since content may have changed
      requestAnimationFrame(() => {
        requestAnimationFrame(() => updateSectionSpacing(true));
      });
    }

    // Keyboard shortcuts for undo/redo
    document.addEventListener('keydown', (e) => {
      // Only handle if not typing in an input field
      const isTyping = e.target.tagName === 'INPUT' ||
                       e.target.tagName === 'TEXTAREA' ||
                       e.target.isContentEditable;

      if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
        if (e.shiftKey) {
          // Cmd+Shift+Z = Redo
          e.preventDefault();
          redo();
        } else if (!isTyping) {
          // Cmd+Z = Undo (only when not typing, to preserve native undo in fields)
          e.preventDefault();
          undo();
        }
      }
    });

    // Hide main-only buttons in exported files
    if (isExportMode) {
      document.querySelectorAll('.main-only').forEach(el => el.style.display = 'none');
    }

    // Video timing offset in milliseconds (adjust this to sync video with timeline)
    // Positive values shift timeline markers earlier (if video content appears late)
    const VIDEO_OFFSET_MS = 30;

    const video = document.getElementById('videoPlayer');

    // ===== TAB MANAGEMENT FUNCTIONS =====

    // Create a new tab
    function createNewTab() {
      if (tabs.length >= MAX_TABS) {
        alert(`Maximum of ${MAX_TABS} tabs allowed`);
        return;
      }

      // Add a new tab
      const newTabSpec = createDefaultSpec();
      // Copy Tab 1's title to maintain global title across all tabs
      if (tabs.length > 0 && tabs[0].specData && tabs[0].specData.compName) {
        newTabSpec.compName = tabs[0].specData.compName;
      }

      const newTab = {
        id: nextTabId++,
        name: `Tab ${tabs.length + 1}`,
        specData: newTabSpec,
        videos: [],
        currentVideoIndex: 0
      };
      groupAnimations(newTab.specData);
      ensureLayerIds(newTab.specData);
      tabs.push(newTab);
      switchTab(tabs.length - 1); // Switch to new tab

      renderTabs();
    }

    // Delete a tab
    function deleteTab(index) {
      // Can't delete the last tab
      if (tabs.length === 1) {
        alert("Cannot delete the last tab");
        return;
      }

      const tab = tabs[index];
      if (!confirm(`Delete "${tab.name}"?`)) {
        return;
      }

      tabs.splice(index, 1);

      // If deleting current tab, switch to another tab
      if (index === currentTabIndex) {
        // Temporarily set to -1 so switchTab doesn't early-return
        currentTabIndex = -1;
        // Switch to the tab that's now at the deleted position, or the last tab
        const newIndex = Math.min(index, tabs.length - 1);
        switchTab(newIndex);
      } else if (index < currentTabIndex) {
        // Adjust current index if tab before it was deleted
        currentTabIndex--;
      }

      renderTabs();
    }

    // Switch to a different tab
    function switchTab(index) {
      if (index === currentTabIndex) return;

      // Close info box
      const detailPanel = document.getElementById('detailPanel');
      if (detailPanel) {
        detailPanel.innerHTML = '';
      }
      selectedAnimation = null;
      document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
      document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected'));

      // Switch tab
      currentTabIndex = index;

      // Sync legacy variables
      syncLegacyVariables();

      // Reset playhead to 0
      currentTime = 0;

      // Reset zoom level
      viewDuration = null;

      // Update video element (only if src changed to avoid reload flash)
      const videoElement = document.getElementById('videoPlayer');
      const videoSrc = getCurrentVideoSrc();
      const videoWrapper = document.querySelector('.video-wrapper');
      let videoSrcChanged = false;

      if (videoElement) {
        const currentSrc = videoElement.src;
        const newSrc = videoSrc || '';

        // Only update src if it actually changed
        if (currentSrc !== newSrc) {
          // Hide video wrapper during load to prevent dimension flash
          if (videoWrapper) {
            videoWrapper.style.visibility = 'hidden';
          }

          videoElement.src = newSrc;
          videoSrcChanged = true;

          // Show wrapper once new video is loaded
          if (newSrc) {
            const showVideo = () => {
              if (videoWrapper) {
                videoWrapper.style.visibility = 'visible';
              }
              // Triple RAF to ensure layout is fully updated after potential padding change
              requestAnimationFrame(() => {
                updateVideoAlignment();
                requestAnimationFrame(() => {
                  updateVideoAlignment();
                  requestAnimationFrame(() => {
                    updateVideoAlignment();
                  });
                });
              });
            };
            // Check if video metadata is already loaded (cached video)
            if (videoElement.readyState >= 1) {
              showVideo();
            } else {
              videoElement.addEventListener('loadedmetadata', showVideo, { once: true });
            }
          } else {
            // No video, show wrapper immediately
            if (videoWrapper) {
              videoWrapper.style.visibility = 'visible';
            }
          }
        } else if (videoSrc) {
          // Same video - just reset to beginning without reload
          videoElement.currentTime = 0;
          // Update alignment immediately since it's the same video
          if (videoElement.readyState >= 1) {
            updateVideoAlignment();
          }
        }
      }

      // Update video container visibility
      const emptyState = document.getElementById('videoEmptyState');
      const videoContainer = document.getElementById('videoContainer');
      if (videoSrc) {
        if (emptyState) emptyState.classList.add('hidden');
        if (videoContainer) videoContainer.classList.add('has-video');
      } else {
        if (emptyState) emptyState.classList.remove('hidden');
        if (videoContainer) videoContainer.classList.remove('has-video');
      }

      // Update page title (always use Tab 1's title)
      const pageTitle = document.getElementById('pageTitle');
      const tab1Spec = tabs.length > 0 ? tabs[0].specData : null;
      if (pageTitle && tab1Spec && tab1Spec.compName) {
        pageTitle.textContent = tab1Spec.compName;
        document.title = tab1Spec.compName;
      } else if (pageTitle) {
        pageTitle.textContent = 'Motion Inspector';
        document.title = 'Motion Inspector';
      }

      // Re-render appropriate view
      refreshActiveView();
      renderTabs();

      // Update playhead position
      if (typeof updatePlayhead === 'function') {
        updatePlayhead();
      }

      // Load description for current video
      loadDescription();

      // Load timeline description for current tab
      loadTimelineDescription();

      // Update video navigation arrows and overlay buttons
      updateVideoNavigation();
      updateVideoOverlayButtons();
    }

    // Rename a tab
    function renameTab(index, newName) {
      if (newName.trim() === '') return;
      tabs[index].name = newName.trim();
      renderTabs();
    }

    // Render the tabs bar
    function renderTabs() {
      const tabsBar = document.querySelector('.tabs-bar');
      if (!tabsBar) return;

      let tabsHtml = '';
      let addBtnHtml = '';

      // Render existing tabs
      tabs.forEach((tab, index) => {
        const isActive = index === currentTabIndex;
        const showCloseBtn = tabs.length > 1; // Only show close button when multiple tabs exist
        tabsHtml += `
          <div class="tab ${isActive ? 'active' : ''}" data-tab-index="${index}">
            <span class="tab-name">${tab.name}</span>
            ${showCloseBtn ? `<button class="tab-close edit-only" onclick="event.stopPropagation(); deleteTab(${index})"></button>` : ''}
          </div>
        `;
      });

      // Add + button if under limit
      if (tabs.length < MAX_TABS) {
        const initialClass = tabs.length === 0 ? 'initial' : '';
        addBtnHtml = `<button class="tab-add-btn edit-only ${initialClass}" onclick="createNewTab()">+</button>`;
      }

      // Always wrap tabs in tabs-bar-left for consistent layout
      tabsBar.innerHTML = `<div class="tabs-bar-left">${tabsHtml}</div>${addBtnHtml}`;

      // Add click listeners for tab switching
      document.querySelectorAll('.tab').forEach(tab => {
        const tabIndex = parseInt(tab.dataset.tabIndex);
        tab.addEventListener('click', (e) => {
          // Don't switch if clicking close button or editing name
          if (e.target.classList.contains('tab-close') ||
              e.target.classList.contains('tab-name') && e.target.getAttribute('contenteditable') === 'true') {
            return;
          }
          switchTab(tabIndex);
        });
      });

      // Add double-click listeners for renaming
      document.querySelectorAll('.tab-name').forEach(tabName => {
        const tab = tabName.closest('.tab');
        const tabIndex = parseInt(tab.dataset.tabIndex);

        tabName.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          const originalName = tabs[tabIndex].name;

          // Make editable
          tabName.setAttribute('contenteditable', 'true');
          tabName.focus();

          // Select all text
          const range = document.createRange();
          range.selectNodeContents(tabName);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);

          // Handle blur (when user clicks away)
          const handleBlur = () => {
            tabName.setAttribute('contenteditable', 'false');
            const newName = tabName.textContent.trim();
            if (newName === '' || newName === originalName) {
              tabName.textContent = originalName;
            } else {
              renameTab(tabIndex, newName);
            }
            tabName.removeEventListener('blur', handleBlur);
          };

          // Handle Enter key (finish editing)
          const handleKeydown = (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              tabName.blur();
              tabName.removeEventListener('keydown', handleKeydown);
            } else if (e.key === 'Escape') {
              e.preventDefault();
              tabName.textContent = originalName;
              tabName.blur();
              tabName.removeEventListener('keydown', handleKeydown);
            }
          };

          tabName.addEventListener('blur', handleBlur);
          tabName.addEventListener('keydown', handleKeydown);
        });
      });

      // Add horizontal-only drag for reordering tabs (similar to color bar dragging)
      document.querySelectorAll('.tab').forEach(tab => {
        const tabIndex = parseInt(tab.dataset.tabIndex);

        tab.addEventListener('mousedown', (e) => {
          // Don't allow dragging if clicking close button
          if (e.target.classList.contains('tab-close')) return;

          // Don't allow tab reordering in read/export mode
          if (!isEditMode) return;

          // Don't allow dragging if editing tab name
          const tabName = tab.querySelector('.tab-name');
          if (tabName && tabName.getAttribute('contenteditable') === 'true') return;

          const startX = e.clientX;
          const startY = e.clientY;
          const threshold = 5; // pixels to move before starting drag
          let isDragging = false;
          let draggedTabIndex = tabIndex;

          function onMouseMove(moveEvent) {
            const deltaX = moveEvent.clientX - startX;
            const deltaY = moveEvent.clientY - startY;

            // Determine if we should start dragging (horizontal movement past threshold)
            if (!isDragging && Math.abs(deltaX) > threshold && Math.abs(deltaX) > Math.abs(deltaY)) {
              isDragging = true;
              tab.classList.add('dragging');
            }

            if (!isDragging) return;

            // Move the tab visually with the cursor
            tab.style.transform = `translateX(${deltaX}px)`;

            // Find which tab we're hovering over based on X position
            const allTabs = document.querySelectorAll('.tab');
            let targetIndex = null;
            let closestDistance = Infinity;

            // Find the closest insertion point based on cursor X position
            allTabs.forEach((t, idx) => {
              const rect = t.getBoundingClientRect();

              // Check distance to left edge (insert before this tab)
              const distToLeft = Math.abs(moveEvent.clientX - rect.left);
              if (distToLeft < closestDistance) {
                closestDistance = distToLeft;
                targetIndex = idx;
              }

              // Check distance to right edge (insert after this tab)
              const distToRight = Math.abs(moveEvent.clientX - rect.right);
              if (distToRight < closestDistance) {
                closestDistance = distToRight;
                targetIndex = idx + 1;
              }
            });

            // Remove all drag-over classes
            allTabs.forEach(t => t.classList.remove('drag-over-left', 'drag-over-right'));

            // Add visual indicator (blue line showing where tab will be inserted)
            if (targetIndex !== null && targetIndex !== draggedTabIndex && targetIndex !== draggedTabIndex + 1) {
              if (targetIndex < allTabs.length) {
                allTabs[targetIndex].classList.add('drag-over-left');
              } else if (targetIndex === allTabs.length && allTabs.length > 0) {
                allTabs[allTabs.length - 1].classList.add('drag-over-right');
              }
            }
          }

          function onMouseUp(upEvent) {
            if (isDragging) {
              // Reset visual transform
              tab.style.transform = '';

              // Find drop position using same logic as mousemove
              const allTabs = document.querySelectorAll('.tab');
              let targetIndex = null;
              let closestDistance = Infinity;

              // Find the closest insertion point based on cursor X position
              allTabs.forEach((t, idx) => {
                const rect = t.getBoundingClientRect();

                // Check distance to left edge (insert before this tab)
                const distToLeft = Math.abs(upEvent.clientX - rect.left);
                if (distToLeft < closestDistance) {
                  closestDistance = distToLeft;
                  targetIndex = idx;
                }

                // Check distance to right edge (insert after this tab)
                const distToRight = Math.abs(upEvent.clientX - rect.right);
                if (distToRight < closestDistance) {
                  closestDistance = distToRight;
                  targetIndex = idx + 1;
                }
              });

              // Reorder tabs if we have a valid target
              if (targetIndex !== null && targetIndex !== draggedTabIndex && targetIndex !== draggedTabIndex + 1) {
                const draggedTab = tabs[draggedTabIndex];
                tabs.splice(draggedTabIndex, 1);

                // Adjust target index if removing from before it
                const insertIndex = targetIndex > draggedTabIndex ? targetIndex - 1 : targetIndex;
                tabs.splice(insertIndex, 0, draggedTab);

                // Update currentTabIndex to follow the active tab
                if (currentTabIndex === draggedTabIndex) {
                  currentTabIndex = insertIndex;
                } else if (draggedTabIndex < currentTabIndex && insertIndex >= currentTabIndex) {
                  currentTabIndex--;
                } else if (draggedTabIndex > currentTabIndex && insertIndex <= currentTabIndex) {
                  currentTabIndex++;
                }

                renderTabs();
              } else {
                // Clean up without reordering
                tab.classList.remove('dragging');
                allTabs.forEach(t => t.classList.remove('drag-over-left', 'drag-over-right'));
              }
            }

            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          }

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
      });
    }

    // ===== END TAB MANAGEMENT FUNCTIONS =====

    // Update the UI mode (edit vs read)
    function updateMode() {
      const mode = isEditMode ? 'edit' : 'read';
      document.body.setAttribute('data-mode', mode);

      // Update page title editability
      const pageTitle = document.getElementById('pageTitle');
      if (pageTitle) {
        pageTitle.contentEditable = isEditMode;
      }
    }

    // Toggle between edit and read modes
    function toggleEditMode() {
      isEditMode = !isEditMode;
      updateMode();
      // Re-render timeline to update draggable attributes and buttons
      if (specData) {
        renderTimeline();
      }
    }

    // Initialize mode on page load
    updateMode();

    // Initialize video section to minimum width
    // videoSectionWidthRatio stays null (default state)
    requestAnimationFrame(() => {
      setVideoSectionWidth(VIDEO_MIN_WIDTH);
    });

    // Initialize tabs
    syncLegacyVariables();
    renderTabs();

    // Setup page title editing
    const pageTitle = document.getElementById('pageTitle');
    if (pageTitle) {
      // Store original value on focus
      pageTitle.addEventListener('focus', (e) => {
        pageTitle.dataset.originalValue = pageTitle.textContent.trim();
        // Select all text on focus
        const range = document.createRange();
        range.selectNodeContents(pageTitle);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
      });

      // Handle Enter and Escape keys
      pageTitle.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          pageTitle.blur();
        } else if (e.key === 'Escape') {
          // Restore original value
          pageTitle.textContent = pageTitle.dataset.originalValue || 'Motion Inspector';
          pageTitle.blur();
        }
      });

      // Save changes on blur
      pageTitle.addEventListener('blur', (e) => {
        let newTitle = pageTitle.textContent.trim();

        // If empty, restore original
        if (!newTitle) {
          newTitle = pageTitle.dataset.originalValue || 'Motion Inspector';
          pageTitle.textContent = newTitle;
        }

        // Update ALL tabs' compName to maintain global title
        tabs.forEach(tab => {
          if (tab.specData) {
            tab.specData.compName = newTitle;
          }
        });
        if (specData) {
          specData.compName = newTitle;
        }

        // Update document title
        document.title = newTitle;

        // Clear selection when blurring
        window.getSelection().removeAllRanges();
      });

      // Clear selection when clicking outside the title
      document.addEventListener('mousedown', (e) => {
        if (!pageTitle.contains(e.target)) {
          window.getSelection().removeAllRanges();
        }
      });
    }

    // Throttled video seek using RAF to prevent multiple competing seeks
    function scheduleVideoSeek(targetTime) {
      pendingVideoSeek = targetTime;

      if (!videoSeekScheduled) {
        videoSeekScheduled = true;
        requestAnimationFrame(() => {
          if (pendingVideoSeek !== null) {
            video.currentTime = pendingVideoSeek;
            pendingVideoSeek = null;
          }
          videoSeekScheduled = false;
        });
      }
    }

    // Video upload handler
    // Check if video is width-constrained and update alignment
    function updateVideoAlignment() {
      const videoContainer = document.getElementById('videoContainer');
      const videoWrapper = document.querySelector('.video-wrapper');
      const videoOverlay = document.querySelector('.video-overlay');

      if (!videoContainer || !videoWrapper || !video || !video.videoWidth) {
        return;
      }

      const containerWidth = videoContainer.clientWidth;
      if (containerWidth <= 0) {
        return;
      }

      const aspectRatio = video.videoWidth / video.videoHeight;
      if (!Number.isFinite(aspectRatio) || aspectRatio <= 0) {
        return;
      }

      // Detect if video is square or landscape (wider)
      const isSquareOrWider = aspectRatio >= 1;

      // Use smaller bezel and rounding for square/landscape videos
      const bezelPadding = isSquareOrWider ? 10 : 16; // 5px or 8px padding on each side

      // Corner radius scales proportionally with video size
      // Reference: iPhone 14 at 400px width, adjusted for visual fit
      const referenceWidth = 400;
      const refVideoRadius = isSquareOrWider ? 15 : 53;

      // Adjust video section padding for landscape videos
      const videoSection = document.querySelector('.video-section');
      if (videoSection) {
        videoSection.style.padding = isSquareOrWider ? '24px' : '48px';
      }

      const viewportMaxHeight = Math.max(0, window.innerHeight - 96);
      const containerHeight = videoContainer.clientHeight;
      const heightLimits = [];

      if (viewportMaxHeight > 0) heightLimits.push(viewportMaxHeight);
      if (containerHeight > 0) heightLimits.push(containerHeight);

      // Start with max available width for the video (excluding bezel)
      let videoWidth = containerWidth - bezelPadding;
      let videoHeight = videoWidth / aspectRatio;

      // Check if height constraint is exceeded
      if (heightLimits.length) {
        const maxAllowedHeight = Math.min(...heightLimits);
        if (videoHeight > maxAllowedHeight) {
          videoHeight = maxAllowedHeight;
          videoWidth = videoHeight * aspectRatio;
        }
      }

      if (!Number.isFinite(videoWidth) || !Number.isFinite(videoHeight) || videoWidth <= 0 || videoHeight <= 0) {
        return;
      }

      // Calculate proportional corner radii based on final video width
      // Bezel radius = video radius + padding to maintain concentric corners
      const scaleFactor = videoWidth / referenceWidth;
      const paddingPx = bezelPadding / 2;
      const videoBorderRadius = Math.round(refVideoRadius * scaleFactor);
      const bezelBorderRadius = videoBorderRadius + paddingPx;

      // Set wrapper size to video size + bezel padding
      const wrapperWidth = videoWidth + bezelPadding;
      const wrapperHeight = videoHeight + bezelPadding;

      videoWrapper.style.width = `${wrapperWidth}px`;
      videoWrapper.style.height = `${wrapperHeight}px`;

      // Apply proportionally scaled border radius
      videoWrapper.style.borderRadius = `${bezelBorderRadius}px`;
      video.style.borderRadius = `${videoBorderRadius}px`;

      // Update bezel padding
      videoWrapper.style.padding = `${paddingPx}px`;

      // Update overlay positioning to match bezel padding
      if (videoOverlay) {
        videoOverlay.style.borderRadius = `${videoBorderRadius}px`;
        videoOverlay.style.top = `${paddingPx}px`;
        videoOverlay.style.left = `${paddingPx}px`;
        videoOverlay.style.width = `calc(100% - ${bezelPadding}px)`;
        videoOverlay.style.height = `calc(100% - ${bezelPadding}px)`;
      }

      // Position fullscreen button proportionally with video size (size stays fixed)
      const fullscreenBtn = videoWrapper.querySelector('.video-fullscreen-btn');
      if (fullscreenBtn) {
        const refBtnOffset = 20;
        const btnOffset = Math.round(refBtnOffset * scaleFactor) + paddingPx;

        fullscreenBtn.style.bottom = `${btnOffset}px`;
        fullscreenBtn.style.right = `${btnOffset}px`;
      }

      // If video is using full container width (within 5px threshold), it's width-constrained
      if (Math.abs(containerWidth - wrapperWidth) < 5) {
        videoContainer.classList.add('width-constrained');
      } else {
        videoContainer.classList.remove('width-constrained');
      }

      if (viewMode === 'table') {
        requestAnimationFrame(updateTableEasingWidth);
      }
    }

    const videoInput = document.getElementById('videoInput');
    if (videoInput) {
      videoInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const url = URL.createObjectURL(file);

          // If no tabs exist, create the first tab
          if (tabs.length === 0) {
            const newTab = {
              id: nextTabId++,
              name: `Tab 1`,
              specData: createDefaultSpec(),
              videos: [{ id: generateVideoId(), src: url, file: file, description: '' }],
              currentVideoIndex: 0
            };
            groupAnimations(newTab.specData);
            ensureLayerIds(newTab.specData);
            tabs.push(newTab);
            currentTabIndex = 0;
            syncLegacyVariables();
            renderTabs();
          } else {
            // Store for current tab (replaces current video)
            setCurrentUploadedVideoFile(file);
            uploadedVideoFile = file; // Also update legacy variable
            setCurrentVideoSrc(url);
          }

          // Update navigation arrows and overlay buttons
          updateVideoNavigation();
          updateVideoOverlayButtons();

          video.src = url;

          // Hide empty state and show video container when video is loaded
          const emptyState = document.getElementById('videoEmptyState');
          if (emptyState) {
            emptyState.classList.add('hidden');
          }
          const videoContainer = document.getElementById('videoContainer');
          if (videoContainer) {
            videoContainer.classList.add('has-video');
          }

          const onMetadataLoaded = () => {
            videoDuration = video.duration * 1000; // Convert to ms
            // Ensure video starts at exactly 0
            video.currentTime = 0;
            if (getCurrentSpecData()) {
              renderTimeline();
            }
            // Triple RAF to ensure layout is fully updated after potential padding change
            requestAnimationFrame(() => {
              updateVideoAlignment();
              if (viewMode === 'table') {
                updateTableEasingWidth();
              }
              requestAnimationFrame(() => {
                updateVideoAlignment();
                requestAnimationFrame(() => {
                  updateVideoAlignment();
                });
              });
            });
          };

          // Check if video metadata is already loaded (cached video)
          if (video.readyState >= 1) {
            onMetadataLoaded();
          } else {
            video.addEventListener('loadedmetadata', onMetadataLoaded, { once: true });
          }
        }
      });
    }

    // Handle loading a video file (shared by file input and drag/drop)
    function loadVideoFile(file) {
      if (!file || !file.type.startsWith('video/')) return;

      const url = URL.createObjectURL(file);

      // If no tabs exist, create the first tab
      if (tabs.length === 0) {
        const newTab = {
          id: nextTabId++,
          name: `Tab 1`,
          specData: createDefaultSpec(),
          videos: [{ id: generateVideoId(), src: url, file: file, description: '' }],
          currentVideoIndex: 0
        };
        groupAnimations(newTab.specData);
        ensureLayerIds(newTab.specData);
        tabs.push(newTab);
        currentTabIndex = 0;
        syncLegacyVariables();
        renderTabs();
      } else {
        // Store for current tab (replaces current video)
        setCurrentUploadedVideoFile(file);
        uploadedVideoFile = file;
        setCurrentVideoSrc(url);
      }

      // Update navigation arrows and overlay buttons
      updateVideoNavigation();
      updateVideoOverlayButtons();

      video.src = url;

      // Hide empty state and show video container
      const emptyState = document.getElementById('videoEmptyState');
      if (emptyState) {
        emptyState.classList.add('hidden');
      }
      const videoContainer = document.getElementById('videoContainer');
      if (videoContainer) {
        videoContainer.classList.add('has-video');
      }

      const onMetadataLoaded = () => {
        videoDuration = video.duration * 1000;
        video.currentTime = 0;
        if (getCurrentSpecData()) {
          renderTimeline();
        }
        requestAnimationFrame(() => {
          updateVideoAlignment();
          requestAnimationFrame(() => {
            updateVideoAlignment();
            requestAnimationFrame(() => {
              updateVideoAlignment();
            });
          });
        });
      };

      if (video.readyState >= 1) {
        onMetadataLoaded();
      } else {
        video.addEventListener('loadedmetadata', onMetadataLoaded, { once: true });
      }
    }


    // Centralized function to set video section width
    // All grid column changes go through here for consistency
    const VIDEO_MIN_WIDTH = 560;
    const BODY_PADDING = 40; // 20px left + 20px right

    // videoSectionWidthRatio: null = default/minimum width, number = user-specified ratio
    // When null, video stays at VIDEO_MIN_WIDTH regardless of window size
    // When set, video maintains that ratio when window resizes

    function setVideoSectionWidth(desiredWidth) {
      const mainContent = document.querySelector('.main-content');
      if (!mainContent) return null;

      // Use viewport width to prevent overflow when container is already overflowing
      const viewportAvailable = window.innerWidth - BODY_PADDING;
      const containerWidth = Math.min(mainContent.offsetWidth, viewportAvailable);
      if (containerWidth <= 0) return null;

      const handleWidth = isEditMode ? 20 : 0;
      const maxWidth = (containerWidth - handleWidth) / 2;
      const clampedWidth = Math.max(VIDEO_MIN_WIDTH, Math.min(desiredWidth, maxWidth));

      // Use setProperty with 'important' to ensure override of CSS rules
      const gridValue = isEditMode
        ? `1fr 20px ${clampedWidth}px`
        : `1fr ${clampedWidth}px`;
      mainContent.style.setProperty('grid-template-columns', gridValue, 'important');

      // Don't update videoSectionWidthRatio here - callers decide when to update it
      return clampedWidth;
    }

    // Helper to get current available width
    function getAvailableWidth() {
      return window.innerWidth - BODY_PADDING;
    }

    // Update alignment on window resize
    window.addEventListener('resize', () => {
      if (viewMode === 'table') {
        // Table mode: always stay at minimum width
        setVideoSectionWidth(VIDEO_MIN_WIDTH);
        requestAnimationFrame(updateTableEasingWidth);
      } else if (videoSectionWidthRatio !== null) {
        // Timeline mode with user-specified ratio: maintain that ratio
        const availableWidth = getAvailableWidth();
        setVideoSectionWidth(availableWidth * videoSectionWidthRatio);
      } else {
        // Timeline mode at default: stay at minimum width
        setVideoSectionWidth(VIDEO_MIN_WIDTH);
      }

      updateVideoAlignment();
      positionVideoNavArrows();

      // Resize timeline description textarea on window resize
      const timelineDesc = document.getElementById('timelineDescription');
      if (timelineDesc) autoResizeTextarea(timelineDesc);

      // Update section spacing based on scroll presence
      updateSectionSpacing();
    });

    // Resize handle functionality
    const resizeHandle = document.getElementById('resizeHandle');
    let isResizing = false;
    let startX = 0;
    let startWidth = VIDEO_MIN_WIDTH;

    if (resizeHandle) {
      resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startWidth = document.querySelector('.video-section').offsetWidth;
        resizeHandle.classList.add('dragging');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
      });

      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;

        const deltaX = e.clientX - startX;
        const newWidth = startWidth - deltaX; // Inverted: dragging right shrinks video (now on right)
        const actualWidth = setVideoSectionWidth(newWidth);

        // User is manually resizing - save their ratio
        const availableWidth = getAvailableWidth();
        if (actualWidth && availableWidth > 0) {
          videoSectionWidthRatio = actualWidth / availableWidth;
        }

        requestAnimationFrame(() => {
          updatePlayhead();
          updateVideoAlignment();
          positionVideoNavArrows();
          if (viewMode === 'table') {
            updateTableEasingWidth();
          }
          // Resize timeline description textarea on drag
          const timelineDesc = document.getElementById('timelineDescription');
          if (timelineDesc) autoResizeTextarea(timelineDesc);
        });
      });

      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          resizeHandle.classList.remove('dragging');
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
          updateVideoAlignment();
          positionVideoNavArrows();
          if (viewMode === 'table') {
            updateTableEasingWidth();
          }
        }
      });
    }

    // Play/pause toggle
    function togglePlayPause() {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (video.paused) {
        video.play();
        if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon pause"><svg viewBox="0 0 10 12"><rect x="1" y="1" width="3" height="10" rx="1" fill="white"/><rect x="6" y="1" width="3" height="10" rx="1" fill="white"/></svg></span>';
        startPlayheadAnimation();
      } else {
        video.pause();
        if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon"><svg viewBox="0 0 10 12"><path d="M1 1.5 L8.5 6 L1 10.5 Z" stroke="white" stroke-width="2" stroke-linejoin="round" fill="white"/></svg></span>';
        stopPlayheadAnimation();
      }
    }

    // Toggle video fullscreen
    function toggleVideoFullscreen() {
      const videoElement = document.getElementById('videoPlayer');
      if (!videoElement) return;

      if (document.fullscreenElement) {
        document.exitFullscreen();
      } else {
        videoElement.requestFullscreen().catch(() => {});
      }
    }

    // Set playback speed
    let currentPlaybackSpeed = 1;
    function setPlaybackSpeed(speed) {
      currentPlaybackSpeed = speed;
      video.playbackRate = speed;

      // Update button states in the popup that's in body
      const popup = document.getElementById('settingsPopup');
      if (popup) {
        popup.querySelectorAll('.settings-option[data-speed]').forEach(btn => {
          btn.classList.remove('selected');
        });
        const selectedBtn = popup.querySelector(`.settings-option[data-speed="${speed}"]`);
        if (selectedBtn) {
          selectedBtn.classList.add('selected');
        }
      }
    }

    // Toggle settings popup
    function toggleSettingsPopup(e) {
      e.stopPropagation();
      const btn = document.getElementById('settingsBtn');
      if (!btn) return;

      // Check if popup already exists in body
      let popup = document.body.querySelector(':scope > #settingsPopup');

      // If popup is in body and visible, just close it
      if (popup && popup.classList.contains('visible')) {
        popup.classList.remove('visible');
        btn.classList.remove('active');
        return;
      }

      // Check if there's a fresh popup in the timeline (from re-render)
      const freshPopup = document.querySelector('.playhead-time #settingsPopup');

      let needsAnimationFrame = false;
      if (freshPopup) {
        // Remove old popup from body if exists
        if (popup) popup.remove();
        // Use fresh popup and move to body
        popup = freshPopup;
        document.body.appendChild(popup);
        needsAnimationFrame = true;
      } else if (!popup) {
        // No popup anywhere
        return;
      }

      // Show popup (use rAF for newly added elements to allow initial state to paint)
      const showPopup = () => {
        popup.classList.add('visible');
        btn.classList.add('active');
      };
      if (needsAnimationFrame) {
        requestAnimationFrame(() => requestAnimationFrame(showPopup));
      } else {
        showPopup();
      }

      // Restore the selected state based on current speed
      popup.querySelectorAll('.settings-option[data-speed]').forEach(b => {
        b.classList.toggle('selected', parseFloat(b.dataset.speed) === currentPlaybackSpeed);
      });

      // Restore loop toggle state
      const loopToggle = popup.querySelector('#loopToggle');
      if (loopToggle) {
        loopToggle.classList.toggle('active', isLoopEnabled);
      }

      // Position popup below the button
      const btnRect = btn.getBoundingClientRect();
      const arrowOffset = 75; // Arrow is ~75px from left edge of popup
      popup.style.top = (btnRect.bottom + 11) + 'px';
      popup.style.left = (btnRect.left + btnRect.width/2 - arrowOffset) + 'px';
    }

    // Close settings popup when clicking outside
    document.addEventListener('click', (e) => {
      const popup = document.getElementById('settingsPopup');
      const btn = document.getElementById('settingsBtn');
      if (popup && popup.classList.contains('visible')) {
        // If target is orphaned (disconnected from DOM after re-render), don't close
        if (!e.target.isConnected) {
          return;
        }

        // Use closest() to handle child elements
        const clickedPlayBtn = e.target.closest('#playPauseBtn') !== null;
        const clickedSettingsBtn = e.target.closest('#settingsBtn') !== null;
        const clickedPopup = e.target.closest('#settingsPopup') !== null;

        if (!clickedPopup && !clickedSettingsBtn && !clickedPlayBtn) {
          popup.classList.remove('visible');
          btn.classList.remove('active');
        }
      }
    });

    // Toggle help tooltips (export only)
    let helpTooltipsVisible = false;
    function toggleHelpTooltips() {
      helpTooltipsVisible = !helpTooltipsVisible;
      const helpBtn = document.getElementById('helpBtn');
      const tooltips = document.querySelectorAll('.help-tooltip');
      const scrim = document.getElementById('helpScrim');

      if (helpTooltipsVisible) {
        helpBtn.classList.add('active');
        updateScrimHoles();
        if (scrim) scrim.classList.add('visible');
        positionHelpTooltips();
        // Only show tooltips that weren't hidden by positioning
        tooltips.forEach(t => {
          if (!t.classList.contains('tooltip-hidden')) {
            t.classList.add('visible');
          }
        });
      } else {
        helpBtn.classList.remove('active');
        if (scrim) scrim.classList.remove('visible');
        tooltips.forEach(t => t.classList.remove('visible'));
      }
    }

    // Update scrim SVG with holes for highlighted elements
    function updateScrimHoles() {
      const scrim = document.getElementById('helpScrim');
      if (!scrim) return;

      const w = window.innerWidth;
      const h = window.innerHeight;
      const padding = 6; // Padding around highlighted elements
      const radius = 6;  // Border radius for holes

      // Get elements to highlight
      const holes = [];

      // 1. Playhead - combined handle + line as single shape (timeline mode only)
      const playheadHandle = document.getElementById('playheadTimeDisplay') || document.querySelector('.playhead-handle');
      const playhead = document.getElementById('playhead') || document.querySelector('.playhead');
      if (playheadHandle && playheadHandle.offsetParent !== null && playhead) {
        const handleRect = playheadHandle.getBoundingClientRect();
        const playheadRect = playhead.getBoundingClientRect();
        const lineWidth = 4;
        const linePadding = 2;
        holes.push({
          type: 'playhead',
          // Handle box dimensions
          hx: handleRect.left - padding,
          hy: handleRect.top - padding,
          hw: handleRect.width + padding * 2,
          hh: handleRect.height + padding * 2,
          // Line dimensions
          lx: handleRect.left + handleRect.width / 2 - lineWidth / 2 - linePadding,
          ly: handleRect.bottom + padding,
          lw: lineWidth + linePadding * 2,
          lh: playheadRect.bottom - handleRect.bottom - padding + padding
        });
      }

      // 2. View mode toggle (pill shaped)
      const viewModeControl = document.querySelector('.view-mode-control');
      if (viewModeControl) {
        const rect = viewModeControl.getBoundingClientRect();
        holes.push({
          x: rect.left - padding,
          y: rect.top - padding,
          w: rect.width + padding * 2,
          h: rect.height + padding * 2,
          pill: true
        });
      }

      // 3. First color bar (timeline mode only)
      const firstBar = document.querySelector('.timeline-bar');
      if (firstBar && firstBar.offsetParent !== null) {
        const rect = firstBar.getBoundingClientRect();
        holes.push({
          x: rect.left - padding,
          y: rect.top - padding,
          w: rect.width + padding * 2,
          h: rect.height + padding * 2
        });
      }

      // Build SVG with mask - overlapping white shapes union together
      let maskShapes = '';

      holes.forEach(hole => {
        if (hole.type === 'playhead') {
          // Draw combined handle + line as single shape
          const r = radius;
          const { hx, hy, hw, hh, lx, ly, lw, lh } = hole;
          const lineBottom = ly + lh;

          let d = `M${hx + r},${hy}`;
          d += ` L${hx + hw - r},${hy}`;
          d += ` A${r},${r} 0 0 1 ${hx + hw},${hy + r}`;
          d += ` L${hx + hw},${hy + hh - r}`;
          d += ` A${r},${r} 0 0 1 ${hx + hw - r},${hy + hh}`;
          d += ` L${lx + lw},${hy + hh}`;
          d += ` L${lx + lw},${lineBottom}`;
          d += ` L${lx},${lineBottom}`;
          d += ` L${lx},${hy + hh}`;
          d += ` L${hx + r},${hy + hh}`;
          d += ` A${r},${r} 0 0 1 ${hx},${hy + hh - r}`;
          d += ` L${hx},${hy + r}`;
          d += ` A${r},${r} 0 0 1 ${hx + r},${hy}`;
          d += ` Z`;
          maskShapes += `<path d="${d}" fill="black"/>`;
        } else {
          const x = hole.x;
          const y = hole.y;
          const rw = hole.w;
          const rh = hole.h;
          const r = hole.pill ? Math.min(rh / 2, rw / 2) : Math.min(radius, rw / 2, rh / 2);

          let d = `M${x + r},${y}`;
          d += ` L${x + rw - r},${y}`;
          d += ` A${r},${r} 0 0 1 ${x + rw},${y + r}`;
          d += ` L${x + rw},${y + rh - r}`;
          d += ` A${r},${r} 0 0 1 ${x + rw - r},${y + rh}`;
          d += ` L${x + r},${y + rh}`;
          d += ` A${r},${r} 0 0 1 ${x},${y + rh - r}`;
          d += ` L${x},${y + r}`;
          d += ` A${r},${r} 0 0 1 ${x + r},${y}`;
          d += ` Z`;
          maskShapes += `<path d="${d}" fill="black"/>`;
        }
      });

      scrim.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}">
          <defs>
            <mask id="scrimMask">
              <rect width="${w}" height="${h}" fill="white"/>
              ${maskShapes}
            </mask>
          </defs>
          <rect width="${w}" height="${h}" fill="rgba(0, 0, 0, 0.75)" mask="url(#scrimMask)"/>
        </svg>
      `;
    }

    // Update scrim holes on resize when help is visible
    window.addEventListener('resize', () => {
      if (helpTooltipsVisible) {
        updateScrimHoles();
        positionHelpTooltips();
      }
    });

    function positionHelpTooltips() {
      // First make all tooltips visible so we can measure them
      const allTooltips = document.querySelectorAll('.help-tooltip');
      allTooltips.forEach(t => {
        t.style.visibility = 'hidden';
        t.style.display = 'block';
        t.style.whiteSpace = 'nowrap';
      });

      // Playhead - use the handle element which shows the time, position ABOVE (timeline only)
      const playheadHandle = document.getElementById('playheadTimeDisplay') || document.querySelector('.playhead-handle');
      const playheadTooltip = document.getElementById('helpTooltipPlayhead');
      if (playheadTooltip) {
        playheadTooltip.classList.remove('tooltip-hidden');
        // Only show if playhead is visible (timeline mode)
        if (playheadHandle && playheadHandle.offsetParent !== null) {
          const rect = playheadHandle.getBoundingClientRect();
          playheadTooltip.style.top = (rect.top - playheadTooltip.offsetHeight - 14) + 'px';
          playheadTooltip.style.left = (rect.left + rect.width/2 - playheadTooltip.offsetWidth/2) + 'px';
        } else {
          playheadTooltip.classList.add('tooltip-hidden');
        }
      }

      // View mode toggle - centered horizontally
      const viewModeControl = document.querySelector('.view-mode-control');
      const viewModeTooltip = document.getElementById('helpTooltipViewMode');
      if (viewModeControl && viewModeTooltip) {
        const rect = viewModeControl.getBoundingClientRect();
        viewModeTooltip.style.top = (rect.bottom + 14) + 'px';
        viewModeTooltip.style.left = (rect.left + rect.width/2 - viewModeTooltip.offsetWidth/2) + 'px';
      }

      // Check if playhead and view mode tooltips overlap - if so, flip playhead to below
      if (playheadTooltip && viewModeTooltip && playheadHandle && !playheadTooltip.classList.contains('tooltip-hidden')) {
        const playheadRect = playheadTooltip.getBoundingClientRect();
        const viewModeRect = viewModeTooltip.getBoundingClientRect();
        const overlaps = !(playheadRect.right < viewModeRect.left ||
                          playheadRect.left > viewModeRect.right ||
                          playheadRect.bottom < viewModeRect.top ||
                          playheadRect.top > viewModeRect.bottom);
        if (overlaps) {
          // Flip playhead tooltip to below
          const handleRect = playheadHandle.getBoundingClientRect();
          playheadTooltip.style.top = (handleRect.bottom + 14) + 'px';
          playheadTooltip.classList.remove('arrow-down-center');
          playheadTooltip.classList.add('arrow-up-center');
        } else {
          playheadTooltip.classList.remove('arrow-up-center');
          playheadTooltip.classList.add('arrow-down-center');
        }
      }

      // First color bar - below and centered (timeline only)
      const firstBar = document.querySelector('.timeline-bar');
      const colorBarTooltip = document.getElementById('helpTooltipColorBar');
      if (colorBarTooltip) {
        colorBarTooltip.classList.remove('tooltip-hidden');
        // Only show if timeline bar is visible (timeline mode)
        if (firstBar && firstBar.offsetParent !== null) {
          const rect = firstBar.getBoundingClientRect();
          colorBarTooltip.style.top = (rect.bottom + 14) + 'px';
          colorBarTooltip.style.left = (rect.left + rect.width/2 - colorBarTooltip.offsetWidth/2) + 'px';
        } else {
          colorBarTooltip.classList.add('tooltip-hidden');
        }
      }

      // Slack link - to the left of help button with caret on right
      const helpBtn = document.getElementById('helpBtn');
      const slackTooltip = document.getElementById('helpTooltipSlack');
      if (helpBtn && slackTooltip) {
        const rect = helpBtn.getBoundingClientRect();
        slackTooltip.style.top = (rect.top + rect.height/2 - slackTooltip.offsetHeight/2) + 'px';
        slackTooltip.style.left = (rect.left - slackTooltip.offsetWidth - 14) + 'px';
      }

      // Now hide them again (toggle function will show them)
      allTooltips.forEach(t => {
        t.style.visibility = '';
        t.style.display = '';
      });
    }

    // Close help tooltips when clicking outside
    document.addEventListener('click', (e) => {
      if (!helpTooltipsVisible) return;
      const helpBtn = document.getElementById('helpBtn');
      if (e.target.closest('#helpBtn')) return;
      if (e.target.closest('.help-tooltip')) return;

      helpTooltipsVisible = false;
      helpBtn.classList.remove('active');
      const scrim = document.getElementById('helpScrim');
      if (scrim) scrim.classList.remove('visible');
      document.querySelectorAll('.help-tooltip').forEach(t => t.classList.remove('visible'));
    });

    // Toggle loop video
    let isLoopEnabled = false;
    let loopTimeoutId = null;
    function toggleLoopVideo() {
      isLoopEnabled = !isLoopEnabled;
      // Don't use native loop - we handle it manually with a pause delay
      const toggle = document.getElementById('loopToggle');
      if (toggle) {
        toggle.classList.toggle('active', isLoopEnabled);
      }
      // Clear any pending loop timeout if disabling
      if (!isLoopEnabled && loopTimeoutId) {
        clearTimeout(loopTimeoutId);
        loopTimeoutId = null;
      }
    }

    // Duration controls - extend/shorten timeline
    function zoomIn() {
      if (!specData) return;

      // Extend timeline duration by 100ms
      specData.workArea.duration += 100;

      // Ensure tab's specData is synced
      const tab = getCurrentTab();
      if (tab) {
        tab.specData.workArea.duration = specData.workArea.duration;
      }

      // Reset view duration to show full timeline
      viewDuration = null;

      renderTimeline();
    }

    function zoomOut() {
      if (!specData) return;

      // Shorten timeline duration by 100ms (minimum 100ms)
      const newDuration = Math.max(100, specData.workArea.duration - 100);
      specData.workArea.duration = newDuration;

      // Ensure tab's specData is synced
      const tab = getCurrentTab();
      if (tab) {
        tab.specData.workArea.duration = specData.workArea.duration;
      }

      // Reset view duration to show full timeline
      viewDuration = null;

      renderTimeline();
    }

    function setTimelineDuration(value) {
      if (!specData) return;

      // Parse the input value
      const parsed = parseInt(value, 10);
      if (isNaN(parsed) || parsed < 100) {
        // Invalid input, reset to current value
        renderTimeline();
        return;
      }

      // Set the new duration
      specData.workArea.duration = parsed;

      // Ensure tab's specData is synced
      const tab = getCurrentTab();
      if (tab) {
        tab.specData.workArea.duration = specData.workArea.duration;
      }

      // Reset view duration to show full timeline
      viewDuration = null;

      renderTimeline();
    }

    // Toggle layout between vertical (400px | 1fr) and 50/50 split
    function toggleLayout() {
      const mainContent = document.querySelector('.main-content');
      mainContent.classList.toggle('split-layout');

      // Update button emoji based on current state
      const toggleBtn = event.currentTarget;
      if (mainContent.classList.contains('split-layout')) {
        // Now in 50/50 split, show desktop emoji
        toggleBtn.innerHTML = '<span class="btn-emoji"></span>&nbsp;&nbsp;Toggle Layout';
      } else {
        // Now in narrow layout, show smartphone emoji
        toggleBtn.innerHTML = '<span class="btn-emoji"></span>&nbsp;&nbsp;Toggle Layout';
      }

      // Update playhead position after layout change
      requestAnimationFrame(() => {
        updatePlayhead();
        updateVideoAlignment();
        if (viewMode === 'table') {
          updateTableEasingWidth();
        }
      });
    }

    // Smooth playhead animation using RAF
    function animatePlayhead() {
      if (!isDraggingPlayhead && !video.paused) {
        updatePlayhead();
        updateTimeDisplays();
        animationFrameId = requestAnimationFrame(animatePlayhead);
      }
    }

    function startPlayheadAnimation() {
      if (animationFrameId === null) {
        animationFrameId = requestAnimationFrame(animatePlayhead);
      }
    }

    function stopPlayheadAnimation() {
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    }

    // Video events
    video.addEventListener('play', () => {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon pause"><svg viewBox="0 0 10 12"><rect x="1" y="1" width="3" height="10" rx="1" fill="white"/><rect x="6" y="1" width="3" height="10" rx="1" fill="white"/></svg></span>';
      startPlayheadAnimation();
    });

    video.addEventListener('pause', () => {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon"><svg viewBox="0 0 10 12"><path d="M1 1.5 L8.5 6 L1 10.5 Z" stroke="white" stroke-width="2" stroke-linejoin="round" fill="white"/></svg></span>';
      stopPlayheadAnimation();
      // Cancel any pending loop restart
      if (loopTimeoutId) {
        clearTimeout(loopTimeoutId);
        loopTimeoutId = null;
      }
    });

    video.addEventListener('ended', () => {
      // Don't auto-loop if user dragged playhead to the end while paused
      if (isDraggingPlayhead || justFinishedDragging) {
        return;
      }

      // Move playhead to end of timeline (video may be shorter than timeline duration)
      const playhead = document.querySelector('.playhead');
      const timelineContent = document.querySelector('.timeline-content-column');
      if (playhead && timelineContent) {
        const contentRect = timelineContent.getBoundingClientRect();
        playhead.style.left = `${contentRect.right}px`;
        // Update time display to show timeline end time
        const currentViewDuration = viewDuration || (specData ? specData.workArea.duration : 0);
        const timeDisplay = document.getElementById('playheadTimeDisplay');
        if (timeDisplay) {
          timeDisplay.textContent = `${Math.round(currentViewDuration)}ms`;
        }
      }

      // Check if looping is enabled
      if (isLoopEnabled) {
        // Pause 500ms at the end, then restart
        loopTimeoutId = setTimeout(() => {
          video.currentTime = 0;
          video.play();
          loopTimeoutId = null;
        }, 500);
      } else {
        const playPauseBtn = document.getElementById('playPauseBtn');
        if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon"><svg viewBox="0 0 10 12"><path d="M1 1.5 L8.5 6 L1 10.5 Z" stroke="white" stroke-width="2" stroke-linejoin="round" fill="white"/></svg></span>';
        stopPlayheadAnimation();
      }
    });

    // Update time displays
    function updateTimeDisplays() {
      // If we just finished dragging, use the stored position instead of recalculating
      let specTimeMs;
      if (justFinishedDragging && lastDraggedSpecTimeMs !== null) {
        specTimeMs = lastDraggedSpecTimeMs;
      } else {
        // Calculate spec time as direct time mapping (not percentage-based)
        specTimeMs = video.currentTime * 1000; // Convert to milliseconds
      }

      const playheadTimeDisplay = document.getElementById('playheadTimeDisplay');
      if (playheadTimeDisplay) {
        playheadTimeDisplay.textContent = `${specTimeMs.toFixed(0)}ms`;
      }
    }

    // Update playhead position
    function updatePlayhead() {
      // Don't update position during or right after dragging - user has direct control
      if (isDraggingPlayhead || justFinishedDragging) return;

      const playhead = document.querySelector('.playhead');
      const outerWrapper = document.querySelector('.timeline-outer-wrapper');
      const timelineContent = document.querySelector('.timeline-content-column');
      const timelineRuler = document.querySelector('.timeline-ruler');

      if (playhead && outerWrapper && timelineContent) {
        const positionPercent = getTimelinePosition(video.currentTime);
        const wrapperRect = outerWrapper.getBoundingClientRect();
        const contentRect = timelineContent.getBoundingClientRect();

        // Calculate pixel position relative to viewport
        const leftPosition = contentRect.left + (positionPercent / 100 * contentRect.width);
        playhead.style.left = `${leftPosition}px`;

        // If ruler exists in header, extend playhead up into it
        if (timelineRuler) {
          const rulerRect = timelineRuler.getBoundingClientRect();
          playhead.style.top = `${rulerRect.top + 32}px`; // Start within ruler area
        } else {
          playhead.style.top = `${wrapperRect.top}px`;
        }
        playhead.style.bottom = `${window.innerHeight - wrapperRect.bottom + 1}px`;
      }
    }

    // Paste spec from clipboard
    async function pasteSpec() {
      try {
        const text = await navigator.clipboard.readText();
        const data = JSON.parse(text);

        // Use workArea.duration from JSON directly

        // If no tabs exist, create the first tab
        if (tabs.length === 0) {
          const newTab = {
            id: nextTabId++,
            name: `Tab 1`,
            specData: data,
            videos: [],
            currentVideoIndex: 0
          };
          groupAnimations(newTab.specData);
          ensureLayerIds(newTab.specData);
          tabs.push(newTab);
          currentTabIndex = 0;
          syncLegacyVariables();
        } else {
          // Update current tab's spec
          setCurrentSpecData(data);
          specData = data; // Also update legacy variable
          groupAnimations(getCurrentSpecData()); // Group matching X/Y Position and Width/Height
          ensureLayerIds(getCurrentSpecData());
        }

        viewDuration = null; // Reset zoom level for new spec

        // Update page title only if pasting into Tab 1 (global title)
        const pageTitle = document.getElementById('pageTitle');
        if (pageTitle && data.compName && currentTabIndex === 0) {
          pageTitle.textContent = data.compName;
          document.title = data.compName;
          // Update ALL tabs' compName to maintain global title
          tabs.forEach(tab => {
            if (tab.specData) {
              tab.specData.compName = data.compName;
            }
          });
        }

        // Reset section spacing state for new spec
        needsCompactSpacing = false;

        renderTimeline();
        renderTabs(); // Update tabs display

        // Check section spacing after render
        requestAnimationFrame(() => updateSectionSpacing(true));
      } catch (err) {
        alert('Failed to paste or parse JSON.\n\nError: ' + err.message + '\n\nCheck the browser console for more details.');
        console.error('Parse error:', err);
        console.error('Clipboard content:', await navigator.clipboard.readText());
      }
    }

    // Copy spec JSON to clipboard (for exported files)
    async function copySpecJson() {
      try {
        // Export only current tab's spec
        const currentSpec = getCurrentSpecData();
        const jsonString = JSON.stringify(currentSpec, null, 2);
        await navigator.clipboard.writeText(jsonString);
        alert('Spec JSON copied to clipboard!\n\nYou can paste this into MotionInspector.html to edit.');
      } catch (err) {
        alert('Failed to copy to clipboard: ' + err.message);
        console.error(err);
      }
    }

    // Switch between timeline and table view modes
    function switchToView(view) {
      // Update global view mode
      viewMode = view;

      // Update button states
      document.querySelectorAll('.view-mode-btn').forEach(btn => {
        btn.classList.remove('selected');
      });
      const selectedBtn = document.querySelector(`.view-mode-btn[data-view="${view}"]`);
      if (selectedBtn) {
        selectedBtn.classList.add('selected');
      }

      // Switch view
      if (view === 'table') {
        switchToTableView();
      } else {
        switchToTimelineView();
      }

      // Apply existing section spacing state (preserve across view switches)
      requestAnimationFrame(() => {
        requestAnimationFrame(() => updateSectionSpacing(false));
      });
    }

    // Switch to table view
    function switchToTableView() {
      document.body.classList.add('table-view-active');
      const timelineContent = document.getElementById('timelineContent');

      // Save current ratio for when we switch back to timeline
      savedVideoSectionWidth = videoSectionWidthRatio;

      // Set video to minimum width for table view
      setVideoSectionWidth(VIDEO_MIN_WIDTH);

      // Clear timeline content and render table
      timelineContent.innerHTML = '';
      renderTableView();

      // Apply spacing class immediately to prevent flash
      const outerWrapper = document.querySelector('.timeline-outer-wrapper');
      if (outerWrapper && needsCompactSpacing) {
        outerWrapper.classList.add('has-scroll');
      }

      requestAnimationFrame(() => {
        updateVideoAlignment();
        updateTableEasingWidth();
        syncTableRowHeights();
      });
    }

    // Switch back to timeline view
    function switchToTimelineView() {
      document.body.classList.remove('table-view-active');
      const timelineContent = document.getElementById('timelineContent');

      // Restore user's ratio (could be null if they never manually resized)
      videoSectionWidthRatio = savedVideoSectionWidth;

      // Apply the restored ratio (or minimum if null)
      if (videoSectionWidthRatio !== null) {
        const availableWidth = getAvailableWidth();
        setVideoSectionWidth(availableWidth * videoSectionWidthRatio);
      } else {
        setVideoSectionWidth(VIDEO_MIN_WIDTH);
      }

      // Clear table content
      timelineContent.innerHTML = '';

      // Re-render timeline
      const contentColumn = document.querySelector('.timeline-content-column');
      if (contentColumn) {
        contentColumn.style.removeProperty('--table-easing-width');
      }
      const headerRow = document.querySelector('.timeline-ruler.table-row');
      if (headerRow) {
        headerRow.style.removeProperty('--table-easing-width');
      }

      document.querySelectorAll('.timeline-label').forEach((label) => {
        label.style.removeProperty('height');
        label.style.removeProperty('min-height');
      });

      renderTimeline();

      // Apply spacing class immediately to prevent flash
      const outerWrapper = document.querySelector('.timeline-outer-wrapper');
      if (outerWrapper && needsCompactSpacing) {
        outerWrapper.classList.add('has-scroll');
      }

      requestAnimationFrame(() => {
        updateVideoAlignment();
        updateTimeDisplays();
        updatePlayhead();
      });
    }

    function updateTableEasingWidth() {
      if (viewMode !== 'table') return;

      const contentColumn = document.querySelector('.timeline-content-column');
      const headerRow = document.querySelector('.timeline-ruler.table-row');
      if (!contentColumn) return;

      const easingCells = contentColumn.querySelectorAll('.table-cell--easing');
      if (!easingCells.length) return;

      let requiredWidth = 200;

      contentColumn.style.setProperty('--table-easing-width', 'max-content');

      easingCells.forEach((cell) => {
        const cellWidth = Math.ceil(cell.scrollWidth);
        if (cellWidth > requiredWidth) {
          requiredWidth = cellWidth;
        }
      });

      requiredWidth = Math.max(200, Math.min(requiredWidth, 520));
      contentColumn.style.setProperty('--table-easing-width', `${requiredWidth}px`);
      if (headerRow) {
        headerRow.style.setProperty('--table-easing-width', `${requiredWidth}px`);
      }
      requestAnimationFrame(syncTableRowHeights);
    }

    // Track if we need compact spacing (shared between timeline and table views)
    let needsCompactSpacing = false;

    // Detect if content would overflow and toggle class for section spacing
    // Uses stable timeline-section height (ignores info box) for consistent behavior
    // If forceRecheck is true, measure fresh. Otherwise, just apply current state.
    function updateSectionSpacing(forceRecheck = true) {
      const outerWrapper = document.querySelector('.timeline-outer-wrapper');
      const timelineSection = document.querySelector('.timeline-section');
      if (!outerWrapper || !timelineSection) return;

      if (forceRecheck) {
        // In table mode, syncTableRowHeights sets explicit heights that prevent
        // natural expansion when margins change. Clear them before measuring.
        const isTableMode = viewMode === 'table';
        const leftRows = isTableMode ? Array.from(document.querySelectorAll('.timeline-labels-column .timeline-label')) : [];
        const rightRows = isTableMode ? Array.from(document.querySelectorAll('.timeline-content-column .timeline-track.table-row')) : [];

        if (isTableMode) {
          // Clear explicit heights so content can expand naturally
          leftRows.forEach(row => {
            row.style.removeProperty('height');
            row.style.removeProperty('min-height');
          });
          rightRows.forEach(row => {
            row.style.removeProperty('height');
            row.style.removeProperty('min-height');
          });
        }

        // Remove has-scroll to measure with expanded spacing (16px margins)
        outerWrapper.classList.remove('has-scroll');

        // Force reflow to get accurate measurement
        void outerWrapper.offsetHeight;

        // Get content height (includes header row since it's inside the scroll container)
        const contentHeight = outerWrapper.scrollHeight;

        // Calculate stable available height (ignoring info box)
        // timeline-section has 8px padding top + bottom = 16px
        // Header is inside outerWrapper so it's included in both scrollHeight and available space
        const availableHeight = timelineSection.clientHeight - 16;

        // If content would overflow the stable available height, use compact spacing
        needsCompactSpacing = contentHeight > availableHeight;
      }

      // Apply the shared spacing state
      outerWrapper.classList.toggle('has-scroll', needsCompactSpacing);

      // In table mode, re-sync row heights after applying the spacing
      if (viewMode === 'table') {
        syncTableRowHeights();
      }
    }

    function syncTableRowHeights() {
      if (viewMode !== 'table') return;

      const leftRows = Array.from(document.querySelectorAll('.timeline-labels-column .timeline-label'));
      const rightRows = Array.from(document.querySelectorAll('.timeline-content-column .timeline-track.table-row'));

      if (!leftRows.length || leftRows.length !== rightRows.length) return;

      // Clear all inline height styles to let CSS control them
      leftRows.forEach((row) => {
        row.style.removeProperty('height');
        row.style.removeProperty('min-height');
      });

      rightRows.forEach((row) => {
        row.style.removeProperty('height');
        row.style.removeProperty('min-height');
      });

      requestAnimationFrame(() => {
        leftRows.forEach((leftRow, index) => {
          const rightRow = rightRows[index];
          if (!rightRow) return;

          const isGapRow = leftRow.classList.contains('table-gap-label') || rightRow.classList.contains('table-gap-row');
          if (isGapRow) {
            // Gap rows use CSS height (8px), no inline styles needed
            return;
          }

          const height = Math.max(leftRow.offsetHeight, rightRow.offsetHeight, 32);
          leftRow.style.height = `${height}px`;
          leftRow.style.minHeight = `${height}px`;
          rightRow.style.height = `${height}px`;
          rightRow.style.minHeight = `${height}px`;
        });
      });
    }

    // Helper function to wrap numbers in spans for styling
    function wrapNumbers(text) {
      // Match numbers (including decimals and negatives)
      let result = text.replace(/(-?\d+\.?\d*)/g, '<span class="num">$1</span>');
      // Replace spaces after colons with &nbsp; to preserve them in HTML rendering
      // This ensures "Stiffness: 80" keeps the space after the colon
      result = result.replace(/:\s/g, ':&nbsp;');
      return result;
    }

    // Match cubic-bezier values to presets with tolerance (0.15)
    // AE's internal representation isn't perfectly precise, so we need tolerance matching
    function matchCubicBezierWithTolerance(bezierValue) {
      if (!bezierValue) return null;

      // Parse the bezier values
      const match = bezierValue.match(/cubic-bezier\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)/i);
      if (!match) return null;

      const [_, x1, y1, x2, y2] = match.map(v => typeof v === 'string' ? parseFloat(v) : v);

      // Known presets with their values
      const presets = [
        { name: 'Standard Curve', values: [0.2, 0, 0.2, 1] },
        { name: 'Enter Curve', values: [0.12, 0, 0.12, 1] },
        { name: 'Exit Curve', values: [0.33, 0, 0.5, 1] }
      ];

      const tolerance = 0.15;

      for (const preset of presets) {
        const [px1, py1, px2, py2] = preset.values;
        if (Math.abs(x1 - px1) <= tolerance &&
            Math.abs(y1 - py1) <= tolerance &&
            Math.abs(x2 - px2) <= tolerance &&
            Math.abs(y2 - py2) <= tolerance) {
          return preset.name;
        }
      }

      return null;
    }

    // Helper function to format easing preset names (springs and curves) with hyperlinks
    function formatSpringPreset(text) {
      const presetLinks = {
        // Spring presets
        'Standard Spring': 'https://air.bb/standard-spring',
        'Slow Spring': 'https://air.bb/slow-spring',
        'Fast Spring': 'https://air.bb/fast-spring',
        'Slow Bounce Spring': 'https://air.bb/slow-bounce-spring',
        'Medium Bounce Spring': 'https://air.bb/medium-bounce-spring',
        'Fast Bounce Spring': 'https://air.bb/fast-bounce-spring',
        // Curve presets
        'Standard Curve': 'https://air.bb/standard-curve',
        'Enter Curve': 'https://air.bb/enter-curve',
        'Exit Curve': 'https://air.bb/exit-curve'
      };

      // Check if text matches a preset name (case-insensitive)
      const trimmedText = text.trim();
      for (const [presetName, link] of Object.entries(presetLinks)) {
        if (trimmedText.toLowerCase() === presetName.toLowerCase()) {
          return `<a href="${link}" target="_blank" rel="noopener noreferrer" class="spring-link">${presetName}</a>`;
        }
      }

      // Not a preset, wrap numbers in the text
      return wrapNumbers(text);
    }

    // Easing autocomplete functionality
    let easingAutocomplete = null;
    let autocompleteTarget = null;
    let easingShowPending = false;

    function createEasingAutocomplete() {
      const presets = [
        { name: 'Standard Spring', type: 'spring' },
        { name: 'Slow Spring', type: 'spring' },
        { name: 'Fast Spring', type: 'spring' },
        { name: 'Slow Bounce Spring', type: 'spring' },
        { name: 'Medium Bounce Spring', type: 'spring' },
        { name: 'Fast Bounce Spring', type: 'spring' },
        { name: 'Standard Curve', type: 'curve' },
        { name: 'Enter Curve', type: 'curve' },
        { name: 'Exit Curve', type: 'curve' }
      ];

      // Create dropdown if it doesn't exist
      if (!easingAutocomplete) {
        easingAutocomplete = document.createElement('div');
        easingAutocomplete.className = 'easing-autocomplete';
        // Position off-screen initially to prevent flash on first creation
        easingAutocomplete.style.left = '-9999px';
        easingAutocomplete.style.top = '-9999px';
        document.body.appendChild(easingAutocomplete);
      }

      return { dropdown: easingAutocomplete, presets };
    }

    function showEasingAutocomplete(inputElement, filterText = '') {
      // Skip if already showing or pending for this same input (prevents double animation from click+focus)
      if (autocompleteTarget === inputElement && (easingShowPending ||
          (easingAutocomplete && easingAutocomplete.classList.contains('visible')))) {
        return;
      }
      easingShowPending = true;

      const { dropdown, presets } = createEasingAutocomplete();
      autocompleteTarget = inputElement;

      // Check if input is in info box (detail panel)
      const isInInfoBox = inputElement.closest('#detailPanel') !== null;

      // Always show all presets (no filtering)
      let filtered = [...presets];

      // Reverse order for info box (curves first, then springs)
      if (isInInfoBox) {
        filtered = filtered.reverse();
      }

      // Build dropdown HTML
      let html = '';
      filtered.forEach(preset => {
        const className = preset.type === 'spring' ? 'spring-preset' : 'curve-preset';
        html += `<div class="easing-autocomplete-item ${className}" data-preset="${preset.name}">${preset.name}</div>`;
      });

      dropdown.innerHTML = html;

      // Use fixed width for consistent sizing
      dropdown.style.minWidth = '220px';
      dropdown.style.width = '220px';

      // Position the dropdown
      const rect = inputElement.getBoundingClientRect();
      const dropdownWidth = 220;

      // Reset classes before positioning
      dropdown.classList.remove('anchor-bottom', 'visible');

      // Get height (works because we use opacity, not display:none)
      const dropdownHeight = dropdown.offsetHeight;

      // Center horizontally relative to input
      const inputCenterX = rect.left + (rect.width / 2);
      const dropdownLeft = inputCenterX - (dropdownWidth / 2);
      dropdown.style.left = (dropdownLeft + window.scrollX) + 'px';

      if (isInInfoBox) {
        // Info box: always expand up from bottom center
        dropdown.classList.add('anchor-bottom');
        dropdown.style.top = (rect.top + window.scrollY - dropdownHeight - 4) + 'px';
        dropdown.style.bottom = 'auto';
      } else {
        // Table mode: expand down from top center, unless it would go off screen
        const spaceBelow = window.innerHeight - rect.bottom;
        const spaceAbove = rect.top;

        if (spaceBelow >= dropdownHeight + 4 || spaceBelow >= spaceAbove) {
          // Expand downward from top center
          dropdown.style.top = (rect.bottom + window.scrollY + 4) + 'px';
          dropdown.style.bottom = 'auto';
        } else {
          // Expand upward from bottom center
          dropdown.classList.add('anchor-bottom');
          dropdown.style.top = (rect.top + window.scrollY - dropdownHeight - 4) + 'px';
          dropdown.style.bottom = 'auto';
        }
      }

      // Use double-RAF to ensure position is fully painted before transition starts
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          dropdown.classList.add('visible');
          easingShowPending = false;
        });
      });

      // Use event delegation on the dropdown itself (prevents duplicate listeners)
      dropdown.onclick = (e) => {
        const item = e.target.closest('.easing-autocomplete-item');
        if (!item) return;

        e.preventDefault();
        e.stopPropagation();

        const presetName = item.dataset.preset;

        hideEasingAutocomplete();

        // Determine if this is a spring or curve preset
        const springPresets = ['Standard Spring', 'Slow Spring', 'Fast Spring', 'Slow Bounce Spring', 'Medium Bounce Spring', 'Fast Bounce Spring'];
        const isSpring = springPresets.includes(presetName);

        // Set the value and trigger save based on element type
        if (inputElement.tagName === 'TEXTAREA' || inputElement.tagName === 'INPUT') {
          // For info box elements, get animIndex from data attribute or onblur handler
          let animIndex = null;
          if (inputElement.dataset.animIndex !== undefined) {
            animIndex = parseInt(inputElement.dataset.animIndex);
          } else {
            const onblurAttr = inputElement.getAttribute('onblur');
            const match = onblurAttr && onblurAttr.match(/updateAnimationField\((\d+),\s*'easing'/);
            if (match) {
              animIndex = parseInt(match[1]);
            }
          }
          if (animIndex !== null) {

            // Find the animation in specData
            let currentIndex = 0;
            for (let layerIndex = 0; layerIndex < specData.layers.length; layerIndex++) {
              const layer = specData.layers[layerIndex];
              for (let animIdx = 0; animIdx < layer.animations.length; animIdx++) {
                if (currentIndex === animIndex) {
                  const anim = layer.animations[animIdx];

                  // Save snapshot BEFORE any modifications for proper undo
                  saveSnapshot();

                  // Update duration based on preset type
                  // Check if this is an imported spring (not yet user-modified)
                  const wasImportedSpring = !anim.durationUserSet && anim.easing && anim.easing.type === 'spring';

                  if (isSpring) {
                    // Spring: set duration to "-"
                    anim.timing.duration = '-';
                    // Calculate spring duration from preset params
                    const presetParams = springPresetParams[presetName];
                    if (presetParams) {
                      anim.calculatedSpringDuration = calculateSpringDuration(
                        presetParams.stiffness,
                        presetParams.damping,
                        presetParams.mass
                      );
                    }
                  } else {
                    // Curve: if duration is "-", not set, or was an imported spring, use default 300ms
                    if (anim.timing.duration === '-' || anim.timing.duration === undefined || anim.timing.duration === null || wasImportedSpring) {
                      anim.timing.duration = 300;
                    }
                    // Clear any calculated spring duration
                    delete anim.calculatedSpringDuration;
                    // If duration is already a number (user-set), keep it
                  }
                  // Always mark as user-set to clear isImportedSpring flag
                  anim.durationUserSet = true;

                  // Set easing directly (not through updateAnimationField to avoid double snapshot)
                  anim.customEasing = presetName;

                  // Refresh the view
                  refreshActiveView();
                  return;
                }
                currentIndex++;
              }
            }
          }
        } else {
          // Contenteditable DIV (table mode)
          const row = inputElement.closest('.table-row');
          const layerIndex = parseInt(row.dataset.layerIndex);
          // Use localAnimIndex for accessing layer.animations[]
          const localAnimIndex = parseInt(row.dataset.localAnimIndex);

          inputElement.textContent = presetName;

          // Manually trigger save for table mode
          const layer = specData.layers[layerIndex];
          if (layer) {
            const anim = layer.animations[localAnimIndex];
            if (anim) {
              // Save snapshot BEFORE any modifications for proper undo
              saveSnapshot();

              anim.customEasing = presetName;

              // Update duration based on preset type
              // Check if this is an imported spring (not yet user-modified)
              const wasImportedSpring = !anim.durationUserSet && anim.easing && anim.easing.type === 'spring';

              if (isSpring) {
                // Spring: set duration to "-"
                anim.timing.duration = '-';
                // Calculate spring duration from preset params
                const presetParams = springPresetParams[presetName];
                if (presetParams) {
                  anim.calculatedSpringDuration = calculateSpringDuration(
                    presetParams.stiffness,
                    presetParams.damping,
                    presetParams.mass
                  );
                }
              } else {
                // Curve: if duration is "-", not set, or was an imported spring, use default 300ms
                if (anim.timing.duration === '-' || anim.timing.duration === undefined || anim.timing.duration === null || wasImportedSpring) {
                  anim.timing.duration = 300;
                }
                // Clear any calculated spring duration
                delete anim.calculatedSpringDuration;
                // If duration is already a number (user-set), keep it
              }
              // Always mark as user-set to clear isImportedSpring flag
              anim.durationUserSet = true;

              renderTableView();
            }
          }
        }
      };
    }

    function hideEasingAutocomplete() {
      easingShowPending = false;
      if (easingAutocomplete) {
        easingAutocomplete.classList.remove('visible');
        autocompleteTarget = null;
      }
    }

    // Close autocomplete when clicking outside
    document.addEventListener('mousedown', (e) => {
      // Check if clicking on an easing field (which would open the autocomplete)
      const isEasingTextarea = e.target.tagName === 'TEXTAREA' &&
                               e.target.classList.contains('detail-value-input');
      const isEasingCell = e.target.dataset && e.target.dataset.field === 'easing';
      const isEasingField = isEasingTextarea || isEasingCell;

      if (easingAutocomplete &&
          easingAutocomplete.classList.contains('visible') &&
          !easingAutocomplete.contains(e.target) &&
          !isEasingField) {
        hideEasingAutocomplete();
      }
    });

    // Render table view
    function renderTableView() {
      if (!specData) {
        return;
      }

      const timelineContent = document.getElementById('timelineContent');

      // Build map of parent ID -> child layers for nesting (using unique IDs to avoid name collisions)
      const childrenByParent = {};
      specData.layers.forEach((layer, index) => {
        if (layer.parenting && layer.parenting.parentId) {
          const parentId = layer.parenting.parentId;
          if (!childrenByParent[parentId]) {
            childrenByParent[parentId] = [];
          }
          childrenByParent[parentId].push({ layer, index });
        }
      });

      // Build table view HTML - must match timeline structure exactly
      let html = '';

      // Outer wrapper containing header + scroll area
      html += `<div class="timeline-outer-wrapper">`;

      // ===== HEADER ROW (fixed, outside scroll) =====
      html += `<div class="timeline-header-row">`;

      // Left side of header - playhead controls
      html += `<div class="playhead-time">
        <button id="playPauseBtn" onclick="togglePlayPause()"><span class="icon"><svg viewBox="0 0 10 12"><path d="M1 1.5 L8.5 6 L1 10.5 Z" stroke="white" stroke-width="2" stroke-linejoin="round" fill="white"/></svg></span></button>
        <span style="position: relative; display: inline-flex;">
          <button class="settings-btn" id="settingsBtn" onclick="toggleSettingsPopup(event)"><svg viewBox="0 0 14 16" fill="currentColor"><path d="M14 8.77v-1.6l-1.94-.64-.45-1.09.88-1.84-1.13-1.13-1.81.91-1.09-.45-.69-1.92h-1.6l-.63 1.94-1.11.45-1.84-.88-1.13 1.13.91 1.81-.45 1.09L0 7.23v1.59l1.94.64.45 1.09-.88 1.84 1.13 1.13 1.81-.91 1.09.45.69 1.92h1.59l.63-1.94 1.11-.45 1.84.88 1.13-1.13-.92-1.81.47-1.09L14 8.75v.02zM7 11c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"/></svg></button>
          <div class="settings-popup" id="settingsPopup">
          <div class="settings-section">
            <div class="settings-label">Playback Speed</div>
            <div class="settings-options">
              <button class="settings-option selected" data-speed="1" onclick="setPlaybackSpeed(1)">1x</button>
              <button class="settings-option" data-speed="0.5" onclick="setPlaybackSpeed(0.5)">0.5x</button>
              <button class="settings-option" data-speed="0.1" onclick="setPlaybackSpeed(0.1)">0.1x</button>
            </div>
          </div>
          <div class="settings-section">
            <div class="settings-toggle-row">
              <span class="settings-toggle-label">Loop Video</span>
              <div class="toggle-switch" id="loopToggle" onclick="toggleLoopVideo()"></div>
            </div>
          </div>
        </div>
        </span>
      </div>`;

      // Right side of header - Table header row
      html += `<div class="timeline-ruler table-row table-row--header">
        <div class="table-cell table-cell--desc"><span class="table-desc-text">Description</span></div>
        <div class="table-cell table-cell--delay">Delay</div>
        <div class="table-cell table-cell--duration">Duration</div>
        <div class="table-cell table-cell--easing">Easing</div>
      </div>`;

      html += `</div>`; // timeline-header-row

      // ===== SCROLL AREA =====
      html += `<div class="timeline-container">`;

      // ===== LEFT COLUMN =====
      html += `<div class="timeline-labels-column" style="border-right: 1px solid #222222;">`;

      // Labels
      // Track which layers have been rendered as children (to skip in main loop)
      const renderedAsChild = new Set();
      let isFirstVisibleLayer = true;

      specData.layers.forEach((layer, layerIndex) => {
        // Skip layers that have parenting - they'll be rendered under their parent
        if (layer.parenting) {
          return;
        }

        // Check if this layer has children
        const children = childrenByParent[layer.id] || [];
        const hasChildren = children.length > 0;

        // Determine divider class - only add divider if not the first visible layer
        const dividerClass = isFirstVisibleLayer ? '' : ' has-divider';
        const showSectionDividerBtn = !isFirstVisibleLayer;
        isFirstVisibleLayer = false;

        // Layer header label
        html += `<div class="timeline-label layer-header${dividerClass}"
                      data-row-type="layer"
                      data-layer-index="${layerIndex}"
                      draggable="${isEditMode}"
                      data-drag-type="layer"
                      data-is-section-divider="${showSectionDividerBtn ? 'true' : 'false'}">
          <span class="timeline-label-text">${layer.layerName}</span>
          <button class="timeline-label-add-btn edit-only" draggable="false">+</button>
          ${showSectionDividerBtn ? '<button class="section-divider-add-btn edit-only" draggable="false">+</button>' : ''}
        </div>`;

        // Animation labels for this parent layer
        layer.animations.forEach((anim, animIndexInLayer) => {
          // Calculate global animation index
          let globalAnimIndex = 0;
          for (let i = 0; i < layerIndex; i++) {
            if (!specData.layers[i].parenting) {
              globalAnimIndex += specData.layers[i].animations.length;
            }
          }
          globalAnimIndex += animIndexInLayer;

          // Add has-child-line class if this layer has children
          const childLineClass = hasChildren ? ' has-child-line' : '';

          html += `<div class="timeline-label indented${childLineClass}"
                        data-row-type="animation"
                        data-layer-index="${layerIndex}"
                        data-anim-index="${animIndexInLayer}"
                        draggable="${isEditMode}"
                        data-drag-type="animation"
                        data-anim-in-layer="${animIndexInLayer}">
            <span class="timeline-label-text">${anim.property}</span>
            <button class="param-action-btn edit-only" draggable="false"></button>
            <button class="timeline-label-add-btn edit-only" draggable="false">+</button>
          </div>`;
        });

        // Render children nested under this parent
        if (hasChildren) {
          children.forEach((childInfo, childIdx) => {
            const childLayer = childInfo.layer;
            const childLayerIndex = childInfo.index;
            const isFirstChild = childIdx === 0;
            const isLastChild = childIdx === children.length - 1;
            const hasSiblings = !isLastChild;

            // Child layer header with connector
            const siblingClass = hasSiblings ? ' has-siblings' : '';
            const firstChildClass = isFirstChild ? ' first-child-layer' : '';
            const childContinueClass = hasSiblings ? ' child-continues' : '';
            html += `<div class="timeline-label child-layer-header${siblingClass}${firstChildClass}"
                          data-row-type="child-layer"
                          data-drag-type="child-layer"
                          data-layer-index="${childLayerIndex}"
                          data-parent-layer="${layerIndex}"
                          draggable="${isEditMode}">
              <span class="timeline-label-text">${childLayer.layerName}</span>
              <button class="param-action-btn edit-only" draggable="false"></button>
              <button class="timeline-label-add-btn edit-only" draggable="false">+</button>
            </div>`;

            // Child's own animations (if any) - extra indented under child header
            childLayer.animations.forEach((anim, animIdx) => {
              // Calculate global animation index (layer array order, matches showAnimationDetails)
              let globalIdx = 0;
              for (let i = 0; i < childLayerIndex; i++) {
                globalIdx += specData.layers[i].animations.length;
              }
              globalIdx += animIdx;

              html += `<div class="timeline-label indented child-anim${childContinueClass}"
                            data-row-type="child-animation"
                            data-layer-index="${childLayerIndex}"
                            data-anim-index="${globalIdx}"
                            data-anim-in-layer="${animIdx}"
                            data-drag-type="animation"
                            draggable="${isEditMode}">
                <span class="timeline-label-text">${anim.property}</span>
                <button class="param-action-btn edit-only" draggable="false"></button>
                <button class="timeline-label-add-btn edit-only" draggable="false">+</button>
              </div>`;
            });

            renderedAsChild.add(childLayerIndex);
          });
        }
      });

      // Bottom section divider for adding new sections at the end
      html += `<div class="timeline-bottom-divider">
        <button class="section-divider-add-btn edit-only" draggable="false">+</button>
      </div>`;

      html += `</div>`; // timeline-labels-column

      // ===== RIGHT COLUMN - Table data (header is now in header row above) =====
      html += `<div class="timeline-content-column">`;

      // Helper function to get global animation index for a layer's animation
      // This matches the order used by showAnimationDetails (layer array order)
      function getGlobalAnimIndexTable(layerIdx, animIdxInLayer) {
        let idx = 0;
        for (let i = 0; i < layerIdx; i++) {
          idx += specData.layers[i].animations.length;
        }
        return idx + animIdxInLayer;
      }

      // Helper function to render animation row cells
      function renderAnimationRowCells(anim, layerIndex, animIndex, layerName, extraClasses = '', rowType = 'animation', localAnimIndex = null) {
        // localAnimIndex is the index within layer.animations[] for editing
        // animIndex is the global index for showAnimationDetails
        const actualLocalIndex = localAnimIndex !== null ? localAnimIndex : animIndex;
        const description = getAnimationDescription(anim.property, anim.values, anim.fitToShape, anim.description, layerName);
        const isFitToShape = anim.isFitToShape || anim.fitToShape;
        let delay, duration, easingText;

        // Always show timing values (including for FitToShape animations)
        // Ensure timing and easing objects exist
        if (!anim.timing) anim.timing = { delay: 0, duration: 300 };
        if (!anim.easing) anim.easing = { type: '-' };
        {
          delay = (anim.timing.delay || 0) + 'ms';
          const durationIsNumeric = typeof anim.timing.duration === 'number' && !isNaN(anim.timing.duration);
          const userSetDuration = anim.durationUserSet === true;
          const isImportedSpring = !userSetDuration && anim.easing && anim.easing.type === 'spring' && durationIsNumeric;
          duration = isImportedSpring ? '-' : (durationIsNumeric ? anim.timing.duration + 'ms' : '-');

          if (anim.customEasing !== undefined && anim.customEasing !== null) {
            easingText = formatSpringPreset(anim.customEasing);
          } else if (anim.easing.type === 'spring') {
            const spring = anim.easing.spring;
            const presetSprings = ['Standard Spring', 'Slow Spring', 'Fast Spring', 'Slow Bounce Spring', 'Medium Bounce Spring', 'Fast Bounce Spring'];
            const springLinks = {
              'Standard Spring': 'https://air.bb/standard-spring',
              'Slow Spring': 'https://air.bb/slow-spring',
              'Fast Spring': 'https://air.bb/fast-spring',
              'Slow Bounce Spring': 'https://air.bb/slow-bounce-spring',
              'Medium Bounce Spring': 'https://air.bb/medium-bounce-spring',
              'Fast Bounce Spring': 'https://air.bb/fast-bounce-spring'
            };
            const isPreset = presetSprings.includes(spring.preset);
            if (isPreset) {
              const link = springLinks[spring.preset];
              easingText = `<a href="${link}" target="_blank" rel="noopener noreferrer" class="spring-link">${spring.preset}</a>`;
            } else {
              if (isEditMode) {
                easingText = `Stiffness:&nbsp;<span class="num">${spring.custom.stiffness}</span>, Damping:&nbsp;<span class="num">${spring.custom.damping}</span>, Damping Ratio:&nbsp;<span class="num">${spring.custom.dampingRatio}</span>, Mass:&nbsp;<span class="num">${spring.custom.mass}</span>`;
              } else {
                easingText = `Stiffness:&nbsp;<span class="num">${spring.custom.stiffness}</span>,&nbsp;Damping:&nbsp;<span class="num">${spring.custom.damping}</span>,&nbsp;Damping Ratio:&nbsp;<span class="num">${spring.custom.dampingRatio}</span>,&nbsp;Mass:&nbsp;<span class="num">${spring.custom.mass}</span>`;
              }
            }
          } else if (anim.easing.type === 'cubic-bezier') {
            const bezierValue = anim.easing.cubicBezier;
            let presetName = anim.easing.cubicBezierPreset;
            if (!presetName && bezierValue) {
              // Use tolerance-based matching (0.15) to handle AE's imprecise bezier values
              presetName = matchCubicBezierWithTolerance(bezierValue);
            }
            const curveLinks = {
              'Standard Curve': 'https://air.bb/standard-curve',
              'Enter Curve': 'https://air.bb/enter-curve',
              'Exit Curve': 'https://air.bb/exit-curve'
            };
            if (presetName && curveLinks[presetName]) {
              const link = curveLinks[presetName];
              easingText = `<a href="${link}" target="_blank" rel="noopener noreferrer" class="spring-link">${presetName}</a>`;
            } else {
              // Strip spaces from bezier display for cleaner look
              const cleanBezier = bezierValue.replace(/\s+/g, '').replace('cubic-bezier', '');
              easingText = wrapNumbers(cleanBezier.startsWith('(') ? cleanBezier : `(${cleanBezier})`);
            }
          } else if (anim.easing.type === 'linear') {
            easingText = 'Linear';
          } else {
            easingText = anim.easing.type || '-';
          }
        }

        return `<div class="timeline-track table-row${extraClasses}" data-row-type="${rowType}" data-layer-index="${layerIndex}" data-anim-index="${animIndex}" data-local-anim-index="${actualLocalIndex}">
          <div class="table-cell table-cell--desc editable-cell" contenteditable="${isEditMode}" data-field="description"><span class="table-desc-text">${description}</span></div>
          <div class="table-cell table-cell--delay editable-cell" contenteditable="${isEditMode}" data-field="delay">${delay}</div>
          <div class="table-cell table-cell--duration editable-cell" contenteditable="${isEditMode}" data-field="duration">${duration}</div>
          <div class="table-cell table-cell--easing editable-cell" contenteditable="${isEditMode}" data-field="easing">${easingText}</div>
        </div>`;
      }

      // Table rows - each row exactly 32px to match timeline tracks
      let isFirstVisibleLayerRight = true;
      specData.layers.forEach((layer, layerIndex) => {
        // Skip layers that have parenting - they'll be rendered under their parent
        if (layer.parenting) {
          return;
        }

        // Check if this layer has children
        const children = childrenByParent[layer.id] || [];
        const hasChildren = children.length > 0;

        // Layer header row (empty cells to match left column layer header)
        const dividerClass = isFirstVisibleLayerRight ? '' : ' has-divider';
        isFirstVisibleLayerRight = false;
        html += `<div class="timeline-track layer-header${dividerClass} table-row table-row--layer" data-layer-index="${layerIndex}">
          <div class="table-cell table-cell--desc"></div>
          <div class="table-cell table-cell--delay"></div>
          <div class="table-cell table-cell--duration"></div>
          <div class="table-cell table-cell--easing"></div>
        </div>`;

        // Animation rows for this parent layer
        const childLineClass = hasChildren ? ' has-child-line' : '';
        layer.animations.forEach((anim, animIndex) => {
          html += renderAnimationRowCells(anim, layerIndex, animIndex, layer.layerName, childLineClass);
        });

        // Render children immediately after parent's animations
        children.forEach((childData, childIdx) => {
          const childLayer = childData.layer;
          const childLayerIndex = childData.index;
          const isFirstChild = childIdx === 0;
          const isLastChild = childIdx === children.length - 1;
          const siblingClass = isLastChild ? '' : ' has-siblings';
          const firstChildClass = isFirstChild ? ' first-child-layer' : '';
          const childContinueClass = isLastChild ? '' : ' child-continues';

          // Child layer header row with attachment info in description
          const parentName = layer.layerName;
          const tableAttachedDescription = childLayer.parentingDescription || `Attached to ${parentName}`;
          html += `<div class="timeline-track table-row table-row--child-layer child-layer-header${siblingClass}${firstChildClass}" data-layer-index="${childLayerIndex}" data-row-type="child-layer" data-drag-type="child-layer" data-parent-layer="${layerIndex}" data-parent-name="${parentName}">
            <div class="table-cell table-cell--desc editable-cell" contenteditable="${isEditMode}" data-field="parentingDescription"><span class="table-desc-text">${tableAttachedDescription}</span></div>
            <div class="table-cell table-cell--delay"></div>
            <div class="table-cell table-cell--duration"></div>
            <div class="table-cell table-cell--easing"></div>
          </div>`;

          // Child's own animation rows (if any)
          childLayer.animations.forEach((anim, animIndex) => {
            // Use layer-array-order index (matches showAnimationDetails lookup)
            const childAnimGlobalIndex = getGlobalAnimIndexTable(childLayerIndex, animIndex);
            // Pass both global index (for showAnimationDetails) and local index (for editing)
            html += renderAnimationRowCells(anim, childLayerIndex, childAnimGlobalIndex, childLayer.layerName, childContinueClass, 'child-animation', animIndex);
          });
        });
      });

      // Bottom divider for right column to match left column
      html += `<div class="timeline-bottom-track table-row">
        <div class="table-cell table-cell--desc"></div>
        <div class="table-cell table-cell--delay"></div>
        <div class="table-cell table-cell--duration"></div>
        <div class="table-cell table-cell--easing"></div>
      </div>`;

      html += `</div>`; // timeline-content-column
      html += `</div>`; // timeline-container
      html += `</div>`; // timeline-outer-wrapper

      // Info box panel (must be sibling of timeline-outer-wrapper)
      html += `<div id="detailPanel"></div>`;

      timelineContent.innerHTML = html;

      updateTableEasingWidth();
      syncTableRowHeights();
      addTableHoverListeners();
      setupTableDragAndDrop();
      setupTableAddButtonHandlers();
      setupTableAddButtonHoverZones();
      setupParamActionButtonHoverHandlers();
      setupTableEditableFields();
      setupEasingCellCopyHandler();
    }

    // Setup copy handler for easing cells to ensure clean text (works in both edit and read mode)
    function setupEasingCellCopyHandler() {
      const easingCells = document.querySelectorAll('.table-cell--easing');
      easingCells.forEach(cell => {
        // Remove existing handler to avoid duplicates
        cell.removeEventListener('copy', handleEasingCellCopy);
        cell.addEventListener('copy', handleEasingCellCopy);
      });
    }

    function handleEasingCellCopy(e) {
      const selection = window.getSelection();
      if (!selection.rangeCount) return;

      // Get the selected text, clean it up
      let text = selection.toString();
      // Replace multiple whitespace (including non-breaking spaces U+00A0) with single space
      text = text.replace(/[\s\u00A0]+/g, ' ');
      // Clean up any space before commas (can occur from inline element boundaries)
      text = text.replace(/ +,/g, ',');
      // Trim
      text = text.trim();

      if (text) {
        e.preventDefault();
        e.clipboardData.setData('text/plain', text);
      }
    }

    // Setup hover handlers for param action buttons to show only one at a time
    function setupParamActionButtonHoverHandlers() {
      // Include both indented rows and child-layer-header rows
      const paramRows = document.querySelectorAll('.timeline-label.indented, .timeline-label.child-layer-header');

      paramRows.forEach(row => {
        row.addEventListener('mouseenter', () => {
          // Hide all param action buttons
          document.querySelectorAll('.param-action-btn').forEach(btn => {
            btn.classList.remove('visible');
          });

          // Show only this row's button
          const btn = row.querySelector('.param-action-btn');
          if (btn) {
            btn.classList.add('visible');
          }
        });

        row.addEventListener('mouseleave', () => {
          // Hide this row's button
          const btn = row.querySelector('.param-action-btn');
          if (btn) {
            btn.classList.remove('visible');
          }
        });

        // Add click handler to the delete button
        const btn = row.querySelector('.param-action-btn');
        if (btn) {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();

            const layerIndex = parseInt(row.dataset.layerIndex);

            // Handle child layer rows - delete the entire child layer
            if (row.dataset.rowType === 'child-layer') {
              deleteParentedLayer(layerIndex);
              return;
            }

            // Handle parented rows differently
            if (row.dataset.rowType === 'parented') {
              deleteParentedLayer(layerIndex);
              return;
            }

            // Calculate global animation index for regular animation rows
            const animInLayer = parseInt(row.dataset.animInLayer);

            let globalAnimIndex = 0;
            for (let i = 0; i < layerIndex; i++) {
              globalAnimIndex += specData.layers[i].animations.length;
            }
            globalAnimIndex += animInLayer;

            // Call the delete function
            deleteAnimation(globalAnimIndex);
          });
        }
      });
    }

    // Add hover event listeners to sync hover state between left and right columns in table view
    function addTableHoverListeners() {
      const leftLabels = document.querySelectorAll('.timeline-labels-column .timeline-label[data-row-type]');
      const rightRows = document.querySelectorAll('.timeline-content-column .timeline-track.table-row[data-row-type]');

      // Add listeners to left column labels
      leftLabels.forEach(leftLabel => {
        const rowType = leftLabel.getAttribute('data-row-type');
        const layerIndex = leftLabel.getAttribute('data-layer-index');
        const animIndex = leftLabel.getAttribute('data-anim-index');

        leftLabel.addEventListener('mouseenter', () => {
          // Find matching right row
          let selector = `.timeline-track.table-row[data-row-type="${rowType}"][data-layer-index="${layerIndex}"]`;
          if (animIndex !== null) {
            selector += `[data-anim-index="${animIndex}"]`;
          }
          const rightRow = document.querySelector(selector);

          if (rightRow) {
            leftLabel.classList.add('table-hover');
            rightRow.classList.add('table-hover');
          }
        });

        leftLabel.addEventListener('mouseleave', () => {
          // Find matching right row
          let selector = `.timeline-track.table-row[data-row-type="${rowType}"][data-layer-index="${layerIndex}"]`;
          if (animIndex !== null) {
            selector += `[data-anim-index="${animIndex}"]`;
          }
          const rightRow = document.querySelector(selector);

          if (rightRow) {
            leftLabel.classList.remove('table-hover');
            rightRow.classList.remove('table-hover');
          }
        });
      });

      // Add listeners to right column rows
      rightRows.forEach(rightRow => {
        const rowType = rightRow.getAttribute('data-row-type');
        const layerIndex = rightRow.getAttribute('data-layer-index');
        const animIndex = rightRow.getAttribute('data-anim-index');

        rightRow.addEventListener('mouseenter', () => {
          // Find matching left label
          let selector = `.timeline-label[data-row-type="${rowType}"][data-layer-index="${layerIndex}"]`;
          if (animIndex !== null) {
            selector += `[data-anim-index="${animIndex}"]`;
          }
          const leftLabel = document.querySelector(selector);

          if (leftLabel) {
            leftLabel.classList.add('table-hover');
            rightRow.classList.add('table-hover');
          }
        });

        rightRow.addEventListener('mouseleave', () => {
          // Find matching left label
          let selector = `.timeline-label[data-row-type="${rowType}"][data-layer-index="${layerIndex}"]`;
          if (animIndex !== null) {
            selector += `[data-anim-index="${animIndex}"]`;
          }
          const leftLabel = document.querySelector(selector);

          if (leftLabel) {
            leftLabel.classList.remove('table-hover');
            rightRow.classList.remove('table-hover');
          }
        });
      });
    }

    // Setup drag and drop for table mode (reuses timeline drag logic)
    function setupTableDragAndDrop() {
      const labels = document.querySelectorAll('.timeline-labels-column .timeline-label[draggable="true"]');

      labels.forEach(label => {
        // Dragstart - record what's being dragged
        label.addEventListener('dragstart', (e) => {
          draggedElement = label;
          draggedType = label.dataset.dragType;
          draggedLayerIndex = parseInt(label.dataset.layerIndex);
          draggedAnimIndex = label.dataset.animInLayer ? parseInt(label.dataset.animInLayer) : null;
          draggedParentLayer = label.dataset.parentLayer ? parseInt(label.dataset.parentLayer) : null;

          label.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/html', label.innerHTML);

          // Find and add dragging class to corresponding right row
          const rightRow = findCorrespondingRightRow(label);
          if (rightRow) {
            rightRow.classList.add('dragging');
          }

          // Hide all add buttons during drag
          document.querySelectorAll('.timeline-label-add-btn, .section-divider-add-btn').forEach(btn => {
            btn.classList.remove('visible');
          });
        });

        // Dragend - cleanup
        label.addEventListener('dragend', (e) => {
          label.classList.remove('dragging');

          // Remove all drop indicators from both columns
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(el => {
            el.classList.remove('drag-over-top', 'drag-over-bottom', 'dragging');
          });

          draggedElement = null;
          draggedType = null;
          draggedLayerIndex = null;
          draggedAnimIndex = null;
          draggedParentLayer = null;
        });

        // Dragover - show drop indicator
        label.addEventListener('dragover', (e) => {
          if (!draggedElement || draggedElement === label) return;

          const targetType = label.dataset.dragType;
          const targetLayerIndex = parseInt(label.dataset.layerIndex);
          const targetParentLayer = label.dataset.parentLayer ? parseInt(label.dataset.parentLayer) : null;

          // Check if this drop is valid
          let isValidDrop = false;
          let isDropOnLayerHeader = false;
          let isChildLayerDrop = false;
          let isParentingDrop = false;  // Layer being dropped into another section to become child
          let isUnparentingDrop = false;  // Child being dropped on divider to become standalone

          if (draggedType === 'animation' && targetType === 'animation') {
            isValidDrop = true;
          } else if (draggedType === 'animation' && targetType === 'layer') {
            isValidDrop = true;
            isDropOnLayerHeader = true;
          } else if (draggedType === 'layer' && targetType === 'layer') {
            isValidDrop = true;
          } else if (draggedType === 'layer' && (targetType === 'animation' || targetType === 'child-layer')) {
            // Layer dropped on animation or child-layer row = parenting
            // Only allow if dragged layer is not a parent itself
            if (!layerHasChildren(draggedLayerIndex)) {
              // Find which parent section this target belongs to
              let targetParentIndex = targetLayerIndex;
              if (targetType === 'child-layer') {
                targetParentIndex = parseInt(label.dataset.parentLayer);
              } else if (targetType === 'animation') {
                // If target animation belongs to a child layer, resolve to grandparent
                const targetLayer = specData.layers[targetLayerIndex];
                if (targetLayer && targetLayer.parenting && targetLayer.parenting.parentId) {
                  const grandparentIndex = specData.layers.findIndex(l => l.id === targetLayer.parenting.parentId);
                  if (grandparentIndex !== -1) {
                    targetParentIndex = grandparentIndex;
                  }
                }
              }
              // Can't parent to self or to a child layer
              const targetParent = specData.layers[targetParentIndex];
              if (targetParentIndex !== draggedLayerIndex && !targetParent.parenting) {
                isValidDrop = true;
                isParentingDrop = true;
              }
            }
          } else if (draggedType === 'child-layer' && targetType === 'child-layer') {
            // Child layers can only be reordered within same parent
            if (draggedParentLayer === targetParentLayer && draggedLayerIndex !== targetLayerIndex) {
              isValidDrop = true;
              isChildLayerDrop = true;
            }
          } else if (draggedType === 'child-layer' && targetType === 'layer') {
            // Child dropped on layer header = un-parenting
            isValidDrop = true;
            isUnparentingDrop = true;
          }

          if (!isValidDrop) return;

          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';

          // Determine drop position
          const rect = label.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          const dropPosition = e.clientY < midpoint ? 'before' : 'after';

          // Check if this drop would actually change position
          let wouldChangePosition = false;

          if (isDropOnLayerHeader) {
            wouldChangePosition = draggedLayerIndex !== targetLayerIndex;
          } else if (isParentingDrop) {
            // Parenting always changes state (layer becomes child)
            wouldChangePosition = true;
          } else if (isUnparentingDrop) {
            // Un-parenting: allow drop anywhere on a layer header (section divider)
            wouldChangePosition = true;
          } else if (draggedType === 'layer' && targetType === 'layer') {
            const distanceFromTop = e.clientY - rect.top;
            if (distanceFromTop <= 10) {
              let targetIndex = targetLayerIndex;
              if (draggedLayerIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedLayerIndex !== targetIndex;
            }
          } else if (draggedType === 'animation' && targetType === 'animation') {
            if (draggedLayerIndex !== targetLayerIndex) {
              wouldChangePosition = true;
            } else {
              const targetAnimIndex = parseInt(label.dataset.animInLayer);
              let targetIndex = targetAnimIndex;
              if (dropPosition === 'after') targetIndex++;
              if (draggedAnimIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedAnimIndex !== targetIndex;
            }
          } else if (isChildLayerDrop) {
            // Child layer reordering - drop zone is entire header (drop before) or bottom 10px for last child
            const distanceFromBottom = rect.bottom - e.clientY;
            const isLastChild = !label.classList.contains('has-siblings');
            const targetLayer = specData.layers[targetLayerIndex];
            const hasNoAnimations = targetLayer.animations.length === 0;

            if (isLastChild && hasNoAnimations && distanceFromBottom <= 10) {
              // Last child with no animations - drop after
              let targetIndex = targetLayerIndex + 1;
              if (draggedLayerIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedLayerIndex !== targetIndex;
            } else {
              // Drop before target - allow from entire header area
              let targetIndex = targetLayerIndex;
              if (draggedLayerIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedLayerIndex !== targetIndex;
            }
          }

          if (!wouldChangePosition) return;

          // Clear all indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(el => {
            el.classList.remove('drag-over-top', 'drag-over-bottom');
          });

          // Add indicator to both left label and right row
          const rightRow = findCorrespondingRightRow(label);

          if (isDropOnLayerHeader) {
            label.classList.add('drag-over-bottom');
            if (rightRow) rightRow.classList.add('drag-over-bottom');
          } else if (isParentingDrop) {
            // Show indicator on the row being hovered (will become child of its section)
            label.classList.add('drag-over-bottom');
            if (rightRow) rightRow.classList.add('drag-over-bottom');
          } else if (isUnparentingDrop) {
            // Show indicator at top of section header for un-parenting
            label.classList.add('drag-over-top');
            if (rightRow) rightRow.classList.add('drag-over-top');
          } else if (draggedType === 'layer' && targetType === 'layer') {
            const distanceFromTop = e.clientY - rect.top;
            if (distanceFromTop <= 10) {
              label.classList.add('drag-over-top');
              if (rightRow) rightRow.classList.add('drag-over-top');
            }
          } else if (isChildLayerDrop) {
            // Child layer drops - indicator always at top (in the gap area)
            const distanceFromBottom = rect.bottom - e.clientY;
            const isLastChild = !label.classList.contains('has-siblings');
            const targetLayer = specData.layers[targetLayerIndex];
            const hasNoAnimations = targetLayer.animations.length === 0;

            if (isLastChild && hasNoAnimations && distanceFromBottom <= 10) {
              // Show bottom indicator for last child with no animations
              label.classList.add('drag-over-bottom');
              if (rightRow) rightRow.classList.add('drag-over-bottom');
            } else {
              // Top indicator - shows in the gap above this child
              label.classList.add('drag-over-top');
              if (rightRow) rightRow.classList.add('drag-over-top');
            }
          } else {
            if (dropPosition === 'before') {
              label.classList.add('drag-over-top');
              if (rightRow) rightRow.classList.add('drag-over-top');
            } else {
              label.classList.add('drag-over-bottom');
              if (rightRow) rightRow.classList.add('drag-over-bottom');
            }
          }
        });

        // Drop - perform the reorder
        label.addEventListener('drop', (e) => {
          e.preventDefault();

          if (!draggedElement || draggedElement === label) return;

          const targetType = label.dataset.dragType;
          const targetLayerIndex = parseInt(label.dataset.layerIndex);
          const targetAnimIndex = label.dataset.animInLayer ? parseInt(label.dataset.animInLayer) : null;

          // Determine drop position
          const rect = label.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          const dropPosition = e.clientY < midpoint ? 'before' : 'after';

          // For layer drops on layer headers: only allow drops in top half (before)
          if (draggedType === 'layer' && targetType === 'layer') {
            if (dropPosition === 'after') return;
            performLayerMove(draggedLayerIndex, targetLayerIndex, dropPosition);
          }
          // For layer drops on animation/child-layer rows: convert to child (parenting)
          else if (draggedType === 'layer' && (targetType === 'animation' || targetType === 'child-layer')) {
            // Find the parent section for this target
            let targetParentIndex = targetLayerIndex;
            if (targetType === 'child-layer') {
              targetParentIndex = parseInt(label.dataset.parentLayer);
            } else if (targetType === 'animation') {
              // If target animation belongs to a child layer, find its actual parent
              const targetLayer = specData.layers[targetLayerIndex];
              if (targetLayer && targetLayer.parenting && targetLayer.parenting.parentId) {
                // Target is a child layer's animation - find the grandparent
                const grandparentIndex = specData.layers.findIndex(l => l.id === targetLayer.parenting.parentId);
                if (grandparentIndex !== -1) {
                  targetParentIndex = grandparentIndex;
                }
              }
            }
            // Only parent if dragged layer is not already a parent AND target parent is not itself a child
            const targetParent = specData.layers[targetParentIndex];
            if (!layerHasChildren(draggedLayerIndex) && targetParent && !targetParent.parenting) {
              convertLayerToChild(draggedLayerIndex, targetParentIndex);
            }
          }
          // For child-layer drops on layer headers: convert to standalone (un-parenting)
          else if (draggedType === 'child-layer' && targetType === 'layer') {
            convertChildToStandalone(draggedLayerIndex, targetLayerIndex, 'before');
          }
          // For dropping animations on layer headers
          else if (draggedType === 'animation' && targetType === 'layer') {
            saveSnapshot();
            // Save scroll position before re-render
            const timelineOuter = document.querySelector('.timeline-outer-wrapper');
            const scrollTop = timelineOuter ? timelineOuter.scrollTop : 0;

            const sourceLayer = specData.layers[draggedLayerIndex];
            const targetLayer = specData.layers[targetLayerIndex];
            const anim = sourceLayer.animations.splice(draggedAnimIndex, 1)[0];
            targetLayer.animations.splice(0, 0, anim);
            renderTableView();

            // Restore scroll position after re-render
            requestAnimationFrame(() => {
              const newTimelineOuter = document.querySelector('.timeline-outer-wrapper');
              if (newTimelineOuter) {
                newTimelineOuter.scrollTop = scrollTop;
              }
            });
          }
          // For animation drops
          else if (draggedType === 'animation' && targetType === 'animation') {
            if (draggedLayerIndex === targetLayerIndex) {
              performAnimationMove(draggedLayerIndex, draggedAnimIndex, targetAnimIndex, dropPosition);
            } else {
              saveSnapshot();
              // Save scroll position before re-render
              const timelineOuter = document.querySelector('.timeline-outer-wrapper');
              const scrollTop = timelineOuter ? timelineOuter.scrollTop : 0;

              const sourceLayer = specData.layers[draggedLayerIndex];
              const targetLayer = specData.layers[targetLayerIndex];
              const anim = sourceLayer.animations.splice(draggedAnimIndex, 1)[0];

              let insertIndex = targetAnimIndex;
              if (dropPosition === 'after') insertIndex++;
              targetLayer.animations.splice(insertIndex, 0, anim);
              renderTableView();

              // Restore scroll position after re-render
              requestAnimationFrame(() => {
                const newTimelineOuter = document.querySelector('.timeline-outer-wrapper');
                if (newTimelineOuter) {
                  newTimelineOuter.scrollTop = scrollTop;
                }
              });
            }
          }
          // For child-layer drops on child headers
          else if (draggedType === 'child-layer' && targetType === 'child-layer') {
            const targetParentLayer = label.dataset.parentLayer ? parseInt(label.dataset.parentLayer) : null;
            if (draggedParentLayer === targetParentLayer) {
              // Determine if dropping before or after (for last child with no animations)
              const rect = label.getBoundingClientRect();
              const distanceFromBottom = rect.bottom - e.clientY;
              const isLastChild = !label.classList.contains('has-siblings');
              const targetLayer = specData.layers[targetLayerIndex];
              const hasNoAnimations = targetLayer.animations.length === 0;

              const childDropPosition = (isLastChild && hasNoAnimations && distanceFromBottom <= 10) ? 'after' : 'before';
              performChildLayerMove(draggedLayerIndex, targetLayerIndex, childDropPosition);
            }
          }

          // Clear all indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(el => {
            el.classList.remove('drag-over-top', 'drag-over-bottom');
          });
        });
      });

      // Set up drag handlers for child-animation rows (to allow dropping child-layers after their siblings)
      const childAnimRows = document.querySelectorAll('.timeline-labels-column .timeline-label[data-row-type="child-animation"]');
      childAnimRows.forEach(row => {
        row.addEventListener('dragover', (e) => {
          // Only handle child-layer drags
          if (!draggedElement || draggedType !== 'child-layer') return;

          const targetLayerIndex = parseInt(row.dataset.layerIndex);
          const targetAnimIndex = parseInt(row.dataset.animIndex);
          const targetLayer = specData.layers[targetLayerIndex];

          // Check if this animation's layer is a child of the same parent
          if (!targetLayer.parenting || !targetLayer.parenting.parentId) return;
          const targetParentId = targetLayer.parenting.parentId;
          const draggedLayer = specData.layers[draggedLayerIndex];
          if (!draggedLayer.parenting || draggedLayer.parenting.parentId !== targetParentId) return;

          // Only respond to bottom zone of the LAST animation of the child
          const isLastAnim = targetAnimIndex === targetLayer.animations.length - 1;
          if (!isLastAnim) return;

          const rect = row.getBoundingClientRect();
          const distanceFromBottom = rect.bottom - e.clientY;
          if (distanceFromBottom > 10) return;

          // Check if drop would change position
          let targetIndex = targetLayerIndex + 1;
          if (draggedLayerIndex < targetIndex) targetIndex--;
          if (draggedLayerIndex === targetIndex) return;

          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';

          // Clear all indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(el => {
            el.classList.remove('drag-over-top', 'drag-over-bottom');
          });

          // Show bottom indicator on left label (it extends right via CSS)
          // Also find right row manually since child-animation has different row-type than track
          row.classList.add('drag-over-bottom');
          const rightSelector = `.timeline-content-column .timeline-track[data-layer-index="${targetLayerIndex}"][data-anim-index="${targetAnimIndex}"]`;
          const rightRow = document.querySelector(rightSelector);
          if (rightRow) rightRow.classList.add('drag-over-bottom');
        });

        row.addEventListener('drop', (e) => {
          if (!draggedElement || draggedType !== 'child-layer') return;

          const targetLayerIndex = parseInt(row.dataset.layerIndex);
          const targetAnimIndex = parseInt(row.dataset.animIndex);
          const targetLayer = specData.layers[targetLayerIndex];

          // Verify same parent
          if (!targetLayer.parenting || !targetLayer.parenting.parentId) return;
          const targetParentId = targetLayer.parenting.parentId;
          const draggedLayer = specData.layers[draggedLayerIndex];
          if (!draggedLayer.parenting || draggedLayer.parenting.parentId !== targetParentId) return;

          // Verify it's the last animation of this child
          const isLastAnim = targetAnimIndex === targetLayer.animations.length - 1;
          if (!isLastAnim) return;

          e.preventDefault();
          performChildLayerMove(draggedLayerIndex, targetLayerIndex, 'after');

          // Clear indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(el => {
            el.classList.remove('drag-over-top', 'drag-over-bottom');
          });
        });

        row.addEventListener('dragleave', () => {
          row.classList.remove('drag-over-bottom');
          const targetLayerIndex = row.dataset.layerIndex;
          const targetAnimIndex = row.dataset.animIndex;
          const rightSelector = `.timeline-content-column .timeline-track[data-layer-index="${targetLayerIndex}"][data-anim-index="${targetAnimIndex}"]`;
          const rightRow = document.querySelector(rightSelector);
          if (rightRow) rightRow.classList.remove('drag-over-bottom');
        });
      });

      // Set up drag handlers for bottom divider (to allow dropping sections at the end)
      const bottomDivider = document.querySelector('.timeline-bottom-divider');
      const bottomTrack = document.querySelector('.timeline-bottom-track');
      if (bottomDivider && bottomTrack) {
        bottomDivider.addEventListener('dragover', (e) => {
          // Allow layer drops (reorder) and child-layer drops (un-parent)
          if (!draggedElement || (draggedType !== 'layer' && draggedType !== 'child-layer')) return;

          // Check if dragged layer is already the last layer (for regular layers)
          if (draggedType === 'layer') {
            const isLastLayer = draggedLayerIndex === specData.layers.length - 1;
            if (isLastLayer) {
              // Don't show indicator if already at the end
              return;
            }
          }

          e.preventDefault();
          e.stopPropagation();

          // Clear previous indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });

          // Show indicator on both bottom elements (left and right columns)
          bottomDivider.classList.add('drag-over-top');
          bottomTrack.classList.add('drag-over-top');
          e.dataTransfer.dropEffect = 'move';
        });

        bottomDivider.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();

          if (!draggedElement || (draggedType !== 'layer' && draggedType !== 'child-layer')) return;

          if (draggedType === 'child-layer') {
            // Un-parent and move to end
            convertChildToStandalone(draggedLayerIndex, specData.layers.length - 1, 'after');
          } else {
            // Move layer to end
            performLayerMove(draggedLayerIndex, specData.layers.length - 1, 'after');
          }

          // Clear indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });
          bottomDivider.classList.remove('drag-over-top');
          bottomTrack.classList.remove('drag-over-top');
        });

        bottomDivider.addEventListener('dragleave', (e) => {
          bottomDivider.classList.remove('drag-over-top');
          bottomTrack.classList.remove('drag-over-top');
        });

        // Also handle drag events on the right side (bottom track)
        bottomTrack.addEventListener('dragover', (e) => {
          if (!draggedElement || (draggedType !== 'layer' && draggedType !== 'child-layer')) return;

          if (draggedType === 'layer') {
            const isLastLayer = draggedLayerIndex === specData.layers.length - 1;
            if (isLastLayer) return;
          }

          e.preventDefault();
          e.stopPropagation();

          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });

          bottomDivider.classList.add('drag-over-top');
          bottomTrack.classList.add('drag-over-top');
          e.dataTransfer.dropEffect = 'move';
        });

        bottomTrack.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();

          if (!draggedElement || (draggedType !== 'layer' && draggedType !== 'child-layer')) return;

          if (draggedType === 'child-layer') {
            convertChildToStandalone(draggedLayerIndex, specData.layers.length - 1, 'after');
          } else {
            performLayerMove(draggedLayerIndex, specData.layers.length - 1, 'after');
          }

          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });
          bottomDivider.classList.remove('drag-over-top');
          bottomTrack.classList.remove('drag-over-top');
        });

        bottomTrack.addEventListener('dragleave', (e) => {
          bottomDivider.classList.remove('drag-over-top');
          bottomTrack.classList.remove('drag-over-top');
        });
      }
    }

    // Helper function to find the corresponding right row for a left label
    function findCorrespondingRightRow(label) {
      const rowType = label.getAttribute('data-row-type');
      const layerIndex = label.getAttribute('data-layer-index');
      const animIndex = label.getAttribute('data-anim-index');

      let selector = `.timeline-track.table-row[data-row-type="${rowType}"][data-layer-index="${layerIndex}"]`;
      if (animIndex !== null) {
        selector += `[data-anim-index="${animIndex}"]`;
      }

      return document.querySelector(selector);
    }

    // Setup add button click handlers for table mode
    function setupTableAddButtonHandlers() {
      // Set up + button handlers for adding parameters
      const addButtons = document.querySelectorAll('.timeline-label-add-btn');
      addButtons.forEach(btn => {
        // Prevent drag when clicking the + button
        btn.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();

          // Get the parent label to find which layer and position
          const label = btn.closest('.timeline-label');
          if (!label) return;

          const layerIndex = parseInt(label.dataset.layerIndex);
          const layer = specData.layers[layerIndex];
          if (!layer) return;

          // Determine insert position
          let insertIndex;
          if (label.classList.contains('layer-header')) {
            // If clicking on header, add to top of layer
            insertIndex = 0;
          } else {
            // If clicking on animation row, add after it
            const animInLayer = parseInt(label.dataset.animInLayer);
            insertIndex = animInLayer + 1;
          }

          saveSnapshot();

          // Create new animation with default values
          const newAnimation = {
            property: "Add parameter",
            description: "Add description",
            timing: {
              delay: 0,
              duration: 300
            },
            easing: {
              type: "-",
              cubicBezier: ""
            },
            values: {
              formatted: {
                startValue: "-",
                endValue: "-"
              }
            }
          };

          // Insert the new animation
          layer.animations.splice(insertIndex, 0, newAnimation);

          // Save scroll position before re-render
          const timelineOuter = document.querySelector('.timeline-outer-wrapper');
          const scrollTop = timelineOuter ? timelineOuter.scrollTop : 0;

          // Re-render table
          renderTableView();

          // Calculate the global animation index for the newly added animation
          let globalAnimIndex = 0;
          for (let i = 0; i < layerIndex; i++) {
            globalAnimIndex += specData.layers[i].animations.length;
          }
          globalAnimIndex += insertIndex;

          // Handle post-add actions
          setTimeout(() => {
            // Restore scroll position first
            const newTimelineOuter = document.querySelector('.timeline-outer-wrapper');
            if (newTimelineOuter) {
              newTimelineOuter.scrollTop = scrollTop;
            }

            // Add selected class to the new label
            const newLabel = document.querySelector(`.timeline-label[data-layer-index="${layerIndex}"][data-anim-in-layer="${insertIndex}"]`);
            if (newLabel) {
              newLabel.classList.add('selected');
              // Scroll the new row into view from current position
              newLabel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            // Update section spacing - call synchronously like resize handler does
            updateSectionSpacing(true);
          }, 50);
        });
      });

      // Set up section divider button handlers
      const sectionDividerButtons = document.querySelectorAll('.section-divider-add-btn');
      sectionDividerButtons.forEach(btn => {
        btn.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();

          // Determine insert position
          let insertIndex;
          const parentLabel = btn.closest('.timeline-label');
          const isBottomDivider = btn.closest('.timeline-bottom-divider');

          if (isBottomDivider) {
            // Bottom divider - add to end
            insertIndex = specData.layers.length;
          } else if (parentLabel) {
            // Section header button - insert before this layer
            const layerIndex = parseInt(parentLabel.dataset.layerIndex);
            insertIndex = layerIndex;
          } else {
            return;
          }

          saveSnapshot();

          // Create new layer with one default animation
          const newLayer = {
            id: generateLayerId(),
            layerName: "New section",
            animations: [
              {
                property: "Add parameter",
                description: "Add description",
                timing: {
                  delay: 0,
                  duration: 300
                },
                easing: {
                  type: "-",
                  cubicBezier: ""
                },
                values: {
                  formatted: {
                    startValue: "-",
                    endValue: "-"
                  }
                }
              }
            ]
          };

          // Insert the new layer
          specData.layers.splice(insertIndex, 0, newLayer);

          // Save scroll position before re-render
          const timelineOuter = document.querySelector('.timeline-outer-wrapper');
          const scrollTop = timelineOuter ? timelineOuter.scrollTop : 0;

          // Re-render table
          renderTableView();

          // Calculate the global animation index for the newly added parameter
          let globalAnimIndex = 0;
          for (let i = 0; i < insertIndex; i++) {
            globalAnimIndex += specData.layers[i].animations.length;
          }
          // The new parameter is at index 0 in the new layer

          // Handle post-add actions
          setTimeout(() => {
            // Restore scroll position first
            const newTimelineOuter = document.querySelector('.timeline-outer-wrapper');
            if (newTimelineOuter) {
              newTimelineOuter.scrollTop = scrollTop;
            }

            // Add selected class to the new layer header
            const newLayerHeader = document.querySelector(`.timeline-label.layer-header[data-layer-index="${insertIndex}"]`);
            if (newLayerHeader) {
              newLayerHeader.classList.add('selected');
              // Scroll the new section into view from current position
              newLayerHeader.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            // Update section spacing - call synchronously like resize handler does
            updateSectionSpacing(true);
          }, 50);
        });
      });
    }

    // Setup editable fields for table mode
    function setupTableEditableFields() {
      // Handle right column editable cells
      const editableCells = document.querySelectorAll('.editable-cell[contenteditable="true"]');

      editableCells.forEach(cell => {
        // Store original value on focus
        cell.addEventListener('focus', (e) => {
          cell.dataset.originalValue = cell.textContent.trim();
          // Select all text on focus
          const range = document.createRange();
          range.selectNodeContents(cell);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);

          // Show autocomplete for easing fields
          if (cell.dataset.field === 'easing') {
            showEasingAutocomplete(cell, cell.textContent.trim());
          }
        });

        // Hide autocomplete when typing in easing fields
        if (cell.dataset.field === 'easing') {
          cell.addEventListener('input', (e) => {
            hideEasingAutocomplete();
          });

          // Handle paste to ensure plain text with preserved spaces
          cell.addEventListener('paste', (e) => {
            e.preventDefault();
            const text = e.clipboardData.getData('text/plain');
            // Insert plain text at cursor position
            document.execCommand('insertText', false, text);
          });
        }

        // Handle Enter key
        cell.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            hideEasingAutocomplete();
            cell.blur();
          } else if (e.key === 'Escape') {
            // Restore original value
            cell.textContent = cell.dataset.originalValue || '';
            cell.blur();
          }
        });

        // Save changes on blur
        cell.addEventListener('blur', (e) => {
          const row = cell.closest('.table-row');
          const layerIndex = parseInt(row.dataset.layerIndex);
          // Use localAnimIndex for editing (index within layer.animations[])
          const localAnimIndex = parseInt(row.dataset.localAnimIndex);
          const fieldName = cell.dataset.field;
          let newValue = cell.textContent.trim();
          const originalValue = cell.dataset.originalValue || '';

          // Get the layer
          const layer = specData.layers[layerIndex];
          if (!layer) return;

          // Handle child layer rows (attached to parent)
          if (row.dataset.rowType === 'child-layer') {
            if (newValue === originalValue) return;
            if (fieldName === 'parentingDescription') {
              saveSnapshot();
              layer.parentingDescription = newValue || undefined;
              refreshActiveView();
            }
            return;
          }

          const anim = layer.animations[localAnimIndex];
          if (!anim) return;

          // Check if value changed - if not, skip
          if (newValue === originalValue) return;

          // Validate first, then save snapshot only if valid
          if (fieldName === 'delay') {
            // Parse delay - remove "ms" suffix if present
            const cleanValue = newValue.replace(/ms$/i, '').trim();
            const numValue = parseFloat(cleanValue);
            if (isNaN(numValue)) {
              // Invalid - restore original
              cell.textContent = originalValue;
              return;
            }
            saveSnapshot();
            anim.timing.delay = numValue;
          } else if (fieldName === 'duration') {
            // Parse duration - remove "ms" suffix if present
            const cleanValue = newValue.replace(/ms$/i, '').trim();
            const numValue = parseFloat(cleanValue);
            if (!isNaN(numValue) && numValue >= 0) {
              // Valid number
              saveSnapshot();
              anim.timing.duration = numValue;
              anim.durationUserSet = true;
            } else if (cleanValue === '-' || cleanValue === '') {
              // "-" or empty - spring style
              saveSnapshot();
              anim.timing.duration = '-';
              anim.durationUserSet = true;
            } else {
              // Invalid - restore original
              cell.textContent = originalValue;
              return;
            }
          } else if (fieldName === 'description') {
            saveSnapshot();
            anim.description = newValue || undefined;
          } else if (fieldName === 'easing') {
            saveSnapshot();
            anim.customEasing = newValue || undefined;

            // Detect spring or curve parameters and auto-switch style
            if (newValue) {
              const springKeywords = ['stiffness', 'damping', 'mass'];
              const lowerValue = newValue.toLowerCase();
              const hasSpringParams = springKeywords.some(keyword => lowerValue.includes(keyword));

              // Detect curve parameters (cubic-bezier or 4 comma-separated numbers)
              const hasCubicKeyword = lowerValue.includes('cubic');
              const curveNumberPattern = /[\d.]+\s*,\s*[\d.]+\s*,\s*[\d.]+\s*,\s*[\d.]+/;
              const hasCurveParams = hasCubicKeyword || curveNumberPattern.test(newValue);

              if (hasSpringParams) {
                // Set duration to "-" to trigger spring style bar
                anim.timing.duration = '-';
                anim.durationUserSet = true;
                // Calculate spring duration from params for bar width
                const springParams = parseSpringParams(newValue);
                if (springParams) {
                  anim.calculatedSpringDuration = calculateSpringDuration(
                    springParams.stiffness,
                    springParams.damping,
                    springParams.mass
                  );
                }
              } else if (hasCurveParams) {
                // Ensure duration is a number for curve style bar
                if (anim.timing.duration === '-' || anim.timing.duration === undefined || anim.timing.duration === null) {
                  anim.timing.duration = 300;
                }
                anim.durationUserSet = true;
              }
            }
          }

          // Refresh the view to show updates (use refreshActiveView to sync detail panel)
          refreshActiveView();
        });
      });

      // Setup label editing
      setupLabelEditing();

      // Preserve section spacing state after re-render
      const outerWrapper = document.querySelector('.timeline-outer-wrapper');
      if (outerWrapper && needsCompactSpacing) {
        outerWrapper.classList.add('has-scroll');
      }
    }

    // Setup label editing for both timeline and table modes
    function setupLabelEditing() {
      // Handle left column label editing with double-click
      // Include draggable labels and parented rows (not child layer headers - those are edited via info box)
      const leftLabels = document.querySelectorAll('.timeline-labels-column .timeline-label[draggable="true"], .timeline-labels-column .timeline-label[data-row-type="parented"]');

      leftLabels.forEach(label => {
        const labelText = label.querySelector('.timeline-label-text');
        if (!labelText) return;

        // Double-click to enter edit mode
        labelText.addEventListener('dblclick', (e) => {
          // Don't interfere with + buttons
          if (e.target.closest('.timeline-label-add-btn, .section-divider-add-btn')) return;

          e.stopPropagation();
          e.preventDefault();
          enterEditMode(label, labelText);
        });
      });

      // Function to enter edit mode for left column labels
      function enterEditMode(label, labelText) {
        const originalText = labelText.textContent.trim();
        const isLayerHeader = label.classList.contains('layer-header');
        const isChildLayerHeader = label.classList.contains('child-layer-header');
        const layerIndex = parseInt(label.dataset.layerIndex);
        const animIndex = (isLayerHeader || isChildLayerHeader) ? null : parseInt(label.dataset.animInLayer);

        // Make the span contenteditable
        labelText.contentEditable = true;
        labelText.focus();

        // Select all text
        const range = document.createRange();
        range.selectNodeContents(labelText);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        // Temporarily disable dragging
        label.draggable = false;

        // Handle Enter key
        const handleKeyDown = (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            labelText.blur();
          } else if (e.key === 'Escape') {
            labelText.textContent = originalText;
            labelText.blur();
          }
        };

        // Save changes on blur
        const handleBlur = () => {
          const newText = labelText.textContent.trim();
          labelText.contentEditable = false;
          label.draggable = true;

          // Remove event listeners
          labelText.removeEventListener('keydown', handleKeyDown);
          labelText.removeEventListener('blur', handleBlur);

          // Update specData if text changed
          if (newText && newText !== originalText) {
            if (isLayerHeader || isChildLayerHeader) {
              updateLayerField(layerIndex, 'layerName', newText);
            } else {
              // Calculate global animation index
              let globalAnimIndex = 0;
              for (let i = 0; i < layerIndex; i++) {
                globalAnimIndex += getCurrentSpecData().layers[i].animations.length;
              }
              globalAnimIndex += animIndex;
              updateAnimationField(globalAnimIndex, 'property', newText);
            }
          } else if (!newText) {
            // Restore original if empty
            labelText.textContent = originalText;
          }
        };

        labelText.addEventListener('keydown', handleKeyDown);
        labelText.addEventListener('blur', handleBlur);
      }
    }

    // Setup hover zones for add buttons in table mode
    function setupTableAddButtonHoverZones() {
      const labelsColumn = document.querySelector('.timeline-labels-column');
      const labels = document.querySelectorAll('.timeline-label');
      const bottomDivider = document.querySelector('.timeline-bottom-divider');

      if (!labelsColumn) return;

      labelsColumn.addEventListener('mousemove', (e) => {
        const mouseY = e.clientY;
        const outerWrapper = document.querySelector('.timeline-outer-wrapper');
        const isCollapsed = outerWrapper && outerWrapper.classList.contains('has-scroll');

        // Find all buttons and their distances
        let closestButton = null;
        let closestDistance = Infinity;

        // Check each label's divider line
        const labelsArray = Array.from(labels);
        labelsArray.forEach((label, idx) => {
          const btn = label.querySelector('.timeline-label-add-btn');
          const sectionBtn = label.querySelector('.section-divider-add-btn');
          const rect = label.getBoundingClientRect();
          const halfCellHeight = rect.height / 2;

          // Check regular divider line (at bottom of cell)
          if (btn) {
            const dividerY = rect.bottom;
            const distanceFromDivider = Math.abs(mouseY - dividerY);
            if (distanceFromDivider <= halfCellHeight) {
              // In collapsed mode, check if next row is a section header
              // If so, prefer the section button from that header
              if (isCollapsed) {
                const nextLabel = labelsArray[idx + 1];
                if (nextLabel && nextLabel.classList.contains('layer-header') && nextLabel.classList.contains('has-divider')) {
                  const nextSectionBtn = nextLabel.querySelector('.section-divider-add-btn');
                  if (nextSectionBtn && distanceFromDivider < closestDistance) {
                    closestDistance = distanceFromDivider;
                    closestButton = nextSectionBtn;
                    return; // Skip adding param button
                  }
                }
              }
              if (distanceFromDivider < closestDistance) {
                closestDistance = distanceFromDivider;
                closestButton = btn;
              }
            }
          }

          // Check section divider line (at top of cell, for elements with has-divider)
          // Only show in expanded mode (non-collapsed)
          if (sectionBtn && !isCollapsed) {
            const sectionDividerY = rect.top; // Border-top is at element's top edge
            const distanceFromSectionDivider = Math.abs(mouseY - sectionDividerY);
            // Use a larger hover zone for section dividers (about 15px total margin-top / 2)
            if (distanceFromSectionDivider <= 15) {
              if (distanceFromSectionDivider < closestDistance) {
                closestDistance = distanceFromSectionDivider;
                closestButton = sectionBtn;
              }
            }
          }
        });

        // Check bottom divider
        if (bottomDivider) {
          const bottomBtn = bottomDivider.querySelector('.section-divider-add-btn');
          if (bottomBtn) {
            const rect = bottomDivider.getBoundingClientRect();
            const dividerY = rect.top;
            const distanceFromDivider = Math.abs(mouseY - dividerY);
            if (distanceFromDivider <= 15) {
              if (distanceFromDivider < closestDistance) {
                closestDistance = distanceFromDivider;
                closestButton = bottomBtn;
              }
            }
          }
        }

        // Hide all buttons first
        labels.forEach(label => {
          const btn = label.querySelector('.timeline-label-add-btn');
          const sectionBtn = label.querySelector('.section-divider-add-btn');
          if (btn) btn.classList.remove('visible');
          if (sectionBtn) sectionBtn.classList.remove('visible');
        });
        if (bottomDivider) {
          const bottomBtn = bottomDivider.querySelector('.section-divider-add-btn');
          if (bottomBtn) bottomBtn.classList.remove('visible');
        }

        // Show only the closest button
        if (closestButton) {
          closestButton.classList.add('visible');
        }
      });

      // Hide all buttons when mouse leaves the column
      labelsColumn.addEventListener('mouseleave', () => {
        // Hide all buttons when mouse leaves the column
        labels.forEach(label => {
          const btn = label.querySelector('.timeline-label-add-btn');
          const sectionBtn = label.querySelector('.section-divider-add-btn');
          if (btn) btn.classList.remove('visible');
          if (sectionBtn) sectionBtn.classList.remove('visible');
        });

        // Hide bottom divider button
        if (bottomDivider) {
          const bottomBtn = bottomDivider.querySelector('.section-divider-add-btn');
          if (bottomBtn) bottomBtn.classList.remove('visible');
        }
      });
    }

    // Get the base HTML template for export (without the export button and JSZip)
    // videoSectionRatio: null = default/minimum, number = user-specified ratio
    function getExportTemplate(videoFileName, tabsJson, videoSectionRatio = null, compactSpacing = false) {
      // Get all the styles from this page
      const styleElement = document.querySelector('style');
      const styles = styleElement ? styleElement.textContent : '';

      // Build custom CSS for the exported file
      // If ratio is null, use default layout (video at minimum width)
      // If ratio is set, preserve the user's chosen split
      let customCSS = '';
      if (videoSectionRatio !== null) {
        const videoFr = Math.round(videoSectionRatio * 100);
        const timelineFr = 100 - videoFr;
        customCSS = `
    /* Preserve video section ratio for exported files */
    body[data-mode='read'] .main-content {
      grid-template-columns: ${timelineFr}fr minmax(560px, ${videoFr}fr);
      gap: 20px;
    }
    body[data-mode='edit'] .main-content {
      grid-template-columns: ${timelineFr}fr 20px minmax(560px, ${videoFr}fr);
    }`;
      }
      // If ratio is null, we don't add custom CSS - JS will handle it at minimum width

      // Get all the script content (we'll extract just the functions we need)
      const scriptElement = document.querySelector('script:not([src])');
      const scriptContent = scriptElement ? scriptElement.textContent : '';

      // Remove the exportZip and getExportTemplate functions from the script
      const cleanedScript = scriptContent
        .replace(/\/\/ Get the base HTML template for export[\s\S]*?return result;\s*\n\s*}\s*\n/m, '')
        .replace(/\/\/ Export everything as a zip file[\s\S]*?}\s*catch[\s\S]*?}\s*\n\s*}\s*\n/m, '')
        .replace(/let uploadedVideoFile = null;\s*\n/g, '')
        .replace(/const isExportMode = false;/g, 'const isExportMode = true;')
        .replace(/let isEditMode = true;/g, 'let isEditMode = false;')
        .replace(/\/\/ Initialize with default spec[\s\S]*?\/\/ Render the default timeline\s*\n\s*renderTimeline\(\);\s*\n/m, '');



      const result = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Motion Inspector</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Generator:%20Adobe%20Illustrator%2027.9.0,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%206.00%20Build%200)%20--%3e%3csvg%20version='1.1'%20id='Layer_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%20150%20150'%20style='enable-background:new%200%200%20150%20150;'%20xml:space='preserve'%3e%3cstyle%20type='text/css'%3e%20.st0{fill:%23FF385C;fill-rule:evenodd;clip-rule:evenodd;}%20%3c/style%3e%3cg%20id='Layer_1_00000076594398665045771890000013973700932976003724_'%3e%3cg%3e%3cpath%20class='st0'%20d='M131.3,118c-1.1,7.2-5.9,13.5-12.9,16.2c-3.4,1.3-7.1,1.9-10.7,1.3c-3.6-0.4-7.1-1.6-10.7-3.6%20c-5.1-2.8-10.2-7.2-16-13.5c9.3-11.3,15-21.7,17-31c0.9-4.3,1.2-8.3,0.7-11.9c-0.5-3.5-1.7-6.7-3.8-9.5%20c-4.3-6.3-11.7-9.9-19.8-9.9c-8.2,0-15.6,3.8-19.8,9.9c-1.9,2.8-3.2,6-3.8,9.5c-0.5,3.6-0.4,7.6,0.7,11.9c2.1,9.3,7.9,19.7,17,31%20c-5.8,6.4-10.9,10.7-16,13.5c-3.6,2-7.2,3.2-10.7,3.6c-3.8,0.4-7.4,0-10.7-1.3c-6.8-2.8-11.8-9-12.9-16.2c-0.5-3.6-0.1-7,1.2-10.9%20c0.5-1.3,1.1-2.8,1.9-4.4c1.1-2.3,2.1-4.7,3.2-7l0.1-0.3c9.7-20.9,20.1-42,30.8-62.9l0.4-0.8c1.1-2.1,2.3-4.3,3.4-6.4%20c1.2-2.1,2.4-4.3,4-6.2c3-3.5,6.8-5.2,11.3-5.2c4.4,0,8.3,1.9,11.3,5.2c1.6,1.9,2.8,4,4,6.2c1.1,2.1,2.3,4.3,3.4,6.4l0.4,0.9%20c10.9,20.8,21.2,42,30.8,62.9l0.1,0.1c1.1,2.3,2.1,4.7,3.2,7.1c0.7,1.6,1.3,3.1,1.9,4.4C131.4,111.1,131.8,114.6,131.3,118z%20M74.9,111.6c-7.6-9.7-12.5-18.5-14.2-26c-0.7-3.1-0.9-6-0.5-8.6c0.4-2.1,1.1-4.2,2.3-5.9c2.7-3.8,7.2-6,12.5-6%20c5.1,0,9.8,2.3,12.5,6c1.2,1.7,1.9,3.6,2.3,5.9c0.4,2.5,0.3,5.5-0.5,8.6C87.4,93.1,82.6,102,74.9,111.6z%20M138.5,104.2%20c-0.7-1.7-1.3-3.5-2-5.1c-1.1-2.4-2.1-4.8-3.4-7.2l-0.1-0.1c-9.8-20.9-20.2-42.2-31.1-63.2l-0.4-0.9c-1.1-2.1-2.3-4.3-3.5-6.6%20c-1.3-2.5-3-5.2-5.1-7.8C88.2,8,81.9,5,74.8,5c-7,0-13.4,3-18.1,8.3c-2.1,2.5-3.6,5.2-5.1,7.8c-1.2,2.1-2.3,4.4-3.5,6.6l-0.4,0.8%20C37.1,49.7,26.7,70.8,16.9,91.9l-0.1,0.3c-1.1,2.3-2.1,4.7-3.2,7.1c-0.7,1.6-1.5,3.2-2,5.1c-1.9,5.1-2.4,10.1-1.6,15%20c1.5,10.5,8.6,19.3,18.4,23.3c3.6,1.5,7.5,2.3,11.5,2.3c1.2,0,2.4-0.1,3.8-0.3c4.7-0.5,9.5-2.1,14.1-4.7%20c5.8-3.2,11.4-7.9,17.4-14.5c6.2,6.7,11.8,11.4,17.4,14.5c4.7,2.5,9.4,4.2,14.1,4.7c1.2,0.1,2.4,0.3,3.8,0.3c4,0,7.9-0.8,11.5-2.3%20c9.8-3.9,16.9-12.9,18.4-23.3C140.8,114.4,140.3,109.5,138.5,104.2z'/%3e%3c/g%3e%3c/g%3e%3cg%20id='Dimensions'%3e%3c/g%3e%3c/svg%3e">
  <style>${styles}${customCSS}</style>
</head>
<body data-mode="read">
  <div class="container">
    <div class="header-section">
      <h1 id="pageTitle" contenteditable="false">Motion Inspector</h1>
      <div class="view-mode-control">
        <button class="view-mode-btn selected" data-view="timeline" onclick="switchToView('timeline')">Timeline</button>
        <button class="view-mode-btn" data-view="table" onclick="switchToView('table')">Table</button>
      </div>
      <div class="controls">
        <button class="btn btn-secondary btn-circular help-btn export-only" id="helpBtn" onclick="toggleHelpTooltips()" data-tooltip="Help">?</button>
        <button class="btn btn-secondary btn-circular" onclick="copySpecJson()" data-tooltip="Copy Spec">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
        </button>
      </div>
    </div>

    <div class="main-content">
      <div class="timeline-wrapper">
        <div class="timeline-description-container">
          <textarea id="timelineDescription" class="timeline-description-input" placeholder="Add optional description" rows="1" readonly></textarea>
        </div>
        <div class="tabs-container" id="tabsContainer">
          <div class="tabs-bar">
            <!-- Tabs will be rendered here by JavaScript -->
          </div>
        </div>
        <div class="timeline-section">
          <div id="timelineContent"></div>
        </div>
      </div>

      <div class="resize-handle edit-only" id="resizeHandle"></div>

      <div class="video-section">
        <div class="video-nav-arrow left" id="videoNavLeft" onclick="switchVideo(-1)"></div>
        <div class="video-nav-arrow right" id="videoNavRight" onclick="switchVideo(1)"></div>
        <div id="videoEmptyState" class="video-empty-state edit-only" style="display: none;">
          <div class="video-empty-state-btn">
            <span></span>
            <span>Add Video</span>
          </div>
        </div>
        <div id="videoContainer" class="video-container">
          <div class="video-wrapper">
            <video id="videoPlayer" onclick="togglePlayPause()"></video>
            <button class="video-fullscreen-btn" onclick="event.stopPropagation(); toggleVideoFullscreen()" title="Fullscreen">
              <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
            </button>
            <div class="video-overlay edit-only">
              <div class="video-overlay-btn" onclick="document.getElementById('videoInput').click()">
                <span></span>
                <span>Replace Video</span>
              </div>
              <div class="video-overlay-btn" onclick="addAnotherVideo()">
                <span style="filter: brightness(10);"></span>
                <span>Add Another Video</span>
              </div>
            </div>
            <div class="video-description">
              <textarea id="videoDescription" class="video-description-input" placeholder="Add optional description" rows="1" oninput="saveDescription(this.value)" onfocus="this.select()" onkeydown="if(event.key==='Enter'){event.preventDefault();this.blur();}"></textarea>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
${cleanedScript}
    // Auto-load embedded data
    const EMBEDDED_TABS = ${tabsJson};
    const EXPORT_VIDEO_RATIO = ${videoSectionRatio};
    const EXPORT_COMPACT_SPACING = ${compactSpacing};

    window.addEventListener('DOMContentLoaded', () => {
      // Initialize grid based on exported ratio
      // EXPORT_VIDEO_RATIO is null if user never manually resized, or a number if they did
      if (EXPORT_VIDEO_RATIO !== null) {
        const availableWidth = getAvailableWidth();
        setVideoSectionWidth(availableWidth * EXPORT_VIDEO_RATIO);
        videoSectionWidthRatio = EXPORT_VIDEO_RATIO;
      } else {
        setVideoSectionWidth(VIDEO_MIN_WIDTH);
        // videoSectionWidthRatio stays null
      }

      // Load tabs array
      tabs = EMBEDDED_TABS;
      currentTabIndex = 0;
      nextTabId = tabs.length > 0 ? Math.max(...tabs.map(t => t.id)) + 1 : 1;

      // Group animations and ensure layer IDs for all tabs
      tabs.forEach(tab => {
        if (tab.specData) {
          groupAnimations(tab.specData);
          ensureLayerIds(tab.specData);
        }
      });

      // Update page title (always use Tab 1's title)
      const pageTitle = document.getElementById('pageTitle');
      const tab1Spec = tabs.length > 0 ? tabs[0].specData : null;
      if (pageTitle && tab1Spec && tab1Spec.compName) {
        pageTitle.textContent = tab1Spec.compName;
        document.title = tab1Spec.compName;
      }

      // Load video for current tab
      const currentTab = tabs[currentTabIndex];
      const currentVideo = currentTab && currentTab.videos && currentTab.videos.length > 0
        ? currentTab.videos[currentTab.currentVideoIndex || 0]
        : null;
      if (currentVideo && currentVideo.src) {
        video.src = currentVideo.src;
        const videoContainer = document.getElementById('videoContainer');
        if (videoContainer) {
          videoContainer.classList.add('has-video');
        }

        const onVideoReady = () => {
          videoDuration = video.duration * 1000;
          video.currentTime = 0;
          // Triple RAF to ensure layout is fully updated after potential padding change
          requestAnimationFrame(() => {
            updateVideoAlignment();
            requestAnimationFrame(() => {
              updateVideoAlignment();
              requestAnimationFrame(() => {
                updateVideoAlignment();
              });
            });
          });
        };

        // Check if video metadata is already loaded (cached video)
        if (video.readyState >= 1) {
          onVideoReady();
        } else {
          video.addEventListener('loadedmetadata', onVideoReady, { once: true });
        }
      }

      // Load description for current video
      if (currentVideo && currentVideo.description) {
        const descTextarea = document.getElementById('videoDescription');
        if (descTextarea) {
          descTextarea.value = currentVideo.description;
        }
      }

      // Load timeline description for current tab
      loadTimelineDescription();

      // Update video navigation for read mode (if multiple videos)
      if (typeof updateVideoNavigation === 'function') {
        updateVideoNavigation();
      }

      // Set specData from current tab (required for renderTimeline)
      specData = tabs[currentTabIndex].specData;

      // Reset viewDuration so it recalculates from specData.workArea.duration
      viewDuration = null;

      // Render tabs and timeline
      renderTabs();

      // Check if all tabs have empty descriptions
      const allDescriptionsEmpty = tabs.every(tab => !tab.specData || !tab.specData.description || tab.specData.description.trim() === '');
      if (allDescriptionsEmpty) {
        document.body.classList.add('no-descriptions');
      }

      // Hide tabs container if only one tab
      if (tabs.length === 1) {
        document.body.classList.add('single-tab');
        const tabsContainer = document.getElementById('tabsContainer');
        if (tabsContainer) {
          tabsContainer.style.display = 'none';
        }

        // Adjust top spacing for single tab (no description)
        const headerSection = document.querySelector('.header-section');
        if (headerSection) {
          headerSection.style.paddingTop = '0px';
          headerSection.style.marginBottom = '16px';
          headerSection.style.transform = 'translateY(-2px)';
        }

        // Adjust container heights for smaller top spacing
        const videoSection = document.querySelector('.video-section');
        const videoElement = document.querySelector('video');
        const timelineWrapper = document.querySelector('.timeline-wrapper');

        if (videoSection) {
          videoSection.style.height = 'calc(100vh - 96px)';
          videoSection.style.maxHeight = 'calc(100vh - 96px)';
        }
        if (videoElement) {
          videoElement.style.maxHeight = 'calc(100vh - 96px)';
        }
        if (timelineWrapper) {
          timelineWrapper.style.height = 'calc(100vh - 96px)';
          timelineWrapper.style.marginTop = '0';
          timelineWrapper.style.paddingTop = '0';
        }
      }

      renderTimeline();

      // Apply compact spacing immediately if it was compact in the editor
      if (EXPORT_COMPACT_SPACING) {
        const outerWrapper = document.querySelector('.timeline-outer-wrapper');
        if (outerWrapper) {
          outerWrapper.classList.add('has-scroll');
        }
        needsCompactSpacing = true;
      }

      // Re-check section spacing after render (handles window resize, etc.)
      requestAnimationFrame(() => updateSectionSpacing(true));
    });
  <\/script>

  <!-- Help tooltips -->
  <div id="helpScrim" class="help-scrim"></div>
  <div id="helpTooltipPlayhead" class="help-tooltip arrow-down-center">Drag playhead to scrub the video</div>
  <div id="helpTooltipViewMode" class="help-tooltip arrow-up-center">Switch between view modes</div>
  <div id="helpTooltipColorBar" class="help-tooltip arrow-up-center">Click to see animation details</div>
  <div id="helpTooltipSlack" class="help-tooltip arrow-right">Questions? Find us in <a href="https://airbnb.enterprise.slack.com/archives/C0A48KDC0" target="_blank">#motion</a></div>

</body>
</html>`;

      return result;
    }

    // Export everything as a zip file
    async function exportZip() {
      if (!tabs || tabs.length === 0) {
        alert('Please paste a spec first ( Paste Spec button)');
        return;
      }

      try {
        // Export the user's ratio setting (null if never manually resized, number if they did)
        // This preserves the user's intent in the exported file
        const exportRatio = videoSectionWidthRatio;

        // Create zip file
        const zip = new JSZip();

        // Prepare tabs for export and add videos to zip
        const exportTabs = tabs.map((tab, index) => {
          // Export all videos for this tab
          const exportVideos = [];

          if (tab.videos && tab.videos.length > 0) {
            tab.videos.forEach((video, videoIndex) => {
              if (video.file) {
                // Get video file extension
                const originalName = video.file.name;
                const videoExt = originalName.substring(originalName.lastIndexOf('.'));
                const videoFileName = `video_tab${tab.id}_${videoIndex + 1}${videoExt}`;

                // Add video to zip
                zip.file(videoFileName, video.file);

                const exportVideo = {
                  id: video.id || generateVideoId(),
                  src: `./${videoFileName}`
                };
                // Only include description if it's not empty
                if (video.description && video.description.trim()) {
                  exportVideo.description = video.description;
                }
                exportVideos.push(exportVideo);
              }
            });
          }

          // Filter out default/placeholder sections from specData
          const filteredSpecData = filterDefaultSections(tab.specData);

          const exportTab = {
            id: tab.id,
            name: tab.name,
            specData: filteredSpecData,
            videos: exportVideos,
            currentVideoIndex: 0  // Always start with first video when opening exported file
          };
          return exportTab;
        });

        // Helper function to filter out default placeholder sections
        function filterDefaultSections(specData) {
          if (!specData || !specData.layers) return specData;

          const defaultValues = ['New Section', 'Add parameter', 'Add description'];

          const filteredLayers = specData.layers.filter(layer => {
            // Check if layer name is a default placeholder
            const layerNameLower = layer.layerName?.toLowerCase() || '';
            const isDefaultLayerName = defaultValues.some(d => layerNameLower === d.toLowerCase());

            // Check if all animations have default values
            const allAnimsDefault = layer.animations?.every(anim => {
              const propLower = anim.property?.toLowerCase() || '';
              const descLower = anim.description?.toLowerCase() || '';
              return defaultValues.some(d => propLower === d.toLowerCase()) ||
                     defaultValues.some(d => descLower === d.toLowerCase());
            });

            // Exclude if layer name is default AND all animations are default
            if (isDefaultLayerName && allAnimsDefault) {
              return false;
            }

            return true;
          });

          return {
            ...specData,
            layers: filteredLayers
          };
        }

        // Generate clean HTML template
        const tabsJson = JSON.stringify(exportTabs);
        const exportHtml = getExportTemplate('', tabsJson, exportRatio, needsCompactSpacing);

        // Create download link with spec name
        const specName = tabs[0].specData.compName;

        // Add HTML to zip
        zip.file(`${specName}.html`, exportHtml);

        // Generate zip and download
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        const zipUrl = URL.createObjectURL(zipBlob);
        const link = document.createElement('a');
        link.href = zipUrl;
        link.download = `${specName}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(zipUrl);
      } catch (err) {
        alert('Failed to create zip file: ' + err.message);
        console.error(err);
      }
    }

    // Group matching animations (X/Y Position, Width/Height)
    function groupAnimations(specData) {
      if (!specData || !specData.layers) return;


      specData.layers.forEach((layer, layerIdx) => {
        if (!layer.animations || layer.animations.length < 2) return;


        const toRemove = [];
        const toAdd = [];

        // Check each animation for potential grouping
        for (let i = 0; i < layer.animations.length; i++) {
          if (toRemove.includes(i)) continue;

          const anim1 = layer.animations[i];
          const prop1 = anim1.property.toLowerCase();

          // Check for X Position + Y Position
          if (prop1.includes('x position')) {
            for (let j = i + 1; j < layer.animations.length; j++) {
              if (toRemove.includes(j)) continue;

              const anim2 = layer.animations[j];
              const prop2 = anim2.property.toLowerCase();

              if (prop2.includes('y position')) {

                if (animationsMatch(anim1, anim2)) {
                  // Create combined Position animation
                  toAdd.push(createGroupedAnimation(anim1, anim2, 'Position', 'position'));
                  toRemove.push(i, j);
                  break;
                } else {
                }
              }
            }
          }

          // Check for Width + Height
          if (prop1.includes('width') && !prop1.includes('x position')) {
            for (let j = i + 1; j < layer.animations.length; j++) {
              if (toRemove.includes(j)) continue;

              const anim2 = layer.animations[j];
              const prop2 = anim2.property.toLowerCase();

              if (prop2.includes('height') && !prop2.includes('y position')) {

                if (animationsMatch(anim1, anim2)) {
                  // Create combined Width & Height animation
                  toAdd.push(createGroupedAnimation(anim1, anim2, 'Width & Height', 'size'));
                  toRemove.push(i, j);
                  break;
                } else {
                }
              }
            }
          }
        }

        // Remove grouped animations and add combined ones at the original position
        if (toRemove.length > 0) {

          // Sort toRemove to process from highest to lowest index
          toRemove.sort((a, b) => b - a);

          // Insert grouped animations at the position of the first removed animation
          const insertPosition = Math.min(...toRemove);

          // Remove the animations (in reverse order to preserve indices)
          for (const idx of toRemove) {
            layer.animations.splice(idx, 1);
          }

          // Insert grouped animations at the original position
          layer.animations.splice(insertPosition, 0, ...toAdd);
        }
      });

    }

    // Check if two animations match (same delay, duration, easing)
    function animationsMatch(anim1, anim2) {
      // Always check delay
      if (anim1.timing.delay !== anim2.timing.delay) {
        return false;
      }

      // Check easing type
      if (anim1.easing.type !== anim2.easing.type) {
        return false;
      }

      // For cubic-bezier, check duration AND bezier values
      if (anim1.easing.type === 'cubic-bezier') {
        // Check duration for cubic-bezier animations
        if (anim1.timing.duration !== anim2.timing.duration) {
          return false;
        }

        const match = anim1.easing.cubicBezier === anim2.easing.cubicBezier;
        if (!match) {
        }
        return match;
      }

      // For springs, IGNORE duration (it's calculated from physics), only check spring parameters
      if (anim1.easing.type === 'spring') {
        const spring1 = anim1.easing.spring?.custom;
        const spring2 = anim2.easing.spring?.custom;

        const match = spring1?.stiffness === spring2?.stiffness &&
               spring1?.damping === spring2?.damping &&
               spring1?.dampingRatio === spring2?.dampingRatio &&
               spring1?.mass === spring2?.mass;

        if (!match) {
        }

        return match;
      }

      return true;
    }

    // Create a grouped animation from two matching animations
    function createGroupedAnimation(anim1, anim2, propertyName, groupType) {
      const grouped = { ...anim1 };
      grouped.property = propertyName;
      grouped.isGrouped = true;
      grouped.groupType = groupType; // 'position' or 'size'
      grouped.groupedAnimations = [anim1, anim2];

      // Build combined values structure for description generation
      if (groupType === 'position') {
        // Determine which is X and which is Y
        const xAnim = anim1.property.toLowerCase().includes('x position') ? anim1 : anim2;
        const yAnim = anim1.property.toLowerCase().includes('x position') ? anim2 : anim1;

        const xChange = xAnim.values?.change || 0;
        const yChange = yAnim.values?.change || 0;

        // Only show values that changed, with (X)/(Y) labels
        const xStart = xAnim.values?.startValue;
        const xEnd = xAnim.values?.endValue;
        const yStart = yAnim.values?.startValue;
        const yEnd = yAnim.values?.endValue;

        const startParts = [];
        const endParts = [];

        if (xChange !== 0) {
          startParts.push(`${Math.round(xStart)}px (X)`);
          endParts.push(`${Math.round(xEnd)}px (X)`);
        }
        if (yChange !== 0) {
          startParts.push(`${Math.round(yStart)}px (Y)`);
          endParts.push(`${Math.round(yEnd)}px (Y)`);
        }

        grouped.values = {
          change: [xChange, yChange],
          animatingAxes: {
            both: true,
            x: true,
            y: true
          },
          formatted: {
            startValue: startParts.join('\n') || '-',
            endValue: endParts.join('\n') || '-'
          }
        };
      } else if (groupType === 'size') {
        // Determine which is Width and which is Height
        const widthAnim = anim1.property.toLowerCase().includes('width') ? anim1 : anim2;
        const heightAnim = anim1.property.toLowerCase().includes('width') ? anim2 : anim1;

        const widthChange = widthAnim.values?.change || 0;
        const heightChange = heightAnim.values?.change || 0;

        grouped.values = {
          change: [widthChange, heightChange],
          formatted: {
            startValue: `${widthAnim.values?.formatted?.startValue || '-'}\n${heightAnim.values?.formatted?.startValue || '-'}`,
            endValue: `${widthAnim.values?.formatted?.endValue || '-'}\n${heightAnim.values?.formatted?.endValue || '-'}`
          }
        };
      }

      return grouped;
    }

    // Get color class for property
    function getPropertyColorClass(property) {
      const prop = property.toLowerCase();
      if (prop.includes('add parameter')) return 'bar-scale'; // Pink color for new parameters
      if (prop.includes('width & height')) return 'bar-width'; // Grouped Width & Height uses Width color
      if (prop.includes('position')) return 'bar-position-x'; // Grouped position uses same color as X Position
      if (prop.includes('opacity')) return 'bar-opacity';
      if (prop.includes('scale')) return 'bar-scale';
      if (prop.includes('rotation') || prop.includes('rotate')) return 'bar-rotation';
      if (prop.includes('x position')) return 'bar-position-x';
      if (prop.includes('y position')) return 'bar-position-y';
      if (prop.includes('width')) return 'bar-width';
      if (prop.includes('height')) return 'bar-height';
      if (prop.includes('blur')) return 'bar-blur';
      if (prop.includes('transform')) return 'bar-transform';
      if (prop.includes('corner')) return 'bar-position-x'; // Corner radius/smoothing uses blue
      return 'bar-default';
    }

    // Get hex color for property color class
    function getPropertyColor(colorClass) {
      const colorMap = {
        'bar-opacity': '#056e53',
        'bar-scale': '#7d29a0',
        'bar-rotation': '#6c1c90',
        'bar-position-x': '#056e96',
        'bar-position-y': '#056e96',
        'bar-width': '#ca317d',
        'bar-height': '#ca317d',
        'bar-blur': '#595959',
        'bar-transform': '#6c1c90',
        'bar-default': '#056e96'
      };
      return colorMap[colorClass] || '#056e96';
    }

    // Brighten a hex color to match the selected state (1.2x brightness)
    function brightenColor(hex) {
      // Remove # if present
      hex = hex.replace('#', '');

      // Parse RGB
      let r = parseInt(hex.substring(0, 2), 16);
      let g = parseInt(hex.substring(2, 4), 16);
      let b = parseInt(hex.substring(4, 6), 16);

      // Apply same brightness filter as selected bars (1.2x)
      r = Math.min(255, Math.round(r * 1.2));
      g = Math.min(255, Math.round(g * 1.2));
      b = Math.min(255, Math.round(b * 1.2));

      // Add more brightness to make it pop like the stroke
      r = Math.min(255, Math.round(r * 1.5));
      g = Math.min(255, Math.round(g * 1.5));
      b = Math.min(255, Math.round(b * 1.5));

      // Convert back to hex
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    // Convert video time to timeline position percentage
    function getTimelinePosition(videoTimeSeconds) {
      if (!video.duration || !specData) return 0;
      // Direct time mapping in milliseconds (not percentage-based)
      const specTimeMs = videoTimeSeconds * 1000;
      // Position based on current view duration (accounts for zoom)
      const currentViewDuration = viewDuration || specData.workArea.duration;
      // Clamp to 100% so playhead never goes past timeline end
      return Math.min((specTimeMs / currentViewDuration) * 100, 100);
    }

    // Convert alignment number to text
    function getAlignmentText(alignment) {
      const alignments = {
        1: 'center',
        2: 'center left',
        3: 'center right',
        5: 'top center',
        6: 'top left',
        7: 'top right',
        9: 'bottom center',
        10: 'bottom left',
        11: 'bottom right'
      };
      return alignments[alignment] || 'unknown';
    }

    // Format numeric values to max 2 decimal places
    function formatDecimalValue(value) {
      if (value === null || value === undefined) return value;

      // Convert to string if it's a number
      const strValue = String(value);

      // Replace all numbers in the string, preserving units and formatting
      return strValue.replace(/(\d+\.?\d*)/g, (match) => {
        const num = parseFloat(match);
        if (isNaN(num)) return match;

        // If it's a whole number, return as is
        if (num % 1 === 0) return String(num);

        // Otherwise round to 2 decimal places and remove trailing zeros
        return parseFloat(num.toFixed(2)).toString();
      });
    }

    // Convert scaleTo number to text
    function getScaleToText(scaleTo) {
      const scaleOptions = {
        1: 'width',
        2: 'height',
        3: 'stretch',
        4: 'none'
      };
      return scaleOptions[scaleTo] || 'unknown';
    }

    // Get scale divisor from appliedScale - values in JSON are already correct,
    // so we return 1 (no scaling needed). The appliedScale is just metadata.
    function getScaleDivisor() {
      return 1;
    }

    // Scale a pixel value by the appliedScale divisor (currently no-op since divisor is 1)
    function scaleValue(value) {
      // Handle string values gracefully
      if (typeof value === 'string') {
        const num = parseFloat(value);
        if (isNaN(num)) return 0; // Return 0 if can't parse
        return Math.round(num);
      }
      if (typeof value !== 'number' || isNaN(value)) return 0;
      return Math.round(value);
    }

    // Scale pixel values in a formatted string - currently returns unchanged
    // since JSON values are already correct
    function scaleFormattedValue(str, property) {
      return str;
    }

    // Get natural language description of animation
    function getAnimationDescription(property, values, fitToShape, customDescription, layerName) {
      const prop = property.toLowerCase();
      let description;

      // Check for custom description first (allow empty strings)
      if (customDescription !== undefined && customDescription !== null) {
        return customDescription;
      }

      // Note: fitToShape info is now shown in the child layer header row,
      // so we generate the actual animation description here instead

      // Handle cases where values is null
      if (!values || values.change === undefined || values.change === null) {
        description = property;
      }
      else {
        const change = values.change;
        const changeValue = Array.isArray(change) ? change[0] : change;
        const absChange = Math.abs(changeValue);

        // Handle generic "Position" property (not X/Y Position)
        if (prop === 'position' && Array.isArray(change) && values.animatingAxes) {
          const xChange = change[0];
          const yChange = change[1];
          const absXChange = Math.abs(xChange);
          const absYChange = Math.abs(yChange);

          if (values.animatingAxes.both) {
            const xDir = xChange < 0 ? 'left' : 'right';
            const yDir = yChange < 0 ? 'up' : 'down';
            description = `Moves ${xDir} ${scaleValue(absXChange)}px and ${yDir} ${scaleValue(absYChange)}px`;
          } else if (values.animatingAxes.x) {
            const direction = xChange < 0 ? 'left' : 'right';
            description = `Moves ${direction} ${scaleValue(absXChange)}px`;
          } else if (values.animatingAxes.y) {
            const direction = yChange < 0 ? 'up' : 'down';
            description = `Moves ${direction} ${scaleValue(absYChange)}px`;
          } else {
            description = property;
          }
        }
        else if (prop.includes('x position')) {
          // Check for zero change
          if (changeValue === 0) {
            description = `X Position stays at ${scaleValue(values.startValue)}px`;
          } else {
            const direction = changeValue < 0 ? 'left' : 'right';
            description = `Moves ${direction} ${scaleValue(absChange)}px`;
          }
        }
        else if (prop.includes('y position')) {
          // Check for zero change
          if (changeValue === 0) {
            description = `Y Position stays at ${scaleValue(values.startValue)}px`;
          } else {
            const direction = changeValue < 0 ? 'up' : 'down';
            description = `Moves ${direction} ${scaleValue(absChange)}px`;
          }
        }
        // Handle grouped "Width & Height" property
        else if (prop.includes('width & height') && Array.isArray(change)) {
          const widthChange = change[0];
          const heightChange = change[1];
          const widthAction = widthChange > 0 ? 'expands' : 'shrinks';
          const heightAction = heightChange > 0 ? 'expands' : 'shrinks';

          // Get values - try array format first, then formatted values, then raw values
          let widthStartVal, widthEndVal, heightStartVal, heightEndVal;

          if (Array.isArray(values.startValue) && values.startValue.length >= 2) {
            widthStartVal = Math.round(values.startValue[0]);
            heightStartVal = Math.round(values.startValue[1]);
          } else if (values.formatted?.startValue) {
            // Parse from formatted string like "100px, 200px"
            const startMatch = values.formatted.startValue.match(/(-?\d+\.?\d*)/g);
            if (startMatch && startMatch.length >= 2) {
              widthStartVal = Math.round(parseFloat(startMatch[0]));
              heightStartVal = Math.round(parseFloat(startMatch[1]));
            }
          }

          if (Array.isArray(values.endValue) && values.endValue.length >= 2) {
            widthEndVal = Math.round(values.endValue[0]);
            heightEndVal = Math.round(values.endValue[1]);
          } else if (values.formatted?.endValue) {
            // Parse from formatted string like "100px, 200px"
            const endMatch = values.formatted.endValue.match(/(-?\d+\.?\d*)/g);
            if (endMatch && endMatch.length >= 2) {
              widthEndVal = Math.round(parseFloat(endMatch[0]));
              heightEndVal = Math.round(parseFloat(endMatch[1]));
            }
          }

          // Fallback: calculate from change values if we have at least start or end
          if (widthStartVal === undefined && widthEndVal !== undefined) {
            widthStartVal = widthEndVal - widthChange;
          } else if (widthEndVal === undefined && widthStartVal !== undefined) {
            widthEndVal = widthStartVal + widthChange;
          }
          if (heightStartVal === undefined && heightEndVal !== undefined) {
            heightStartVal = heightEndVal - heightChange;
          } else if (heightEndVal === undefined && heightStartVal !== undefined) {
            heightEndVal = heightStartVal + heightChange;
          }

          // Build description with available values
          const widthDesc = (widthStartVal !== undefined && widthEndVal !== undefined)
            ? `Width ${widthAction} ${widthStartVal}px  ${widthEndVal}px`
            : `Width ${widthAction} ${Math.abs(widthChange)}px`;
          const heightDesc = (heightStartVal !== undefined && heightEndVal !== undefined)
            ? `Height ${heightAction} ${heightStartVal}px  ${heightEndVal}px`
            : `Height ${heightAction} ${Math.abs(heightChange)}px`;

          description = `${widthDesc} and ${heightDesc}`;
        }
        else if (prop.includes('width')) {
          if (changeValue === 0) {
            description = `width stays at ${scaleValue(values.startValue)}px`;
          } else {
            const action = changeValue > 0 ? 'expands' : 'shrinks';
            description = `width ${action} ${scaleValue(values.startValue)}px  ${scaleValue(values.endValue)}px`;
          }
        }
        else if (prop.includes('height')) {
          if (changeValue === 0) {
            description = `height stays at ${scaleValue(values.startValue)}px`;
          } else {
            const action = changeValue > 0 ? 'expands' : 'shrinks';
            description = `height ${action} ${scaleValue(values.startValue)}px  ${scaleValue(values.endValue)}px`;
          }
        }
        else if (prop.includes('blur radius')) {
          if (changeValue === 0) {
            description = `blur stays at ${values.formatted?.startValue || Math.round(values.startValue)}`;
          } else {
            const action = changeValue > 0 ? 'blurs' : 'unblurs';
            description = `Layer ${action}`;
          }
        }
        else if (prop.includes('amount to tint')) {
          if (changeValue === 0) {
            description = `tint stays at ${values.formatted?.startValue || Math.round(values.startValue)}`;
          } else {
            const action = changeValue > 0 ? 'tints' : 'untints';
            description = action;
          }
        }
        else if (prop.includes('scale')) {
          if (values.formatted) {
            // Extract just the first value if x and y are the same
            let startVal = values.formatted.startValue;
            let endVal = values.formatted.endValue;

            // Check if it's a format like "100%, 100%" and extract first value
            if (typeof startVal === 'string' && startVal.includes(',')) {
              const startParts = startVal.split(',').map(s => s.trim());
              if (startParts[0] === startParts[1]) {
                startVal = startParts[0];
              }
            }
            if (typeof endVal === 'string' && endVal.includes(',')) {
              const endParts = endVal.split(',').map(s => s.trim());
              if (endParts[0] === endParts[1]) {
                endVal = endParts[0];
              }
            }

            // Format decimal values
            startVal = formatDecimalValue(startVal);
            endVal = formatDecimalValue(endVal);

            if (startVal === endVal) {
              description = `scale stays at ${endVal}`;
            } else {
              // Determine direction by parsing numeric values
              const startNum = parseFloat(startVal);
              const endNum = parseFloat(endVal);
              const direction = endNum > startNum ? 'Scales up' : 'Scales down';
              description = `${direction} ${startVal}  ${endVal}`;
            }
          } else {
            // No formatted values available
            if (changeValue === 0) {
              description = `scale stays at ${Math.round(values.startValue)}%`;
            } else {
              const direction = values.endValue > values.startValue ? 'Scales up' : 'Scales down';
              description = `${direction} ${Math.round(values.startValue)}%  ${Math.round(values.endValue)}%`;
            }
          }
        }
        else if (prop.includes('rotation') || prop.includes('rotate')) {
          // Check for zero change
          if (changeValue === 0) {
            description = `rotation stays at ${values.formatted?.startValue || Math.round(values.startValue)}`;
          } else {
            const direction = changeValue < 0 ? 'counterclockwise' : 'clockwise';
            const degrees = Math.round(absChange);

            // Determine axis (if specified)
            const axis = prop.includes('x rotation') ? 'X ' :
                        prop.includes('y rotation') ? 'Y ' :
                        prop.includes('z rotation') ? 'Z ' : '';

            description = `rotates ${axis}${degrees} ${direction}`;
          }
        }
        else if (prop.includes('opacity')) {
          const startValue = values.startValue;
          const endValue = values.endValue;

          // Format opacity values (remove % if present, show as percentage)
          const startPercent = `${Math.round(typeof startValue === 'string' ? parseFloat(startValue) : startValue)}%`;
          const endPercent = `${Math.round(typeof endValue === 'string' ? parseFloat(endValue) : endValue)}%`;

          // Check zero change FIRST before other conditions
          if (changeValue === 0) {
            description = `opacity stays at ${startPercent}`;
          } else if (endValue > startValue) {
            // Fading in (opacity increasing)
            description = `Fades-in ${startPercent}  ${endPercent}`;
          } else {
            // Fading out (opacity decreasing)
            description = `Fades-out ${startPercent}  ${endPercent}`;
          }
        }
        // Handle corner radius properties (IndieCorners, Squircle, generic corner/radius)
        else if (prop === 'tl' || prop === 'tr' || prop === 'bl' || prop === 'br' ||
                 prop === 'unified radius' || prop === 'unified corners' ||
                 prop.includes('corner') || prop.includes('radius') ||
                 prop.includes('border radius')) {
          const startRounded = Math.round(typeof values.startValue === 'string' ? parseFloat(values.startValue) : values.startValue);
          const endRounded = Math.round(typeof values.endValue === 'string' ? parseFloat(values.endValue) : values.endValue);

          // Special case: Sharp to rounded
          if (startRounded === 0 && endRounded > 0) {
            description = `Corner animates from sharp (0px)  rounded (${endRounded}px)`;
          }
          // Special case: Rounded to sharp
          else if (startRounded > 0 && endRounded === 0) {
            description = `Corner animates from rounded (${startRounded}px)  sharp (0px)`;
          }
          // Zero change
          else if (startRounded === endRounded) {
            description = `Corner stays at ${startRounded}px`;
          }
          // Default
          else {
            description = `Corner animates from ${startRounded}px  ${endRounded}px`;
          }
        }
        else {
          // Generic fallback for unknown properties
          if (changeValue === 0) {
            description = `${property} does not change`;
          } else {
            description = property;
          }
        }
      }

      // Capitalize first letter
      return description.charAt(0).toUpperCase() + description.slice(1);
    }

    // Generate nice time divisions
    function getNiceTimeIntervals(duration) {
      const niceIntervals = [25, 50, 100, 200, 250, 500, 1000, 2000, 2500, 5000];

      for (const interval of niceIntervals) {
        const divisions = Math.floor(duration / interval);
        if (divisions >= 5 && divisions <= 12) {
          return { interval, count: divisions };
        }
      }

      // Fallback: divide by 8
      return { interval: duration / 8, count: 8 };
    }

    // Helper function to refresh the active view
    function refreshActiveView() {
      // Don't render if no tabs exist
      if (currentTabIndex === -1) return;

      if (viewMode === 'table') {
        renderTableView();
      } else {
        renderTimeline();
      }

      // Apply spacing class immediately to prevent flash
      const outerWrapper = document.querySelector('.timeline-outer-wrapper');
      if (outerWrapper && needsCompactSpacing) {
        outerWrapper.classList.add('has-scroll');
      }

      // If an animation is selected, refresh its detail panel and re-apply selected state
      // Only show detail panel in timeline mode, not table mode
      if (viewMode !== 'table' && selectedAnimation !== null) {
        showAnimationDetails(selectedAnimation);
        // Re-apply selected class to timeline bar and label after re-render
        const bar = document.querySelector(`.timeline-bar[data-anim-index="${selectedAnimation}"]`);
        const label = document.querySelector(`.timeline-label.indented[data-anim-index="${selectedAnimation}"]`);
        if (bar) bar.classList.add('selected');
        if (label) label.classList.add('selected');
      }
      // If a parented layer is selected, refresh its detail panel and re-apply selected state
      // Only show detail panel in timeline mode, not table mode
      if (viewMode !== 'table' && selectedParentedLayerIndex !== null) {
        showParentedLayerDetails(selectedParentedLayerIndex);
        // Re-apply selected class to bar and label after re-render
        const bar = document.querySelector(`.timeline-bar[data-layer-index="${selectedParentedLayerIndex}"][data-is-attached="true"]`);
        const label = document.querySelector(`.timeline-label.child-layer-header[data-layer-index="${selectedParentedLayerIndex}"]`);
        if (bar) bar.classList.add('selected');
        if (label) label.classList.add('selected');
      }
      // Apply existing section spacing state (preserve across view switches)
      requestAnimationFrame(() => {
        requestAnimationFrame(() => updateSectionSpacing(false));
      });
    }

    // Auto-resize title input fields to fit content
    function autoResizeTitleInput(input) {
      // Create a temporary span to measure text width
      const temp = document.createElement('span');
      temp.style.font = window.getComputedStyle(input).font;
      temp.style.fontWeight = '700';
      temp.style.visibility = 'hidden';
      temp.style.position = 'absolute';
      temp.style.whiteSpace = 'pre';
      temp.textContent = input.value || input.placeholder || '';
      document.body.appendChild(temp);

      // Set width with some padding - property fields allow larger widths
      const isPropertyField = input.classList.contains('detail-title-input-property');
      const maxWidth = isPropertyField ? 500 : 200;
      const width = Math.min(Math.max(temp.offsetWidth + 16, 40), maxWidth);
      input.style.width = width + 'px';

      document.body.removeChild(temp);
    }

    // Validate numeric field (for delay and duration)
    function validateNumeric(value, previousValue) {
      // Try to parse as float
      const num = parseFloat(value);

      // If invalid or negative, return previous value
      if (isNaN(num) || num < 0) {
        return previousValue;
      }

      return num;
    }

    // Update a layer field and refresh views
    function updateLayerField(layerIndex, fieldName, newValue) {
      if (layerIndex >= 0 && layerIndex < specData.layers.length) {
        saveSnapshot();
        const oldValue = specData.layers[layerIndex][fieldName];
        specData.layers[layerIndex][fieldName] = newValue;

        // If layerName changed, update any child layers that reference this as parent
        if (fieldName === 'layerName' && oldValue !== newValue) {
          specData.layers.forEach(layer => {
            if (layer.parenting && layer.parenting.parentName === oldValue) {
              layer.parenting.parentName = newValue;
            }
          });
        }

        // Refresh the view - this will update:
        // 1. Left column layer header in timeline/table
        // 2. All info boxes for animations in this layer (they all reference layer.layerName)
        refreshActiveView();
      }
    }

    // Generate the attached description for child layers
    function getInheritedDescription(childLayer) {
      if (!childLayer.parenting) return '';

      // If user has set a custom description, use it
      if (childLayer.parentingDescription) {
        return childLayer.parentingDescription;
      }

      // Simple description with just parent name
      const parentName = childLayer.parenting.parentName;
      return `Attached to ${parentName}`;
    }

    // Get available parent layers for a given layer
    // Returns layers that can be selected as parents (top-level only, excluding current layer)
    function getAvailableParentLayers(currentLayerIndex) {
      if (!specData || !specData.layers) return [];

      const availableParents = [];
      specData.layers.forEach((layer, index) => {
        // Exclude the current layer
        if (index === currentLayerIndex) return;
        // Exclude layers that already have a parent (only allow 1 level of nesting)
        if (layer.parenting) return;
        // This layer can be a parent
        availableParents.push({ name: layer.layerName, index: index });
      });

      return availableParents;
    }

    // Update an animation field and refresh views
    function updateAnimationField(animIndex, fieldName, newValue) {
      saveSnapshot();
      // Find the animation in specData
      let currentIndex = 0;
      for (let layerIndex = 0; layerIndex < specData.layers.length; layerIndex++) {
        const layer = specData.layers[layerIndex];
        for (let animIdx = 0; animIdx < layer.animations.length; animIdx++) {
          if (currentIndex === animIndex) {
            const anim = layer.animations[animIdx];

            // Update the field
            if (fieldName === 'customDescription') {
              anim.description = newValue;
            } else if (fieldName === 'delay') {
              // Validate and update delay (must be numeric)
              anim.timing.delay = validateNumeric(newValue, anim.timing.delay);
            } else if (fieldName === 'duration') {
              // Update duration - accept numbers or "-"
              const num = parseFloat(newValue);
              if (!isNaN(num) && num >= 0) {
                // Valid number - curve style
                anim.timing.duration = num;
                // Mark that duration has been explicitly set by user
                anim.durationUserSet = true;
              } else if (newValue === '-' || newValue.trim() === '') {
                // "-" or empty - spring style
                anim.timing.duration = '-';
                anim.durationUserSet = true;
              } else {
                // Invalid input, keep previous value
                anim.timing.duration = anim.timing.duration;
              }
            } else if (fieldName === 'easing') {
              // Update easing - allow any text value
              anim.customEasing = newValue;

              // Detect spring parameters and auto-switch to spring style
              const springKeywords = ['stiffness', 'damping', 'mass'];
              const lowerValue = newValue.toLowerCase();
              const hasSpringParams = springKeywords.some(keyword => lowerValue.includes(keyword));

              // Detect curve parameters (cubic-bezier or 4 comma-separated numbers)
              const hasCubicKeyword = lowerValue.includes('cubic');
              // Match pattern like "0.2, 0, 0.2, 1" or "0.2,0,0.2,1" (4 numbers with 3 commas)
              const curveNumberPattern = /[\d.]+\s*,\s*[\d.]+\s*,\s*[\d.]+\s*,\s*[\d.]+/;
              const hasCurveParams = hasCubicKeyword || curveNumberPattern.test(newValue);

              if (hasSpringParams) {
                // Set duration to "-" to trigger spring style bar
                anim.timing.duration = '-';
                anim.durationUserSet = true;
                // Calculate spring duration from params for bar width
                const springParams = parseSpringParams(newValue);
                if (springParams) {
                  anim.calculatedSpringDuration = calculateSpringDuration(
                    springParams.stiffness,
                    springParams.damping,
                    springParams.mass
                  );
                }
              } else if (hasCurveParams) {
                // Ensure duration is a number for curve style bar
                if (anim.timing.duration === '-' || anim.timing.duration === undefined || anim.timing.duration === null) {
                  anim.timing.duration = 300;
                }
                anim.durationUserSet = true;
              }
            } else if (fieldName === 'startValue') {
              // Update start value - no validation
              anim.customStartValue = newValue;
            } else if (fieldName === 'endValue') {
              // Update end value - no validation
              anim.customEndValue = newValue;
            } else if (fieldName === 'property') {
              // Lock in the current auto-generated description before changing property name
              // This prevents the description from changing when the property name is edited
              if (anim.description === undefined || anim.description === null) {
                anim.description = getAnimationDescription(anim.property, anim.values, anim.fitToShape, null, layer.layerName);
              }
              // Update property name - no validation
              anim.property = newValue;
            } else {
              anim[fieldName] = newValue;
            }

            // Refresh the view
            refreshActiveView();
            return;
          }
          currentIndex++;
        }
      }
    }

    // Render the timeline
    function renderTimeline() {
      if (!specData) {
        return;
      }

      const content = document.getElementById('timelineContent');

      // Update the main title with the spec name
      document.querySelector('h1').textContent = specData.compName;
      // Update the page title
      document.title = specData.compName;

      let html = '';

      // Outer wrapper containing header + scroll area
      html += `<div class="timeline-outer-wrapper">`;

      // ===== HEADER ROW (fixed, outside scroll) =====
      html += `<div class="timeline-header-row">`;

      // Left side of header - playhead controls
      html += `<div class="playhead-time">
        <button id="playPauseBtn" onclick="togglePlayPause()"><span class="icon"><svg viewBox="0 0 10 12"><path d="M1 1.5 L8.5 6 L1 10.5 Z" stroke="white" stroke-width="2" stroke-linejoin="round" fill="white"/></svg></span></button>
        <span style="position: relative; display: inline-flex;">
          <button class="settings-btn" id="settingsBtn" onclick="toggleSettingsPopup(event)"><svg viewBox="0 0 14 16" fill="currentColor"><path d="M14 8.77v-1.6l-1.94-.64-.45-1.09.88-1.84-1.13-1.13-1.81.91-1.09-.45-.69-1.92h-1.6l-.63 1.94-1.11.45-1.84-.88-1.13 1.13.91 1.81-.45 1.09L0 7.23v1.59l1.94.64.45 1.09-.88 1.84 1.13 1.13 1.81-.91 1.09.45.69 1.92h1.59l.63-1.94 1.11-.45 1.84.88 1.13-1.13-.92-1.81.47-1.09L14 8.75v.02zM7 11c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"/></svg></button>
          <div class="settings-popup" id="settingsPopup">
          <div class="settings-section">
            <div class="settings-label">Playback Speed</div>
            <div class="settings-options">
              <button class="settings-option selected" data-speed="1" onclick="setPlaybackSpeed(1)">1x</button>
              <button class="settings-option" data-speed="0.5" onclick="setPlaybackSpeed(0.5)">0.5x</button>
              <button class="settings-option" data-speed="0.1" onclick="setPlaybackSpeed(0.1)">0.1x</button>
            </div>
          </div>
          <div class="settings-section">
            <div class="settings-toggle-row">
              <span class="settings-toggle-label">Loop Video</span>
              <div class="toggle-switch" id="loopToggle" onclick="toggleLoopVideo()"></div>
            </div>
          </div>
        </div>
        </span>
      </div>`;

      // Right side of header - timeline ruler (need to build it now before the scroll area)
      const specDuration = specData.workArea.duration;
      if (!viewDuration) {
        viewDuration = Math.round(specDuration / 100) * 100;
      }
      const currentViewDuration = viewDuration;
      const timeIntervals = getNiceTimeIntervals(currentViewDuration);
      const interval = timeIntervals.interval;
      const ticks = [];
      for (let time = 0; time <= currentViewDuration; time += interval) {
        ticks.push(time);
      }

      html += `<div class="timeline-ruler">`;
      const inputWidth = String(specDuration).length;
      html += `<div class="zoom-controls edit-only">
        <span class="zoom-duration">Timeline duration: <input type="text" class="zoom-duration-input" style="width: ${inputWidth}ch" value="${specDuration}" onchange="setTimelineDuration(this.value)" oninput="this.style.width = this.value.length + 'ch'" onkeydown="if(event.key==='Enter'){this.blur()}" onfocus="this.closest('.zoom-controls').classList.add('input-focused')" onblur="this.closest('.zoom-controls').classList.remove('input-focused')" />ms</span>
        <button class="zoom-btn" onclick="zoomOut()"></button>
        <button class="zoom-btn" onclick="zoomIn()">+</button>
      </div>`;
      html += `<div style="position: absolute; top: 0; left: 0; right: 0; height: 100%;">`;
      ticks.forEach((time, index) => {
        if (time >= currentViewDuration) return;
        const position = (time / currentViewDuration) * 100;
        html += `<div class="timeline-tick" style="position: absolute; left: ${position}%; height: 100%; transform: translateX(-50%);">${Math.round(time)}ms</div>`;
      });
      html += `</div></div>`; // timeline-ruler

      html += `</div>`; // timeline-header-row

      // ===== SCROLL AREA =====
      html += `<div class="timeline-container">`;

      // Left column - labels (no playhead-time, it's in header now)
      html += `<div class="timeline-labels-column">`;

      // Build map of children by parent ID for nesting (using unique IDs to avoid name collisions)
      const childrenByParent = {};
      specData.layers.forEach((layer, index) => {
        if (layer.parenting && layer.parenting.parentId) {
          const parentId = layer.parenting.parentId;
          if (!childrenByParent[parentId]) {
            childrenByParent[parentId] = [];
          }
          childrenByParent[parentId].push({ layer, index });
        }
      });

      // Helper function to get global animation index for a layer's animation
      // This matches the order used by showAnimationDetails (layer array order)
      function getGlobalAnimIndex(layerIdx, animIdxInLayer) {
        let idx = 0;
        for (let i = 0; i < layerIdx; i++) {
          idx += specData.layers[i].animations.length;
        }
        return idx + animIdxInLayer;
      }

      let isFirstVisibleLayerTimeline = true;
      specData.layers.forEach((layer, layerIndex) => {
        // Skip layers that have parenting - they'll be rendered under their parent
        // Don't count animations here - they'll be counted when rendering under parent
        if (layer.parenting) {
          return;
        }

        // Check if this layer has children
        const children = childrenByParent[layer.id] || [];
        const hasChildren = children.length > 0;

        // Layer header label (add divider class if not first visible layer)
        const dividerClass = isFirstVisibleLayerTimeline ? '' : ' has-divider';
        const showSectionDividerBtn = !isFirstVisibleLayerTimeline;
        isFirstVisibleLayerTimeline = false;
        html += `<div class="timeline-label layer-header${dividerClass}"
                      draggable="${isEditMode}"
                      data-drag-type="layer"
                      data-layer-index="${layerIndex}"
                      data-is-section-divider="${showSectionDividerBtn ? 'true' : 'false'}">
          <span class="timeline-label-text">${layer.layerName}</span>
          <button class="timeline-label-add-btn edit-only" draggable="false">+</button>
          ${showSectionDividerBtn ? '<button class="section-divider-add-btn edit-only" draggable="false">+</button>' : ''}
        </div>`;

        // Animation labels for this parent layer
        const childLineClass = hasChildren ? ' has-child-line' : '';
        layer.animations.forEach((anim, animIndexInLayer) => {
          // Use layer-array-order index (matches showAnimationDetails lookup)
          const globalAnimIndex = getGlobalAnimIndex(layerIndex, animIndexInLayer);
          html += `<div class="timeline-label indented${childLineClass}"
                        draggable="${isEditMode}"
                        data-drag-type="animation"
                        data-anim-index="${globalAnimIndex}"
                        data-layer-index="${layerIndex}"
                        data-anim-in-layer="${animIndexInLayer}">
            <span class="timeline-label-text">${anim.property}</span>
            <button class="param-action-btn edit-only" draggable="false"></button>
            <button class="timeline-label-add-btn edit-only" draggable="false">+</button>
          </div>`;
        });

        // Render children immediately after parent's animations
        children.forEach((childData, childIdx) => {
          const childLayer = childData.layer;
          const childLayerIndex = childData.index;
          const isFirstChild = childIdx === 0;
          const isLastChild = childIdx === children.length - 1;
          const siblingClass = isLastChild ? '' : ' has-siblings';
          const firstChildClass = isFirstChild ? ' first-child-layer' : '';
          const childContinueClass = isLastChild ? '' : ' child-continues';

          // Child layer header (with tree connector)
          html += `<div class="timeline-label child-layer-header${siblingClass}${firstChildClass}"
                        data-layer-index="${childLayerIndex}"
                        data-row-type="child-layer"
                        data-drag-type="child-layer"
                        data-parent-layer="${layerIndex}"
                        data-parent-name="${layer.layerName}"
                        draggable="${isEditMode}">
            <span class="timeline-label-text">${childLayer.layerName}</span>
            <button class="param-action-btn edit-only" draggable="false"></button>
            <button class="timeline-label-add-btn edit-only" draggable="false">+</button>
          </div>`;

          // Child's own animations (if any) - extra indented under child header
          childLayer.animations.forEach((anim, animIndexInLayer) => {
            // Use layer-array-order index (matches showAnimationDetails lookup)
            const childAnimGlobalIndex = getGlobalAnimIndex(childLayerIndex, animIndexInLayer);
            html += `<div class="timeline-label indented child-anim${childContinueClass}"
                          draggable="${isEditMode}"
                          data-drag-type="animation"
                          data-anim-index="${childAnimGlobalIndex}"
                          data-layer-index="${childLayerIndex}"
                          data-anim-in-layer="${animIndexInLayer}">
              <span class="timeline-label-text">${anim.property}</span>
              <button class="param-action-btn edit-only" draggable="false"></button>
              <button class="timeline-label-add-btn edit-only" draggable="false">+</button>
            </div>`;
          });
        });
      });

      // Bottom section divider for adding new sections at the end
      html += `<div class="timeline-bottom-divider">
        <button class="section-divider-add-btn edit-only" draggable="false">+</button>
      </div>`;

      html += `</div>`; // timeline-labels-column

      // Right column - timeline content (ruler is now in header)
      html += `<div class="timeline-content-column">`;

      // Timeline grid with bars
      html += `<div style="position: relative; padding-right: 80px;">`;
      html += `<div class="timeline-grid-lines" style="display: block; position: absolute; top: 0; left: 0; right: 0; height: 100%; pointer-events: none; z-index: 0;">`;

      // Main grid lines (stop at bottom divider)
      ticks.forEach(time => {
        if (time >= currentViewDuration) return;
        const position = (time / currentViewDuration) * 100;
        html += `<div style="position: absolute; left: ${position}%; top: 0; bottom: 15px; width: 1px; background: #2a2a2a;"></div>`;
      });

      html += `</div>`;

      // Helper function to render a single animation bar track
      function renderAnimationBarTrack(anim, layerIndex, globalAnimIndex, layerName) {
        let startPercent, widthPercent, description, springClass;

        // Note: isFitToShape info is displayed in the child layer header row,
        // so animation bars always use their own timing regardless of fitToShape
        startPercent = (anim.timing.delay / currentViewDuration) * 100;

        // Determine styling based on duration value
        const durationIsNumeric = typeof anim.timing.duration === 'number' && !isNaN(anim.timing.duration);
        const durationIsString = typeof anim.timing.duration === 'string';

        // Check if user has explicitly set duration, or if it's an imported spring
        const userSetDuration = anim.durationUserSet === true;
        const isImportedSpring = !userSetDuration && anim.easing.type === 'spring' && durationIsNumeric;

        if (durationIsString) {
          // Duration is "-" - spring style
          let springDuration = anim.calculatedSpringDuration;
          if (!springDuration && anim.customEasing) {
            const params = parseSpringParams(anim.customEasing);
            if (params) {
              springDuration = calculateSpringDuration(params.stiffness, params.damping, params.mass);
            } else {
              const presetParams = springPresetParams[anim.customEasing];
              if (presetParams) {
                springDuration = calculateSpringDuration(presetParams.stiffness, presetParams.damping, presetParams.mass);
              }
            }
          }
          widthPercent = springDuration ? (springDuration * 2 / currentViewDuration) * 100 : 40;
          springClass = ' bar-spring';
        } else if (isImportedSpring) {
          let calculatedDuration = null;
          const spring = anim.easing.spring;
          if (spring) {
            if (spring.preset && springPresetParams[spring.preset]) {
              const params = springPresetParams[spring.preset];
              calculatedDuration = calculateSpringDuration(params.stiffness, params.damping, params.mass);
            } else if (spring.custom) {
              calculatedDuration = calculateSpringDuration(spring.custom.stiffness, spring.custom.damping, spring.custom.mass || 1);
            }
          }
          widthPercent = calculatedDuration ? (calculatedDuration * 2 / currentViewDuration) * 100 : (anim.timing.duration * 2 / currentViewDuration) * 100;
          springClass = ' bar-spring';
        } else if (durationIsNumeric) {
          widthPercent = (anim.timing.duration / currentViewDuration) * 100;
          springClass = '';
        } else {
          widthPercent = 40;
          springClass = ' bar-spring';
        }

        description = getAnimationDescription(anim.property, anim.values, null, anim.description, layerName);

        // Cap width so bars don't extend past the edge
        const maxWidth = 100 - startPercent;
        widthPercent = Math.min(widthPercent, maxWidth);

        const colorClass = getPropertyColorClass(anim.property);
        const currentVideoId = getCurrentVideoId();
        const animCustomColor = getAnimationColorForVideo(anim, currentVideoId);
        let customStyle = `left: ${startPercent}%; width: ${widthPercent}%;`;
        if (animCustomColor) {
          if (springClass) {
            const rgb = animCustomColor.match(/\w\w/g).map(x => parseInt(x, 16));
            customStyle += ` background: linear-gradient(90deg, ${animCustomColor} 0%, ${animCustomColor} 50%, rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0) 100%);`;
          } else {
            customStyle += ` background: ${animCustomColor};`;
          }
        }

        // Determine if this is a spring
        const durationIsNumericFinal = typeof anim.timing.duration === 'number' && !isNaN(anim.timing.duration);
        const durationIsStringFinal = typeof anim.timing.duration === 'string';
        const userSetDurationFinal = anim.durationUserSet === true;
        const isImportedSpringFinal = !userSetDurationFinal && anim.easing.type === 'spring' && durationIsNumericFinal;
        const isSpring = durationIsStringFinal || isImportedSpringFinal;
        const isFitToShape = anim.isFitToShape || anim.fitToShape;

        return `<div class="timeline-track">
          <div class="timeline-bar ${colorClass}${springClass}"
               style="${customStyle}"
               data-anim-index="${globalAnimIndex}"
               data-is-spring="${isSpring}"
               data-is-fit-to-shape="${!!isFitToShape}">
            <span class="timeline-bar-text edit-only" contenteditable="false" data-anim-index="${globalAnimIndex}">${description}</span>
            <span class="timeline-bar-text export-only">${description}</span>
            <div class="timeline-bar-resize-handle left edit-only" data-handle="left"></div>
            ${!isSpring ? '<div class="timeline-bar-resize-handle right edit-only" data-handle="right"></div>' : ''}
          </div>
        </div>`;
      }

      // Timeline tracks
      let isFirstVisibleLayerTimelineRight = true;
      specData.layers.forEach((layer, layerIndex) => {
        // Skip layers that have parenting - they'll be rendered under their parent
        // Don't count animations here - they'll be counted when rendering under parent
        if (layer.parenting) {
          return;
        }

        // Check if this layer has children
        const children = childrenByParent[layer.id] || [];

        // Empty track for layer header (add divider class if not first visible layer)
        const dividerClass = isFirstVisibleLayerTimelineRight ? '' : ' has-divider';
        isFirstVisibleLayerTimelineRight = false;
        html += `<div class="timeline-track layer-header${dividerClass}"></div>`;

        // Animation tracks for this parent layer
        layer.animations.forEach((anim, animIndexInLayer) => {
          // Use layer-array-order index (matches showAnimationDetails lookup)
          const globalAnimIndex = getGlobalAnimIndex(layerIndex, animIndexInLayer);
          html += renderAnimationBarTrack(anim, layerIndex, globalAnimIndex, layer.layerName);
        });

        // Render children immediately after parent's animations
        children.forEach((childData, childIdx) => {
          const childLayer = childData.layer;
          const childLayerIndex = childData.index;
          const parentName = layer.layerName;
          const attachedDescription = childLayer.parentingDescription || `Attached to ${parentName}`;
          const attachedColor = childLayer.parentingColor || '#595959';

          // Calculate start position based on first animation's delay (or 0 if no animations)
          // Calculate end position based on last animation's end time (capped to visible area)
          let attachedStartPercent = 0;
          let attachedEndPercent = 100;
          if (childLayer.animations.length > 0) {
            const firstDelay = Math.min(...childLayer.animations.map(a => a.timing?.delay || 0));
            attachedStartPercent = (firstDelay / currentViewDuration) * 100;

            const lastEndTime = Math.max(...childLayer.animations.map(a => {
              const delay = a.timing?.delay || 0;
              const duration = a.timing?.duration || 0;
              return delay + duration;
            }));
            // Cap to visible area so fade is visible
            attachedEndPercent = Math.min((lastEndTime / currentViewDuration) * 100, 100);
          }
          const attachedWidthPercent = attachedEndPercent - attachedStartPercent;

          const isFirstChildTrack = childIdx === 0;
          const isLastChildTrack = childIdx === children.length - 1;
          const firstChildTrackClass = isFirstChildTrack ? ' first-child-layer' : '';
          const siblingTrackClass = isLastChildTrack ? '' : ' has-siblings';

          // Child layer header track with attached bar (uses standard timeline-bar structure)
          html += `<div class="timeline-track child-layer-header${firstChildTrackClass}${siblingTrackClass}" data-layer-index="${childLayerIndex}" data-drag-type="child-layer" data-parent-layer="${layerIndex}">
            <div class="timeline-bar bar-attached"
                 style="left: ${attachedStartPercent}%; width: ${attachedWidthPercent}%;"
                 data-layer-index="${childLayerIndex}"
                 data-is-attached="true">
              <span class="timeline-bar-text edit-only" contenteditable="false" data-layer-index="${childLayerIndex}">${attachedDescription}</span>
              <span class="timeline-bar-text export-only">${attachedDescription}</span>
            </div>
          </div>`;

          // Child's own animation bars (if any)
          childLayer.animations.forEach((anim, animIdxInLayer) => {
            // Use layer-array-order index (matches showAnimationDetails lookup)
            const childAnimGlobalIndex = getGlobalAnimIndex(childLayerIndex, animIdxInLayer);
            html += renderAnimationBarTrack(anim, childLayerIndex, childAnimGlobalIndex, childLayer.layerName);
          });
        });
      });

      // Bottom divider track to match left column
      html += `<div class="timeline-track timeline-bottom-track" style="border-top: 1px solid #4a4a4a; border-bottom: none; margin-top: 15px; height: 15px;"></div>`;

      html += `<div class="playhead" id="playhead"><div class="playhead-handle" id="playheadTimeDisplay">0ms</div></div>`;
      html += `</div>`; // position relative wrapper
      html += `</div>`; // timeline-content-column
      html += `</div>`; // timeline-container
      html += `</div>`; // timeline-outer-wrapper

      // Detail panel placeholder
      html += `<div id="detailPanel"></div>`;

      content.innerHTML = html;

      // Setup playhead dragging
      setupPlayheadDragging();

      // Setup animation bar clicks and hover effects
      document.querySelectorAll('.timeline-bar').forEach(bar => {
        bar.addEventListener('click', (e) => {
          e.stopPropagation();

          // Handle attached bars differently
          if (bar.dataset.isAttached === 'true') {
            const layerIndex = parseInt(bar.dataset.layerIndex);
            // Remove selected class from all bars and labels
            document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected'));
            document.querySelectorAll('.timeline-label.child-layer-header').forEach(l => l.classList.remove('selected'));
            // Add selected class to clicked bar and corresponding label
            bar.classList.add('selected');
            const label = document.querySelector(`.timeline-label.child-layer-header[data-layer-index="${layerIndex}"]`);
            if (label) label.classList.add('selected');
            showParentedLayerDetails(layerIndex);
            return;
          }

          const animIndex = parseInt(bar.dataset.animIndex);
          // Remove selected class from all bars and labels
          document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
          document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected'));
          document.querySelectorAll('.timeline-label.child-layer-header').forEach(l => l.classList.remove('selected'));
          // Add selected class to clicked bar
          bar.classList.add('selected');
          // Add selected class to corresponding label
          const label = document.querySelector(`.timeline-label.indented[data-anim-index="${animIndex}"]`);
          if (label) label.classList.add('selected');
          showAnimationDetails(animIndex);
        });

        // Highlight corresponding label on hover
        bar.addEventListener('mouseenter', () => {
          // Handle attached bars
          if (bar.dataset.isAttached === 'true') {
            const layerIndex = bar.dataset.layerIndex;
            const label = document.querySelector(`.timeline-label.child-layer-header[data-layer-index="${layerIndex}"]`);
            if (label) label.classList.add('bar-hover');
            return;
          }
          const animIndex = bar.dataset.animIndex;
          const label = document.querySelector(`.timeline-label.indented[data-anim-index="${animIndex}"]`);
          if (label) label.classList.add('bar-hover');
        });

        bar.addEventListener('mouseleave', () => {
          // Handle attached bars
          if (bar.dataset.isAttached === 'true') {
            const layerIndex = bar.dataset.layerIndex;
            const label = document.querySelector(`.timeline-label.child-layer-header[data-layer-index="${layerIndex}"]`);
            if (label) label.classList.remove('bar-hover');
            return;
          }
          const animIndex = bar.dataset.animIndex;
          const label = document.querySelector(`.timeline-label.indented[data-anim-index="${animIndex}"]`);
          if (label) label.classList.remove('bar-hover');
        });
      });

      // Setup left column label clicks to select bar and show info panel
      document.querySelectorAll('.timeline-label.indented, .timeline-label.child-layer-header, .timeline-label.layer-header').forEach(label => {
        label.addEventListener('click', (e) => {
          // Don't interfere with action buttons or text editing
          if (e.target.closest('.param-action-btn, .timeline-label-add-btn, .section-divider-add-btn')) return;
          if (e.target.contentEditable === 'true') return;

          e.stopPropagation();

          // Handle section header (layer-header) clicks
          if (label.classList.contains('layer-header')) {
            const layerIndex = parseInt(label.dataset.layerIndex);
            // Remove selected class from all bars and labels
            document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected'));
            document.querySelectorAll('.timeline-label.child-layer-header').forEach(l => l.classList.remove('selected'));
            document.querySelectorAll('.timeline-label.layer-header').forEach(l => l.classList.remove('selected'));
            // Add selected class to clicked label
            label.classList.add('selected');
            showSectionHeaderDetails(layerIndex);
            return;
          }

          // Handle child layer header clicks
          if (label.classList.contains('child-layer-header')) {
            const layerIndex = parseInt(label.dataset.layerIndex);
            // Remove selected class from all bars and labels
            document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected'));
            document.querySelectorAll('.timeline-label.child-layer-header').forEach(l => l.classList.remove('selected'));
            document.querySelectorAll('.timeline-label.layer-header').forEach(l => l.classList.remove('selected'));
            // Add selected class to clicked label and corresponding bar
            label.classList.add('selected');
            const bar = document.querySelector(`.timeline-bar.bar-attached[data-layer-index="${layerIndex}"]`);
            if (bar) bar.classList.add('selected');
            showParentedLayerDetails(layerIndex);
            return;
          }

          // Handle param row (indented) clicks
          const animIndex = parseInt(label.dataset.animIndex);
          // Remove selected class from all bars and labels
          document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
          document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected'));
          document.querySelectorAll('.timeline-label.child-layer-header').forEach(l => l.classList.remove('selected'));
          document.querySelectorAll('.timeline-label.layer-header').forEach(l => l.classList.remove('selected'));
          // Add selected class to clicked label and corresponding bar
          label.classList.add('selected');
          const bar = document.querySelector(`.timeline-bar[data-anim-index="${animIndex}"]`);
          if (bar) bar.classList.add('selected');
          showAnimationDetails(animIndex);
        });
      });

      // Close info box when clicking on empty timeline area
      const timelineContainer = document.querySelector('.timeline-container');
      if (timelineContainer) {
        timelineContainer.addEventListener('click', (e) => {
          // Check if clicking on empty area (timeline track, grid, or container background)
          // Use closest() to check the element and its parents
          const clickedElement = e.target;

          const isEmptyArea = clickedElement.classList.contains('timeline-track') ||
                              clickedElement.classList.contains('timeline-content-column') ||
                              clickedElement.classList.contains('timeline-container') ||
                              clickedElement.classList.contains('timeline-grid-lines') ||
                              clickedElement.classList.contains('timeline-bottom-track') ||
                              clickedElement.closest('.timeline-track') !== null ||
                              clickedElement.closest('.timeline-bottom-track') !== null ||
                              clickedElement.closest('.timeline-content-column') !== null;

          // Don't close if clicking on interactive elements
          const isInteractive = clickedElement.closest('.timeline-bar') ||
                                clickedElement.closest('.timeline-label') ||
                                clickedElement.closest('button') ||
                                clickedElement.closest('input') ||
                                clickedElement.closest('.playhead');

          if (isEmptyArea && !isInteractive) {
            const detailPanel = document.getElementById('detailPanel');
            if (detailPanel) {
              detailPanel.innerHTML = '';
            }
            selectedAnimation = null;
            selectedSectionHeaderIndex = null;
            selectedParentedLayerIndex = null;
            document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected'));
            document.querySelectorAll('.timeline-label.child-layer-header').forEach(l => l.classList.remove('selected'));
            document.querySelectorAll('.timeline-label.layer-header').forEach(l => l.classList.remove('selected'));
            requestAnimationFrame(() => {
              updatePlayhead();
            });
          }
        });
      }

      // Setup resize handles
      setupResizeHandles();

      // Setup bar dragging (for moving timeline position or reordering)
      setupBarDragging();

      // Setup bar text editing (including attached bars)
      setupBarTextEditing();

      updatePlayhead();

      // Detect text overflow and add fade class
      detectTextOverflow();

      // Setup drag and drop
      setupDragAndDrop();

      // Setup hover zones for add buttons
      setupAddButtonHoverZones();

      // Setup param action button hover handlers
      setupParamActionButtonHoverHandlers();

      // Setup label editing
      setupLabelEditing();

      // Preserve section spacing state after re-render
      const outerWrapper = document.querySelector('.timeline-outer-wrapper');
      if (outerWrapper && needsCompactSpacing) {
        outerWrapper.classList.add('has-scroll');
      }
    }

    // Detect which bars have overflowing text and add fade class
    function detectTextOverflow() {
      const bars = document.querySelectorAll('.timeline-bar');
      bars.forEach(bar => {
        // Select the visible text element based on mode (edit-only or export-only)
        const textElement = isExportMode
          ? bar.querySelector('.timeline-bar-text.export-only')
          : bar.querySelector('.timeline-bar-text.edit-only');
        if (textElement) {
          // Check if text is wider than the container
          const textWidth = textElement.scrollWidth;
          const containerWidth = bar.clientWidth - 16; // Subtract padding (8px * 2)

          if (textWidth > containerWidth) {
            bar.classList.add('has-text-overflow');
          } else {
            bar.classList.remove('has-text-overflow');
          }
        }
      });
    }

    // Setup drag and drop for timeline labels
    let draggedElement = null;
    let draggedType = null;
    let draggedLayerIndex = null;
    let draggedAnimIndex = null;
    let draggedParentLayer = null;

    function setupDragAndDrop() {
      const labels = document.querySelectorAll('.timeline-label');

      labels.forEach(label => {
        // Dragstart - record what's being dragged
        label.addEventListener('dragstart', (e) => {
          draggedElement = label;
          draggedType = label.dataset.dragType;
          draggedLayerIndex = parseInt(label.dataset.layerIndex);
          draggedAnimIndex = label.dataset.animInLayer ? parseInt(label.dataset.animInLayer) : null;
          draggedParentLayer = label.dataset.parentLayer ? parseInt(label.dataset.parentLayer) : null;

          label.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/html', label.innerHTML);

          // Hide all add buttons during drag
          document.querySelectorAll('.timeline-label-add-btn, .section-divider-add-btn').forEach(btn => {
            btn.classList.remove('visible');
          });
        });

        // Dragend - cleanup
        label.addEventListener('dragend', (e) => {
          label.classList.remove('dragging');
          // Remove all drop indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });
          const bottomDivider = document.querySelector('.timeline-bottom-divider');
          const bottomTrack = document.querySelector('.timeline-bottom-track');
          if (bottomDivider) bottomDivider.classList.remove('drag-over-top');
          if (bottomTrack) bottomTrack.classList.remove('drag-over-top');
          draggedElement = null;
          draggedType = null;
          draggedLayerIndex = null;
          draggedAnimIndex = null;
          draggedParentLayer = null;
        });

        // Dragover - show drop indicator
        label.addEventListener('dragover', (e) => {
          if (!draggedElement || draggedElement === label) return;

          const targetType = label.dataset.dragType;
          const targetLayerIndex = parseInt(label.dataset.layerIndex);

          // Check if this drop is valid
          let isValidDrop = false;
          let isDropOnLayerHeader = false;
          let isChildLayerDrop = false;
          let isParentingDrop = false;  // Layer being dropped into another section to become child
          let isUnparentingDrop = false;  // Child being dropped on divider to become standalone
          const targetParentLayer = label.dataset.parentLayer ? parseInt(label.dataset.parentLayer) : null;

          if (draggedType === 'animation' && targetType === 'animation') {
            // Animation can be dropped in any layer
            isValidDrop = true;
          } else if (draggedType === 'animation' && targetType === 'layer') {
            // Allow dropping animations on layer headers (for empty sections or adding to top)
            isValidDrop = true;
            isDropOnLayerHeader = true;
          } else if (draggedType === 'layer' && targetType === 'layer') {
            isValidDrop = true;
          } else if (draggedType === 'layer' && (targetType === 'animation' || targetType === 'child-layer')) {
            // Layer dropped on animation or child-layer row = parenting
            // Only allow if dragged layer is not a parent itself
            if (!layerHasChildren(draggedLayerIndex)) {
              // Find which parent section this target belongs to
              let targetParentIndex = targetLayerIndex;
              if (targetType === 'child-layer') {
                targetParentIndex = parseInt(label.dataset.parentLayer);
              } else if (targetType === 'animation') {
                // If target animation belongs to a child layer, resolve to grandparent
                const targetLayer = specData.layers[targetLayerIndex];
                if (targetLayer && targetLayer.parenting && targetLayer.parenting.parentId) {
                  const grandparentIndex = specData.layers.findIndex(l => l.id === targetLayer.parenting.parentId);
                  if (grandparentIndex !== -1) {
                    targetParentIndex = grandparentIndex;
                  }
                }
              }
              // Can't parent to self or to a child layer
              const targetParent = specData.layers[targetParentIndex];
              if (targetParentIndex !== draggedLayerIndex && !targetParent.parenting) {
                isValidDrop = true;
                isParentingDrop = true;
              }
            }
          } else if (draggedType === 'child-layer' && targetType === 'child-layer') {
            // Child layers can only be reordered within same parent
            if (draggedParentLayer === targetParentLayer && draggedLayerIndex !== targetLayerIndex) {
              isValidDrop = true;
              isChildLayerDrop = true;
            }
          } else if (draggedType === 'child-layer' && targetType === 'layer') {
            // Child dropped on layer header = un-parenting
            isValidDrop = true;
            isUnparentingDrop = true;
          }

          if (!isValidDrop) return;

          e.preventDefault();

          // Calculate if this drop would actually change the position
          const rect = label.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          let dropPosition = e.clientY < midpoint ? 'before' : 'after';
          let wouldChangePosition = false;

          if (isDropOnLayerHeader) {
            // Dropping animation on layer header - always valid unless it's already first in that layer
            if (draggedLayerIndex !== targetLayerIndex) {
              // Moving to a different layer - always valid
              wouldChangePosition = true;
            } else {
              // Same layer - only valid if not already first
              wouldChangePosition = draggedAnimIndex !== 0;
            }
          } else if (isParentingDrop) {
            // Parenting always changes state (layer becomes child)
            wouldChangePosition = true;
          } else if (isUnparentingDrop) {
            // Un-parenting: allow drop anywhere on a layer header
            wouldChangePosition = true;
          } else if (draggedType === 'layer' && targetType === 'layer') {
            // Only very close to the top divider line is valid for layer drops (within 10px)
            const distanceFromTop = e.clientY - rect.top;
            if (distanceFromTop <= 10) {
              let targetIndex = targetLayerIndex;
              if (draggedLayerIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedLayerIndex !== targetIndex;
            }
          } else if (draggedType === 'animation' && targetType === 'animation') {
            // Check if animation drop would change position
            if (draggedLayerIndex !== targetLayerIndex) {
              // Moving to a different layer - always a valid change
              wouldChangePosition = true;
            } else {
              // Moving within same layer - check if position changes
              const targetAnimIndex = parseInt(label.dataset.animInLayer);
              let targetIndex = targetAnimIndex;
              if (dropPosition === 'after') targetIndex++;
              if (draggedAnimIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedAnimIndex !== targetIndex;
            }
          } else if (isChildLayerDrop) {
            // Child layer reordering - drop zone is entire header (drop before) or bottom 10px for last child
            const distanceFromBottom = rect.bottom - e.clientY;
            const isLastChild = !label.classList.contains('has-siblings');
            const targetLayer = specData.layers[targetLayerIndex];
            const hasNoAnimations = targetLayer.animations.length === 0;

            if (isLastChild && hasNoAnimations && distanceFromBottom <= 10) {
              // Last child with no animations - drop after
              let targetIndex = targetLayerIndex + 1;
              if (draggedLayerIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedLayerIndex !== targetIndex;
            } else {
              // Drop before target - allow from entire header area
              let targetIndex = targetLayerIndex;
              if (draggedLayerIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedLayerIndex !== targetIndex;
            }
          }

          // Only show indicators if the drop would actually change the position
          if (!wouldChangePosition) return;

          // Clear previous indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });
          const bottomDivider = document.querySelector('.timeline-bottom-divider');
          const bottomTrack = document.querySelector('.timeline-bottom-track');
          if (bottomDivider) bottomDivider.classList.remove('drag-over-top');
          if (bottomTrack) bottomTrack.classList.remove('drag-over-top');

          // For animations dropping on layer headers: show bottom indicator
          if (isDropOnLayerHeader) {
            // Find corresponding track and add indicator to both
            const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
            const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
            const labelIndex = allLabels.indexOf(label);

            label.classList.add('drag-over-bottom');
            if (labelIndex >= 0 && allTracks[labelIndex]) {
              allTracks[labelIndex].classList.add('drag-over-bottom');
            }
          }
          // For parenting drops: show indicator on target row
          else if (isParentingDrop) {
            const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
            const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
            const labelIndex = allLabels.indexOf(label);

            label.classList.add('drag-over-bottom');
            if (labelIndex >= 0 && allTracks[labelIndex]) {
              allTracks[labelIndex].classList.add('drag-over-bottom');
            }
          }
          // For un-parenting drops: show indicator at top of layer header
          else if (isUnparentingDrop) {
            const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
            const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
            const labelIndex = allLabels.indexOf(label);

            label.classList.add('drag-over-top');
            if (labelIndex >= 0 && allTracks[labelIndex]) {
              allTracks[labelIndex].classList.add('drag-over-top');
            }
          }
          // For layers: section headers only respond very close to the divider line at the top
          else if (draggedType === 'layer' && targetType === 'layer') {
            // Only show indicator when hovering very close to the divider line (within 10px of top)
            const rect = label.getBoundingClientRect();
            const distanceFromTop = e.clientY - rect.top;
            if (distanceFromTop <= 10) {
              // Find all labels and tracks
              const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
              const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
              const labelIndex = allLabels.indexOf(label);

              // Show indicator on both label and corresponding track
              label.classList.add('drag-over-top');
              if (labelIndex >= 0 && allTracks[labelIndex]) {
                allTracks[labelIndex].classList.add('drag-over-top');
              }
            }
          }
          // For child-layer drops: indicator at top (in gap area) or bottom for last child
          else if (isChildLayerDrop) {
            const distanceFromBottom = rect.bottom - e.clientY;
            const isLastChild = !label.classList.contains('has-siblings');
            const targetLayer = specData.layers[targetLayerIndex];
            const hasNoAnimations = targetLayer.animations.length === 0;

            const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
            const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
            const labelIndex = allLabels.indexOf(label);

            if (isLastChild && hasNoAnimations && distanceFromBottom <= 10) {
              // Show bottom indicator for last child with no animations
              label.classList.add('drag-over-bottom');
              if (labelIndex >= 0 && allTracks[labelIndex]) {
                allTracks[labelIndex].classList.add('drag-over-bottom');
              }
            } else {
              // Top indicator - shows in the gap above this child
              label.classList.add('drag-over-top');
              if (labelIndex >= 0 && allTracks[labelIndex]) {
                allTracks[labelIndex].classList.add('drag-over-top');
              }
            }
          } else {
            // For animations, show both top and bottom indicators normally
            const dropPositionDisplay = e.clientY < midpoint ? 'top' : 'bottom';

            // Find corresponding track and add indicator to both
            const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
            const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
            const labelIndex = allLabels.indexOf(label);

            if (dropPositionDisplay === 'top') {
              label.classList.add('drag-over-top');
              if (labelIndex >= 0 && allTracks[labelIndex]) {
                allTracks[labelIndex].classList.add('drag-over-top');
              }
            } else {
              label.classList.add('drag-over-bottom');
              if (labelIndex >= 0 && allTracks[labelIndex]) {
                allTracks[labelIndex].classList.add('drag-over-bottom');
              }
            }
          }

          e.dataTransfer.dropEffect = 'move';
        });

        // Drop - perform the move
        label.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();

          if (!draggedElement || draggedElement === label) return;

          const targetType = label.dataset.dragType;
          const targetLayerIndex = parseInt(label.dataset.layerIndex);
          const targetAnimIndex = label.dataset.animInLayer ? parseInt(label.dataset.animInLayer) : null;

          // Calculate drop position
          const rect = label.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          let dropPosition = e.clientY < midpoint ? 'before' : 'after';

          // For layer drops: only allow drops in top half (before)
          if (draggedType === 'layer' && targetType === 'layer') {
            if (dropPosition === 'after') {
              // Don't allow drops on bottom half of any section header
              return;
            }
            // Moving a layer
            performLayerMove(draggedLayerIndex, targetLayerIndex, dropPosition);
          }
          // For layer drops on animation/child-layer rows: convert to child (parenting)
          else if (draggedType === 'layer' && (targetType === 'animation' || targetType === 'child-layer')) {
            // Find the parent section for this target
            let targetParentIndex = targetLayerIndex;
            if (targetType === 'child-layer') {
              targetParentIndex = parseInt(label.dataset.parentLayer);
            } else if (targetType === 'animation') {
              // If target animation belongs to a child layer, find its actual parent
              const targetLayer = specData.layers[targetLayerIndex];
              if (targetLayer && targetLayer.parenting && targetLayer.parenting.parentId) {
                // Target is a child layer's animation - find the grandparent
                const grandparentIndex = specData.layers.findIndex(l => l.id === targetLayer.parenting.parentId);
                if (grandparentIndex !== -1) {
                  targetParentIndex = grandparentIndex;
                }
              }
            }
            // Only parent if dragged layer is not already a parent AND target parent is not itself a child
            const targetParent = specData.layers[targetParentIndex];
            if (!layerHasChildren(draggedLayerIndex) && targetParent && !targetParent.parenting) {
              convertLayerToChild(draggedLayerIndex, targetParentIndex);
            }
          }
          // For child-layer drops on layer headers: convert to standalone (un-parenting)
          else if (draggedType === 'child-layer' && targetType === 'layer') {
            convertChildToStandalone(draggedLayerIndex, targetLayerIndex, 'before');
          }
          // For dropping animations on layer headers (empty sections or add to top)
          else if (draggedType === 'animation' && targetType === 'layer') {
            saveSnapshot();
            // Save scroll position before re-render
            const timelineOuter = document.querySelector('.timeline-outer-wrapper');
            const scrollTop = timelineOuter ? timelineOuter.scrollTop : 0;

            const sourceLayer = specData.layers[draggedLayerIndex];
            const targetLayer = specData.layers[targetLayerIndex];
            const anim = sourceLayer.animations.splice(draggedAnimIndex, 1)[0];

            // Insert at the beginning of the target layer
            targetLayer.animations.splice(0, 0, anim);
            renderTimeline();

            // Restore scroll position after re-render
            requestAnimationFrame(() => {
              const newTimelineOuter = document.querySelector('.timeline-outer-wrapper');
              if (newTimelineOuter) {
                newTimelineOuter.scrollTop = scrollTop;
              }
            });
          }
          else if (draggedType === 'animation' && targetType === 'animation') {
            // Moving an animation (within same layer or across layers)
            if (draggedLayerIndex === targetLayerIndex) {
              // Moving within the same layer
              performAnimationMove(draggedLayerIndex, draggedAnimIndex, targetAnimIndex, dropPosition);
            } else {
              // Moving to a different layer
              saveSnapshot();
              // Save scroll position before re-render
              const timelineOuter = document.querySelector('.timeline-outer-wrapper');
              const scrollTop = timelineOuter ? timelineOuter.scrollTop : 0;

              const sourceLayer = specData.layers[draggedLayerIndex];
              const targetLayer = specData.layers[targetLayerIndex];
              const anim = sourceLayer.animations.splice(draggedAnimIndex, 1)[0];

              let targetIndex = targetAnimIndex;
              if (dropPosition === 'after') targetIndex++;

              targetLayer.animations.splice(targetIndex, 0, anim);
              renderTimeline();

              // Restore scroll position after re-render
              requestAnimationFrame(() => {
                const newTimelineOuter = document.querySelector('.timeline-outer-wrapper');
                if (newTimelineOuter) {
                  newTimelineOuter.scrollTop = scrollTop;
                }
              });
            }
          }
          // For child-layer drops on child headers
          else if (draggedType === 'child-layer' && targetType === 'child-layer') {
            const targetParentLayer = label.dataset.parentLayer ? parseInt(label.dataset.parentLayer) : null;
            if (draggedParentLayer === targetParentLayer) {
              // Determine if dropping before or after (for last child with no animations)
              const rect = label.getBoundingClientRect();
              const distanceFromBottom = rect.bottom - e.clientY;
              const isLastChild = !label.classList.contains('has-siblings');
              const targetLayer = specData.layers[targetLayerIndex];
              const hasNoAnimations = targetLayer.animations.length === 0;

              const childDropPosition = (isLastChild && hasNoAnimations && distanceFromBottom <= 10) ? 'after' : 'before';
              performChildLayerMove(draggedLayerIndex, targetLayerIndex, childDropPosition);
            }
          }
          // For child-layer drops on child-animation rows (bottom of last anim = drop after that child)
          else if (draggedType === 'child-layer' && label.classList.contains('child-anim')) {
            const targetAnimIndexInLayer = parseInt(label.dataset.animInLayer);
            const targetLayer = specData.layers[targetLayerIndex];

            // Verify same parent and it's the last animation
            if (targetLayer.parenting && targetLayer.parenting.parentId) {
              const targetParentId = targetLayer.parenting.parentId;
              const draggedLayer = specData.layers[draggedLayerIndex];
              if (draggedLayer.parenting && draggedLayer.parenting.parentId === targetParentId) {
                const isLastAnim = targetAnimIndexInLayer === targetLayer.animations.length - 1;
                if (isLastAnim) {
                  performChildLayerMove(draggedLayerIndex, targetLayerIndex, 'after');
                }
              }
            }
          }

          // Clear indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });
          const bottomDivider = document.querySelector('.timeline-bottom-divider');
          const bottomTrack = document.querySelector('.timeline-bottom-track');
          if (bottomDivider) bottomDivider.classList.remove('drag-over-top');
          if (bottomTrack) bottomTrack.classList.remove('drag-over-top');
        });
      });

      // Set up drag handlers for child-animation rows (to allow dropping child-layers after their siblings)
      // In timeline view, child animations have class 'child-anim' and use 'data-anim-in-layer' for index
      const childAnimLabels = document.querySelectorAll('.timeline-label.child-anim');
      childAnimLabels.forEach(row => {
        row.addEventListener('dragover', (e) => {
          // Only handle child-layer drags
          if (!draggedElement || draggedType !== 'child-layer') return;

          const targetLayerIndex = parseInt(row.dataset.layerIndex);
          const targetAnimIndex = parseInt(row.dataset.animInLayer); // Use animInLayer for timeline view
          const targetLayer = specData.layers[targetLayerIndex];

          // Check if this animation's layer is a child of the same parent
          if (!targetLayer.parenting || !targetLayer.parenting.parentId) return;
          const targetParentId = targetLayer.parenting.parentId;
          const draggedLayer = specData.layers[draggedLayerIndex];
          if (!draggedLayer.parenting || draggedLayer.parenting.parentId !== targetParentId) return;

          // Only respond to bottom zone of the LAST animation of the child
          const isLastAnim = targetAnimIndex === targetLayer.animations.length - 1;
          if (!isLastAnim) return;

          const rect = row.getBoundingClientRect();
          const distanceFromBottom = rect.bottom - e.clientY;
          if (distanceFromBottom > 10) return;

          // Check if drop would change position
          let targetIndex = targetLayerIndex + 1;
          if (draggedLayerIndex < targetIndex) targetIndex--;
          if (draggedLayerIndex === targetIndex) return;

          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';

          // Clear all indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(el => {
            el.classList.remove('drag-over-top', 'drag-over-bottom');
          });

          // Show bottom indicator on both label and track
          row.classList.add('drag-over-bottom');
          const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
          const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
          const labelIndex = allLabels.indexOf(row);
          if (labelIndex >= 0 && allTracks[labelIndex]) {
            allTracks[labelIndex].classList.add('drag-over-bottom');
          }
        });

        row.addEventListener('drop', (e) => {
          if (!draggedElement || draggedType !== 'child-layer') return;

          const targetLayerIndex = parseInt(row.dataset.layerIndex);
          const targetAnimIndex = parseInt(row.dataset.animInLayer); // Use animInLayer for timeline view
          const targetLayer = specData.layers[targetLayerIndex];

          // Verify same parent
          if (!targetLayer.parenting || !targetLayer.parenting.parentId) return;
          const targetParentId = targetLayer.parenting.parentId;
          const draggedLayer = specData.layers[draggedLayerIndex];
          if (!draggedLayer.parenting || draggedLayer.parenting.parentId !== targetParentId) return;

          // Verify it's the last animation of this child
          const isLastAnim = targetAnimIndex === targetLayer.animations.length - 1;
          if (!isLastAnim) return;

          e.preventDefault();
          performChildLayerMove(draggedLayerIndex, targetLayerIndex, 'after');

          // Clear indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(el => {
            el.classList.remove('drag-over-top', 'drag-over-bottom');
          });
        });

        row.addEventListener('dragleave', () => {
          row.classList.remove('drag-over-bottom');
          const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
          const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
          const labelIndex = allLabels.indexOf(row);
          if (labelIndex >= 0 && allTracks[labelIndex]) {
            allTracks[labelIndex].classList.remove('drag-over-bottom');
          }
        });
      });

      // Set up drag handlers for bottom divider
      const bottomDivider = document.querySelector('.timeline-bottom-divider');
      const bottomTrack = document.querySelector('.timeline-bottom-track');
      if (bottomDivider && bottomTrack) {
        bottomDivider.addEventListener('dragover', (e) => {
          // Allow layer drops (reorder) and child-layer drops (un-parent)
          if (!draggedElement || (draggedType !== 'layer' && draggedType !== 'child-layer')) return;

          // Check if dragged layer is already the last layer (only for regular layers)
          if (draggedType === 'layer') {
            const isLastLayer = draggedLayerIndex === specData.layers.length - 1;
            if (isLastLayer) {
              // Don't show indicator if already at the end
              return;
            }
          }

          e.preventDefault();
          e.stopPropagation();

          // Clear previous indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });

          // Show indicator on both bottom elements
          bottomDivider.classList.add('drag-over-top');
          bottomTrack.classList.add('drag-over-top');
          e.dataTransfer.dropEffect = 'move';
        });

        bottomDivider.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();

          if (!draggedElement || (draggedType !== 'layer' && draggedType !== 'child-layer')) return;

          if (draggedType === 'child-layer') {
            // Un-parent the child layer and move to end
            convertChildToStandalone(draggedLayerIndex, specData.layers.length - 1, 'after');
          } else {
            // Move layer to end
            performLayerMove(draggedLayerIndex, specData.layers.length - 1, 'after');
          }

          // Clear indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });
          bottomDivider.classList.remove('drag-over-top');
          bottomTrack.classList.remove('drag-over-top');
        });

        bottomDivider.addEventListener('dragleave', (e) => {
          bottomDivider.classList.remove('drag-over-top');
          bottomTrack.classList.remove('drag-over-top');
        });
      }

      // Set up + button handlers
      const addButtons = document.querySelectorAll('.timeline-label-add-btn');
      addButtons.forEach(btn => {
        // Prevent drag when clicking the + button
        btn.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();

          // Get the parent label to find which layer and position
          const label = btn.closest('.timeline-label');
          if (!label) return;

          const layerIndex = parseInt(label.dataset.layerIndex);
          const layer = specData.layers[layerIndex];
          if (!layer) return;

          // Determine insert position
          let insertIndex;
          if (label.classList.contains('layer-header')) {
            // If clicking on header, add to top of layer
            insertIndex = 0;
          } else {
            // If clicking on animation row, add after it
            const animInLayer = parseInt(label.dataset.animInLayer);
            insertIndex = animInLayer + 1;
          }

          saveSnapshot();

          // Create new animation with default values
          const newAnimation = {
            property: "Add parameter",
            description: "Add description",
            timing: {
              delay: 0,
              duration: 300
            },
            easing: {
              type: "-",
              cubicBezier: ""
            },
            values: {
              formatted: {
                startValue: "-",
                endValue: "-"
              }
            }
          };

          // Insert the new animation
          layer.animations.splice(insertIndex, 0, newAnimation);

          // Save scroll position before re-render
          const timelineOuter = document.querySelector('.timeline-outer-wrapper');
          const scrollTop = timelineOuter ? timelineOuter.scrollTop : 0;

          // Re-render timeline
          renderTimeline();

          // Calculate the global animation index for the newly added animation
          let globalAnimIndex = 0;
          for (let i = 0; i < layerIndex; i++) {
            globalAnimIndex += specData.layers[i].animations.length;
          }
          globalAnimIndex += insertIndex;

          // Show the info box for the newly added animation
          setTimeout(() => {
            // Restore scroll position first
            const newTimelineOuter = document.querySelector('.timeline-outer-wrapper');
            if (newTimelineOuter) {
              newTimelineOuter.scrollTop = scrollTop;
            }

            showAnimationDetails(globalAnimIndex);

            // Add selected class to the new bar and label
            const newBar = document.querySelector(`.timeline-bar[data-anim-index="${globalAnimIndex}"]`);
            const newLabel = document.querySelector(`.timeline-label.indented[data-anim-index="${globalAnimIndex}"]`);
            if (newBar) newBar.classList.add('selected');
            if (newLabel) {
              newLabel.classList.add('selected');
              // Scroll the new row into view from current position
              newLabel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            // Update section spacing after layout completes
            requestAnimationFrame(() => {
              requestAnimationFrame(() => updateSectionSpacing(true));
            });
          }, 0);
        });
      });

      // Set up section divider button handlers
      const sectionDividerButtons = document.querySelectorAll('.section-divider-add-btn');
      sectionDividerButtons.forEach(btn => {
        btn.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();

          // Determine insert position
          let insertIndex;
          const parentLabel = btn.closest('.timeline-label');
          const isBottomDivider = btn.closest('.timeline-bottom-divider');

          if (isBottomDivider) {
            // Bottom divider - add to end
            insertIndex = specData.layers.length;
          } else if (parentLabel) {
            // Section header button - insert before this layer
            const layerIndex = parseInt(parentLabel.dataset.layerIndex);
            insertIndex = layerIndex;
          } else {
            return;
          }

          saveSnapshot();

          // Create new layer with one default animation
          const newLayer = {
            id: generateLayerId(),
            layerName: "New section",
            animations: [
              {
                property: "Add parameter",
                description: "Add description",
                timing: {
                  delay: 0,
                  duration: 300
                },
                easing: {
                  type: "-",
                  cubicBezier: ""
                },
                values: {
                  formatted: {
                    startValue: "-",
                    endValue: "-"
                  }
                }
              }
            ]
          };

          // Insert the new layer
          specData.layers.splice(insertIndex, 0, newLayer);

          // Save scroll position before re-render
          const timelineOuter = document.querySelector('.timeline-outer-wrapper');
          const scrollTop = timelineOuter ? timelineOuter.scrollTop : 0;

          // Re-render timeline
          renderTimeline();

          // Calculate the global animation index for the newly added parameter
          let globalAnimIndex = 0;
          for (let i = 0; i < insertIndex; i++) {
            globalAnimIndex += specData.layers[i].animations.length;
          }
          // The new parameter is at index 0 in the new layer

          // Show the info box for the newly added animation
          setTimeout(() => {
            // Restore scroll position first
            const newTimelineOuter = document.querySelector('.timeline-outer-wrapper');
            if (newTimelineOuter) {
              newTimelineOuter.scrollTop = scrollTop;
            }

            showAnimationDetails(globalAnimIndex);

            // Add selected class to the new bar and label
            const newBar = document.querySelector(`.timeline-bar[data-anim-index="${globalAnimIndex}"]`);
            const newLabel = document.querySelector(`.timeline-label.indented[data-anim-index="${globalAnimIndex}"]`);
            if (newBar) newBar.classList.add('selected');
            if (newLabel) {
              newLabel.classList.add('selected');
              // Scroll the new row into view from current position
              newLabel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            // Update section spacing after layout completes
            requestAnimationFrame(() => {
              requestAnimationFrame(() => updateSectionSpacing(true));
            });
          }, 0);
        });
      });
    }

    // Setup hover zones for add buttons
    function setupAddButtonHoverZones() {
      const labelsColumn = document.querySelector('.timeline-labels-column');
      const labels = document.querySelectorAll('.timeline-label');
      const bottomDivider = document.querySelector('.timeline-bottom-divider');

      if (!labelsColumn) return;

      labelsColumn.addEventListener('mousemove', (e) => {
        const columnRect = labelsColumn.getBoundingClientRect();
        const mouseY = e.clientY;
        const outerWrapper = document.querySelector('.timeline-outer-wrapper');
        const isCollapsed = outerWrapper && outerWrapper.classList.contains('has-scroll');

        // Find all buttons and their distances
        let closestButton = null;
        let closestDistance = Infinity;

        // Check each label's divider line
        const labelsArray = Array.from(labels);
        labelsArray.forEach((label, idx) => {
          const btn = label.querySelector('.timeline-label-add-btn');
          const sectionBtn = label.querySelector('.section-divider-add-btn');
          const rect = label.getBoundingClientRect();
          const halfCellHeight = rect.height / 2;

          // Check regular divider line (at bottom of cell)
          if (btn) {
            const dividerY = rect.bottom;
            const distanceFromDivider = Math.abs(mouseY - dividerY);
            if (distanceFromDivider <= halfCellHeight) {
              // In collapsed mode, check if next row is a section header
              // If so, prefer the section button from that header
              if (isCollapsed) {
                const nextLabel = labelsArray[idx + 1];
                if (nextLabel && nextLabel.classList.contains('layer-header') && nextLabel.classList.contains('has-divider')) {
                  const nextSectionBtn = nextLabel.querySelector('.section-divider-add-btn');
                  if (nextSectionBtn && distanceFromDivider < closestDistance) {
                    closestDistance = distanceFromDivider;
                    closestButton = nextSectionBtn;
                    return; // Skip adding param button
                  }
                }
              }
              if (distanceFromDivider < closestDistance) {
                closestDistance = distanceFromDivider;
                closestButton = btn;
              }
            }
          }

          // Check section divider line (at top of cell, for elements with has-divider)
          // Only show in expanded mode (non-collapsed) since collapsed mode uses the row above
          if (sectionBtn && !isCollapsed) {
            const sectionDividerY = rect.top; // Border-top is at element's top edge
            const distanceFromSectionDivider = Math.abs(mouseY - sectionDividerY);
            // Use a larger hover zone for section dividers (about 15px total margin-top / 2)
            if (distanceFromSectionDivider <= 15) {
              if (distanceFromSectionDivider < closestDistance) {
                closestDistance = distanceFromSectionDivider;
                closestButton = sectionBtn;
              }
            }
          }
        });

        // Check bottom divider
        if (bottomDivider) {
          const bottomBtn = bottomDivider.querySelector('.section-divider-add-btn');
          if (bottomBtn) {
            const rect = bottomDivider.getBoundingClientRect();
            const dividerY = rect.top; // Border-top is at element's top edge
            const distanceFromDivider = Math.abs(mouseY - dividerY);
            if (distanceFromDivider <= 15) {
              if (distanceFromDivider < closestDistance) {
                closestDistance = distanceFromDivider;
                closestButton = bottomBtn;
              }
            }
          }
        }

        // Hide all buttons first
        labels.forEach(label => {
          const btn = label.querySelector('.timeline-label-add-btn');
          const sectionBtn = label.querySelector('.section-divider-add-btn');
          if (btn) btn.classList.remove('visible');
          if (sectionBtn) sectionBtn.classList.remove('visible');
        });
        if (bottomDivider) {
          const bottomBtn = bottomDivider.querySelector('.section-divider-add-btn');
          if (bottomBtn) bottomBtn.classList.remove('visible');
        }

        // Show only the closest button
        if (closestButton) {
          closestButton.classList.add('visible');
        }
      });

      labelsColumn.addEventListener('mouseleave', () => {
        // Hide all buttons when mouse leaves the column
        labels.forEach(label => {
          const btn = label.querySelector('.timeline-label-add-btn');
          const sectionBtn = label.querySelector('.section-divider-add-btn');
          if (btn) btn.classList.remove('visible');
          if (sectionBtn) sectionBtn.classList.remove('visible');
        });

        // Hide bottom divider button
        if (bottomDivider) {
          const bottomBtn = bottomDivider.querySelector('.section-divider-add-btn');
          if (bottomBtn) bottomBtn.classList.remove('visible');
        }
      });
    }

    // Setup resize handles for timeline bars
    function setupResizeHandles() {
      const handles = document.querySelectorAll('.timeline-bar-resize-handle');

      handles.forEach(handle => {
        handle.addEventListener('mousedown', (e) => {
          // Disable resize in export mode
          if (isExportMode) return;

          const bar = handle.closest('.timeline-bar');

          e.stopPropagation();
          e.preventDefault();

          const animIndex = parseInt(bar.dataset.animIndex);
          const handleType = handle.dataset.handle; // 'left' or 'right'
          const isSpring = bar.dataset.isSpring === 'true';

          // Find the animation in specData
          let currentAnimIndex = 0;
          let targetLayer = null;
          let targetAnim = null;
          let layerIndex = -1;
          let animInLayerIndex = -1;

          for (let i = 0; i < specData.layers.length; i++) {
            const layer = specData.layers[i];
            for (let j = 0; j < layer.animations.length; j++) {
              if (currentAnimIndex === animIndex) {
                targetLayer = layer;
                targetAnim = layer.animations[j];
                layerIndex = i;
                animInLayerIndex = j;
                break;
              }
              currentAnimIndex++;
            }
            if (targetAnim) break;
          }

          if (!targetAnim) return;

          const startDelay = targetAnim.timing.delay;
          const startDuration = targetAnim.timing.duration;
          const startX = e.clientX;
          const timelineGrid = document.querySelector('.timeline-grid-lines').parentElement;
          const gridRect = timelineGrid.getBoundingClientRect();
          const specDuration = specData.workArea.duration;
          const currentViewDuration = viewDuration || specDuration;

          // Add dragging class to maintain hover state
          bar.classList.add('dragging-resize');

          // Save state before resize changes
          saveSnapshot();

          // Function to snap to 25ms increments
          function snapToIncrement(value) {
            return Math.round(value / 25) * 25;
          }

          function onMouseMove(moveEvent) {
            const deltaX = moveEvent.clientX - startX;
            const deltaTime = (deltaX / gridRect.width) * currentViewDuration;

            let newDelay, newDuration;

            if (handleType === 'left') {
              // Adjust delay (start time)
              newDelay = snapToIncrement(startDelay + deltaTime);
              newDelay = Math.max(0, newDelay); // Can't go below 0

              // Adjust duration to compensate (keep end time the same)
              newDuration = startDelay + startDuration - newDelay;
              newDuration = Math.max(25, newDuration); // Minimum 25ms duration

              // Update animation data
              targetAnim.timing.delay = newDelay;
              targetAnim.timing.duration = newDuration;
            } else {
              // Adjust duration (end time)
              newDelay = targetAnim.timing.delay;
              newDuration = snapToIncrement(startDuration + deltaTime);
              newDuration = Math.max(25, newDuration); // Minimum 25ms duration

              // Update animation data
              targetAnim.timing.duration = newDuration;
            }

            // Update bar position and width directly without full re-render
            const startPercent = (newDelay / currentViewDuration) * 100;
            const widthPercent = (newDuration / currentViewDuration) * 100;
            bar.style.left = `${startPercent}%`;
            bar.style.width = `${widthPercent}%`;

            // Update info box if this animation is selected
            if (selectedAnimation === animIndex) {
              showAnimationDetails(animIndex);
            }
          }

          function onMouseUp() {
            // Remove dragging class
            bar.classList.remove('dragging-resize');

            // Store whether this animation was selected before re-render
            const wasSelected = selectedAnimation === animIndex;

            // Do a full re-render to ensure everything is consistent
            renderTimeline();

            // Restore info box and selected state if it was showing
            if (wasSelected) {
              showAnimationDetails(animIndex);
              // Re-apply selected class after re-render
              const bar = document.querySelector(`.timeline-bar[data-anim-index="${animIndex}"]`);
              const label = document.querySelector(`.timeline-label.indented[data-anim-index="${animIndex}"]`);
              if (bar) bar.classList.add('selected');
              if (label) label.classList.add('selected');
            }

            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          }

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
      });
    }

    // Setup bar dragging for moving timeline position or reordering
    function setupBarDragging() {
      const bars = document.querySelectorAll('.timeline-bar');

      bars.forEach(bar => {
        bar.addEventListener('mousedown', (e) => {
          // Don't allow dragging in read mode
          if (!isEditMode) return;

          // Disable dragging for attached bars (they don't have timing)
          if (bar.dataset.isAttached === 'true') return;

          // Don't interfere with resize handles
          if (e.target.classList.contains('timeline-bar-resize-handle')) return;

          // Don't interfere with text that's currently being edited (focused)
          const textEl = bar.querySelector('.timeline-bar-text.edit-only');
          if (textEl && document.activeElement === textEl) return;

          // Don't start dragging if ANY bar text is currently being edited
          const editingText = document.querySelector('.timeline-bar-text.edit-only[data-editing="true"]');
          if (editingText || isBarTextBeingEdited) return;

          const animIndex = parseInt(bar.dataset.animIndex);
          const startX = e.clientX;
          const startY = e.clientY;
          const threshold = 5; // pixels to move before determining direction
          let dragDirection = null; // 'horizontal', 'vertical', or null
          let isDragging = false;

          // Find the animation in specData
          let currentAnimIndex = 0;
          let targetAnim = null;
          let layerIndex = -1;
          let animInLayerIndex = -1;

          for (let i = 0; i < specData.layers.length; i++) {
            const layer = specData.layers[i];
            for (let j = 0; j < layer.animations.length; j++) {
              if (currentAnimIndex === animIndex) {
                targetAnim = layer.animations[j];
                layerIndex = i;
                animInLayerIndex = j;
                break;
              }
              currentAnimIndex++;
            }
            if (targetAnim) break;
          }

          if (!targetAnim) return;

          const startDelay = targetAnim.timing.delay;
          const timelineGrid = document.querySelector('.timeline-grid-lines').parentElement;
          const gridRect = timelineGrid.getBoundingClientRect();
          const specDuration = specData.workArea.duration;
          const currentViewDuration = viewDuration || specDuration;

          function snapToIncrement(value) {
            return Math.round(value / 25) * 25;
          }

          function onMouseMove(moveEvent) {
            // Check if text is being edited - if so, abort dragging
            const textEl = bar.querySelector('.timeline-bar-text.edit-only');
            if ((textEl && textEl.dataset.editing === 'true') || isBarTextBeingEdited) {
              // Clean up and exit
              document.removeEventListener('mousemove', onMouseMove);
              document.removeEventListener('mouseup', onMouseUp);
              return;
            }

            const deltaX = moveEvent.clientX - startX;
            const deltaY = moveEvent.clientY - startY;

            // Determine drag direction if not yet determined
            if (!dragDirection && (Math.abs(deltaX) > threshold || Math.abs(deltaY) > threshold)) {
              moveEvent.preventDefault(); // Prevent default behavior once we start dragging

              if (Math.abs(deltaX) > Math.abs(deltaY)) {
                dragDirection = 'horizontal';
                saveSnapshot(); // Save state before horizontal drag changes delay
                bar.classList.add('dragging-resize');
              } else {
                dragDirection = 'vertical';
                // Start vertical drag - add visual feedback
                bar.classList.add('dragging-vertical');
                const label = document.querySelector(`.timeline-label.indented[data-anim-index="${animIndex}"]`);
                if (label) {
                  // Programmatically trigger dragstart on the label
                  label.classList.add('dragging');
                  document.querySelectorAll('.timeline-label-add-btn, .section-divider-add-btn').forEach(btn => {
                    btn.classList.remove('visible');
                  });
                }
              }
              isDragging = true;
            }

            if (!isDragging) return;

            if (dragDirection === 'horizontal') {
              // Horizontal drag - move the bar's position in time
              const deltaTime = (deltaX / gridRect.width) * currentViewDuration;
              let newDelay = snapToIncrement(startDelay + deltaTime);
              newDelay = Math.max(0, newDelay);

              // Update animation data
              targetAnim.timing.delay = newDelay;

              // Update bar position directly
              const startPercent = (newDelay / currentViewDuration) * 100;
              bar.style.left = `${startPercent}%`;

              // Update info box if selected
              if (selectedAnimation === animIndex) {
                showAnimationDetails(animIndex);
              }
            } else if (dragDirection === 'vertical') {
              // Vertical drag - show drop indicators
              const animLabels = document.querySelectorAll('.timeline-label.indented');
              const layerHeaders = document.querySelectorAll('.timeline-label.layer-header');
              let closestElement = null;
              let closestDistance = Infinity;
              let isLayerHeader = false;

              // Check animation labels
              animLabels.forEach(label => {
                const rect = label.getBoundingClientRect();
                const distance = Math.abs(rect.top + rect.height / 2 - moveEvent.clientY);
                if (distance < closestDistance) {
                  closestDistance = distance;
                  closestElement = label;
                  isLayerHeader = false;
                }
              });

              // Also check layer headers (for empty sections)
              layerHeaders.forEach(header => {
                const rect = header.getBoundingClientRect();
                const distance = Math.abs(rect.top + rect.height / 2 - moveEvent.clientY);
                if (distance < closestDistance) {
                  closestDistance = distance;
                  closestElement = header;
                  isLayerHeader = true;
                }
              });

              // Remove all drop indicators first
              document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
                l.classList.remove('drag-over-top', 'drag-over-bottom');
              });

              // Show drop indicator on closest element only (extends across full timeline)
              if (closestElement) {
                // Find corresponding track to add indicator to both sides
                const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
                const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
                const labelIndex = allLabels.indexOf(closestElement);

                if (isLayerHeader) {
                  // For layer headers, always show bottom indicator (add to section)
                  const headerLayerIndex = parseInt(closestElement.dataset.layerIndex);
                  if (headerLayerIndex !== layerIndex) {
                    // Only show if dropping into a different section
                    closestElement.classList.add('drag-over-bottom');
                    if (labelIndex >= 0 && allTracks[labelIndex]) {
                      allTracks[labelIndex].classList.add('drag-over-bottom');
                    }
                  }
                } else if (closestElement.dataset.animIndex !== String(animIndex)) {
                  // For animation labels, show top/bottom based on position
                  const rect = closestElement.getBoundingClientRect();
                  const midpoint = rect.top + rect.height / 2;

                  if (moveEvent.clientY < midpoint) {
                    closestElement.classList.add('drag-over-top');
                    if (labelIndex >= 0 && allTracks[labelIndex]) {
                      allTracks[labelIndex].classList.add('drag-over-top');
                    }
                  } else {
                    closestElement.classList.add('drag-over-bottom');
                    if (labelIndex >= 0 && allTracks[labelIndex]) {
                      allTracks[labelIndex].classList.add('drag-over-bottom');
                    }
                  }
                }
              }
            }
          }

          function onMouseUp(upEvent) {
            // If text editing was initiated, abort the drag operation
            if (isBarTextBeingEdited) {
              document.removeEventListener('mousemove', onMouseMove);
              document.removeEventListener('mouseup', onMouseUp);
              return;
            }

            // If we dragged, prevent the click event from firing
            if (isDragging) {
              const preventClick = (e) => {
                e.stopPropagation();
                e.preventDefault();
                bar.removeEventListener('click', preventClick, true);
              };
              bar.addEventListener('click', preventClick, true);
            }

            if (dragDirection === 'horizontal') {
              bar.classList.remove('dragging-resize');

              // Store selection state
              const wasSelected = selectedAnimation === animIndex;

              // Re-render to finalize
              renderTimeline();

              // Restore info box and selected state if needed
              if (wasSelected) {
                showAnimationDetails(animIndex);
                // Re-apply selected class after re-render
                const bar = document.querySelector(`.timeline-bar[data-anim-index="${animIndex}"]`);
                const label = document.querySelector(`.timeline-label.indented[data-anim-index="${animIndex}"]`);
                if (bar) bar.classList.add('selected');
                if (label) label.classList.add('selected');
              }
            } else if (dragDirection === 'vertical') {
              // Complete the drop
              const animLabels = document.querySelectorAll('.timeline-label.indented');
              const layerHeaders = document.querySelectorAll('.timeline-label.layer-header');
              let targetElement = null;
              let dropPosition = null;
              let isLayerHeader = false;

              // Check animation labels
              animLabels.forEach(label => {
                if (label.classList.contains('drag-over-top') || label.classList.contains('drag-over-bottom')) {
                  targetElement = label;
                  dropPosition = label.classList.contains('drag-over-top') ? 'before' : 'after';
                  isLayerHeader = false;
                }
              });

              // Check layer headers
              layerHeaders.forEach(header => {
                if (header.classList.contains('drag-over-bottom')) {
                  targetElement = header;
                  isLayerHeader = true;
                }
              });

              if (targetElement) {
                if (isLayerHeader) {
                  // Dropping on a layer header - add to beginning of that section
                  saveSnapshot();
                  const targetLayerIndex = parseInt(targetElement.dataset.layerIndex);
                  const sourceLayer = specData.layers[layerIndex];
                  const targetLayer = specData.layers[targetLayerIndex];
                  const anim = sourceLayer.animations.splice(animInLayerIndex, 1)[0];

                  // Insert at beginning of target layer
                  targetLayer.animations.splice(0, 0, anim);
                  renderTimeline();
                } else if (targetElement.dataset.animIndex !== String(animIndex)) {
                  // Dropping on an animation label
                  const targetAnimIndex = parseInt(targetElement.dataset.animIndex);
                  const targetLayerIndex = parseInt(targetElement.dataset.layerIndex);
                  const targetAnimInLayerIndex = parseInt(targetElement.dataset.animInLayer);

                  // Perform the move
                  if (layerIndex === targetLayerIndex) {
                    // Moving within the same layer
                    let targetIndex = targetAnimInLayerIndex;
                    if (dropPosition === 'after') targetIndex++;
                    if (animInLayerIndex < targetIndex) targetIndex--;

                    if (animInLayerIndex !== targetIndex) {
                      saveSnapshot();
                      const layer = specData.layers[layerIndex];
                      const anim = layer.animations.splice(animInLayerIndex, 1)[0];
                      layer.animations.splice(targetIndex, 0, anim);
                      renderTimeline();
                    }
                  } else {
                    // Moving to a different layer
                    saveSnapshot();
                    const sourceLayer = specData.layers[layerIndex];
                    const targetLayer = specData.layers[targetLayerIndex];
                    const anim = sourceLayer.animations.splice(animInLayerIndex, 1)[0];

                    let targetIndex = targetAnimInLayerIndex;
                    if (dropPosition === 'after') targetIndex++;

                    targetLayer.animations.splice(targetIndex, 0, anim);
                    renderTimeline();
                  }
                }
              }

              // Cleanup
              bar.classList.remove('dragging-vertical');
              const label = document.querySelector(`.timeline-label.indented[data-anim-index="${animIndex}"]`);
              if (label) label.classList.remove('dragging');

              document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
                l.classList.remove('drag-over-top', 'drag-over-bottom');
              });
            }

            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          }

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
      });
    }

    // Setup bar text editing
    function setupBarTextEditing() {
      const textElements = document.querySelectorAll('.timeline-bar-text.edit-only');

      textElements.forEach(textEl => {
        let isEditing = false;

        // Double-click to enter edit mode
        textEl.addEventListener('dblclick', (e) => {
          if (isEditing) return;

          e.stopPropagation();
          e.preventDefault();
          isBarTextBeingEdited = true;
          enterEditMode(textEl);
        });

        // Enter edit mode function
        function enterEditMode(element) {
          isEditing = true;
          isBarTextBeingEdited = true; // Set global flag
          const originalText = element.textContent.trim();

          // Enable contenteditable on double-click
          element.contentEditable = true;

          // Mark as editing with data attribute so bar dragging can detect it
          element.dataset.editing = 'true';

          // Focus the element
          element.focus();

          // Select all text
          const range = document.createRange();
          range.selectNodeContents(element);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);

          // Block mouse events while editing
          const blockMouseEvents = (e) => {
            e.stopPropagation();
          };
          element.addEventListener('mousedown', blockMouseEvents, true);
          element.addEventListener('mousemove', blockMouseEvents, true);
          element.addEventListener('mouseup', blockMouseEvents, true);

          // Handle Enter and Escape keys
          const handleKeyDown = (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              element.blur();
            } else if (e.key === 'Escape') {
              element.textContent = originalText;
              element.blur();
            }
          };

          // Prevent multi-line paste
          const handlePaste = (e) => {
            e.preventDefault();
            const text = (e.clipboardData || window.clipboardData).getData('text');
            // Replace any line breaks with spaces
            const singleLineText = text.replace(/[\r\n]+/g, ' ');
            document.execCommand('insertText', false, singleLineText);
          };

          // Save changes on blur
          const handleBlur = () => {
            const newText = element.textContent.trim();

            // Disable contenteditable
            element.contentEditable = false;

            // Remove event listeners
            element.removeEventListener('keydown', handleKeyDown);
            element.removeEventListener('paste', handlePaste);
            element.removeEventListener('blur', handleBlur);
            element.removeEventListener('mousedown', blockMouseEvents, true);
            element.removeEventListener('mousemove', blockMouseEvents, true);
            element.removeEventListener('mouseup', blockMouseEvents, true);

            // Clear editing flag
            element.dataset.editing = 'false';
            isEditing = false;

            // Clear global flag on the next mousedown to ensure all mouseup events have been processed
            const clearFlagOnNextMouseDown = () => {
              isBarTextBeingEdited = false;
              document.removeEventListener('mousedown', clearFlagOnNextMouseDown, true);
            };
            document.addEventListener('mousedown', clearFlagOnNextMouseDown, true);

            // Check if this is an attached bar (parenting description)
            const bar = element.closest('.timeline-bar');
            const isAttachedBar = bar && bar.dataset.isAttached === 'true';

            if (isAttachedBar) {
              const layerIndex = parseInt(element.dataset.layerIndex);
              if (newText === '') {
                // Don't allow empty - restore the default
                const layer = specData.layers[layerIndex];
                const parentName = layer?.parenting?.parentName || '';
                element.textContent = layer?.parentingDescription || `Attached to ${parentName}`;
                return;
              }
              // Update parenting description
              saveSnapshot();
              const layer = specData.layers[layerIndex];
              if (layer) {
                layer.parentingDescription = newText;
                setCurrentSpecData(specData);
              }
              return;
            }

            const animIndex = parseInt(element.dataset.animIndex);

            if (newText === '') {
              // Don't allow empty text, restore original
              let currentIndex = 0;
              for (const layer of getCurrentSpecData().layers) {
                for (const anim of layer.animations) {
                  if (currentIndex === animIndex) {
                    element.textContent = anim.description || anim.property;
                    return;
                  }
                  currentIndex++;
                }
              }
              return;
            }

            // Update the animation's customDescription using the helper function
            // This will refresh all views and update the info box
            updateAnimationField(animIndex, 'customDescription', newText);
          };

          element.addEventListener('keydown', handleKeyDown);
          element.addEventListener('paste', handlePaste);
          element.addEventListener('blur', handleBlur);
        }
      });
    }

    // Perform layer move
    function performLayerMove(fromIndex, toIndex, position) {
      // Calculate the actual target index
      let targetIndex = toIndex;
      if (position === 'after') targetIndex++;
      if (fromIndex < targetIndex) targetIndex--;

      if (fromIndex === targetIndex) return;
      saveSnapshot();

      // Save scroll position before re-render
      const timelineOuter = document.querySelector('.timeline-outer-wrapper');
      const scrollTop = timelineOuter ? timelineOuter.scrollTop : 0;

      // Remove from old position
      const layer = specData.layers.splice(fromIndex, 1)[0];

      // Insert at new position
      specData.layers.splice(targetIndex, 0, layer);

      // Re-render based on current view mode
      if (viewMode === 'table') {
        renderTableView();
      } else {
        renderTimeline();
      }

      // Restore scroll position after re-render
      requestAnimationFrame(() => {
        const newTimelineOuter = document.querySelector('.timeline-outer-wrapper');
        if (newTimelineOuter) {
          newTimelineOuter.scrollTop = scrollTop;
        }
      });

      // Maintain selection if needed
      if (selectedAnimation !== null) {
        // Recalculate selected animation index
        setTimeout(() => {
          updatePlayhead();
        }, 0);
      }
    }

    // Perform child layer move (reorder within same parent)
    function performChildLayerMove(fromIndex, toIndex, position) {
      // Calculate the actual target index
      let targetIndex = toIndex;
      if (position === 'after') targetIndex++;
      if (fromIndex < targetIndex) targetIndex--;

      if (fromIndex === targetIndex) return;
      saveSnapshot();

      // Save scroll position before re-render
      const timelineOuter = document.querySelector('.timeline-outer-wrapper');
      const scrollTop = timelineOuter ? timelineOuter.scrollTop : 0;

      // Remove from old position
      const layer = specData.layers.splice(fromIndex, 1)[0];

      // Insert at new position
      specData.layers.splice(targetIndex, 0, layer);

      // Re-render based on current view mode
      if (viewMode === 'table') {
        renderTableView();
      } else {
        renderTimeline();
      }

      // Restore scroll position after re-render
      requestAnimationFrame(() => {
        const newTimelineOuter = document.querySelector('.timeline-outer-wrapper');
        if (newTimelineOuter) {
          newTimelineOuter.scrollTop = scrollTop;
        }
      });
    }

    // Perform animation move within layer
    function performAnimationMove(layerIndex, fromAnimIndex, toAnimIndex, position) {
      // Calculate the actual target index
      let targetIndex = toAnimIndex;
      if (position === 'after') targetIndex++;
      if (fromAnimIndex < targetIndex) targetIndex--;

      if (fromAnimIndex === targetIndex) return;
      saveSnapshot();

      // Save scroll position before re-render
      const timelineOuter = document.querySelector('.timeline-outer-wrapper');
      const scrollTop = timelineOuter ? timelineOuter.scrollTop : 0;

      const layer = specData.layers[layerIndex];

      // Remove from old position
      const anim = layer.animations.splice(fromAnimIndex, 1)[0];

      // Insert at new position
      layer.animations.splice(targetIndex, 0, anim);

      // Re-render based on current view mode
      if (viewMode === 'table') {
        renderTableView();
      } else {
        renderTimeline();
      }

      // Restore scroll position after re-render
      requestAnimationFrame(() => {
        const newTimelineOuter = document.querySelector('.timeline-outer-wrapper');
        if (newTimelineOuter) {
          newTimelineOuter.scrollTop = scrollTop;
        }
      });

      // Maintain selection if needed
      if (selectedAnimation !== null) {
        setTimeout(() => {
          updatePlayhead();
        }, 0);
      }
    }

    // Check if a layer has children (is a parent)
    function layerHasChildren(layerIndex) {
      const layer = specData.layers[layerIndex];
      if (!layer || !layer.id) return false;
      return specData.layers.some(l => l.parenting && l.parenting.parentId === layer.id);
    }

    // Convert a standalone layer to a child of another layer
    function convertLayerToChild(layerIndex, parentLayerIndex) {
      const layer = specData.layers[layerIndex];
      const parentLayer = specData.layers[parentLayerIndex];
      if (!layer || !parentLayer || !parentLayer.id) return;

      saveSnapshot();

      // Set parenting info using parent's unique ID
      layer.parenting = {
        parentId: parentLayer.id,
        parentName: parentLayer.layerName, // Keep for display/export compatibility
        animatingProperties: []
      };

      // Find position: after the last child of the parent, or after parent's last animation row
      // Children are rendered after their parent in the layer array, so find the right spot
      let insertAfterIndex = parentLayerIndex;

      // Find all existing children of this parent and get the last one's index
      specData.layers.forEach((l, idx) => {
        if (l.parenting && l.parenting.parentId === parentLayer.id) {
          if (idx > insertAfterIndex) {
            insertAfterIndex = idx;
          }
        }
      });

      // Remove layer from current position
      const [removed] = specData.layers.splice(layerIndex, 1);

      // Adjust insert index if we removed from before it
      if (layerIndex < insertAfterIndex) {
        insertAfterIndex--;
      }

      // Save scroll position before re-render
      const timelineOuter = document.querySelector('.timeline-outer-wrapper');
      const scrollTop = timelineOuter ? timelineOuter.scrollTop : 0;

      // Insert after the last child (or after parent if no children)
      specData.layers.splice(insertAfterIndex + 1, 0, removed);

      // Re-render
      if (viewMode === 'table') {
        renderTableView();
      } else {
        renderTimeline();
      }

      // Restore scroll position after re-render
      requestAnimationFrame(() => {
        const newTimelineOuter = document.querySelector('.timeline-outer-wrapper');
        if (newTimelineOuter) {
          newTimelineOuter.scrollTop = scrollTop;
        }
      });
    }

    // Convert a child layer to a standalone layer
    function convertChildToStandalone(layerIndex, newPositionIndex, position) {
      const layer = specData.layers[layerIndex];
      if (!layer || !layer.parenting) return;

      saveSnapshot();

      // Remove parenting info
      delete layer.parenting;
      delete layer.parentingDescription;
      delete layer.parentingColor;

      // Calculate actual target index
      let targetIndex = newPositionIndex;
      if (position === 'after') targetIndex++;
      if (layerIndex < targetIndex) targetIndex--;

      // Save scroll position before re-render
      const timelineOuter = document.querySelector('.timeline-outer-wrapper');
      const scrollTop = timelineOuter ? timelineOuter.scrollTop : 0;

      if (layerIndex !== targetIndex) {
        // Remove from old position
        const [removed] = specData.layers.splice(layerIndex, 1);
        // Insert at new position
        specData.layers.splice(targetIndex, 0, removed);
      }

      // Re-render
      if (viewMode === 'table') {
        renderTableView();
      } else {
        renderTimeline();
      }

      // Restore scroll position after re-render
      requestAnimationFrame(() => {
        const newTimelineOuter = document.querySelector('.timeline-outer-wrapper');
        if (newTimelineOuter) {
          newTimelineOuter.scrollTop = scrollTop;
        }
      });
    }

    // Setup playhead dragging
    let playheadListenersAdded = false;
    function setupPlayheadDragging() {
      const playhead = document.getElementById('playhead');
      if (!playhead) return;

      const outerWrapper = document.querySelector('.timeline-outer-wrapper');
      const timelineContent = document.querySelector('.timeline-content-column');
      const timelineRuler = document.querySelector('.timeline-ruler');

      function onMouseDown(e) {
        isDraggingPlayhead = true;
        video.pause();
        const playPauseBtn = document.getElementById('playPauseBtn');
        if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon"><svg viewBox="0 0 10 12"><path d="M1 1.5 L8.5 6 L1 10.5 Z" stroke="white" stroke-width="2" stroke-linejoin="round" fill="white"/></svg></span>';
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        onMouseMove(e);
      }

      function onMouseMove(e) {
        const wrapperRect = outerWrapper.getBoundingClientRect();
        const contentRect = timelineContent.getBoundingClientRect();
        let x = e.clientX - contentRect.left;

        // Calculate percentage of full width (not content width)
        let percentage = x / contentRect.width;

        // Clamp percentage between 0 and 1 (allow full range)
        percentage = Math.max(0, Math.min(percentage, 1.0));

        // Calculate pixel position relative to viewport
        const leftPosition = contentRect.left + (percentage * contentRect.width);
        playhead.style.left = `${leftPosition}px`;

        // Position playhead to extend from ruler down through content
        if (timelineRuler) {
          const rulerRect = timelineRuler.getBoundingClientRect();
          playhead.style.top = `${rulerRect.top + 32}px`;
        } else {
          playhead.style.top = `${wrapperRect.top}px`;
        }
        playhead.style.bottom = `${window.innerHeight - wrapperRect.bottom + 1}px`;

        if (video.duration && specData) {
          // Convert drag percentage to spec time (use current view duration for zoom)
          const currentViewDuration = viewDuration || specData.workArea.duration;
          const specTimeMs = (percentage * currentViewDuration);

          // Store this position for when we release
          lastDraggedSpecTimeMs = specTimeMs;

          // Calculate target video time - direct time mapping (ms to seconds)
          const targetVideoTime = specTimeMs / 1000;
          lastDraggedVideoTime = Math.min(targetVideoTime, video.duration);

          // Use throttled seek to prevent multiple competing seeks
          scheduleVideoSeek(lastDraggedVideoTime);

          // Display the exact spec time we're dragging to
          const playheadTimeDisplay = document.getElementById('playheadTimeDisplay');
          if (playheadTimeDisplay) {
            playheadTimeDisplay.textContent = `${specTimeMs.toFixed(0)}ms`;
          }
        }
      }

      function onMouseUp() {
        isDraggingPlayhead = false;
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);

        // Set flag IMMEDIATELY to freeze display updates (before RAF executes)
        justFinishedDragging = true;

        // Schedule final seek in its own RAF to ensure it executes AFTER any pending drag RAF
        requestAnimationFrame(() => {
          // Now set the final video time - this will be the last seek
          if (lastDraggedVideoTime !== null) {
            video.currentTime = lastDraggedVideoTime;
          }

          // Clear the flag after everything settles
          setTimeout(() => {
            justFinishedDragging = false;
            lastDraggedSpecTimeMs = null;
            lastDraggedVideoTime = null;
          }, 100);
        });
      }

      playhead.addEventListener('mousedown', onMouseDown);

      // Only add window/container listeners once to avoid duplicates
      if (!playheadListenersAdded) {
        playheadListenersAdded = true;

        // Update playhead position on window resize and scroll
        window.addEventListener('resize', () => {
          if (!isDraggingPlayhead) {
            updatePlayhead();
          }
        });

        // Update playhead position on scroll
        window.addEventListener('scroll', () => {
          if (!isDraggingPlayhead) {
            updatePlayhead();
          }
        });

        // Also update on timeline container scroll
        const timelineContainer = document.querySelector('.timeline-container');
        if (timelineContainer) {
          timelineContainer.addEventListener('scroll', () => {
            if (!isDraggingPlayhead) {
              updatePlayhead();
            }
          });
        }
      }
    }

    // Toggle color picker panel
    function toggleColorPicker(event, animIndex) {
      event.stopPropagation();
      const panel = document.getElementById('colorPickerPanel');
      const dot = document.getElementById('colorPickerDot');

      if (panel.classList.contains('visible')) {
        panel.classList.remove('visible');
      } else {
        panel.classList.add('visible');

        // Position panel above the dot
        const dotRect = dot.getBoundingClientRect();
        panel.style.left = '-36px';
        panel.style.bottom = 'calc(100% + 12px)';
      }
    }

    // Change animation color
    function changeAnimationColor(animIndex, color) {
      saveSnapshot();
      // Find the animation in specData
      let currentIndex = 0;
      let targetAnim = null;

      for (let i = 0; i < specData.layers.length; i++) {
        const layer = specData.layers[i];
        for (let j = 0; j < layer.animations.length; j++) {
          if (currentIndex === animIndex) {
            targetAnim = layer.animations[j];
            break;
          }
          currentIndex++;
        }
        if (targetAnim) break;
      }

      if (targetAnim) {
        const videoId = getCurrentVideoId();
        setAnimationColorForVideo(targetAnim, videoId, color);

        // Update colors directly in DOM without re-rendering
        const brightColor = brightenColor(color);

        // Update timeline bar
        const bar = document.querySelector(`.timeline-bar[data-anim-index="${animIndex}"]`);
        if (bar) {
          bar.style.background = color;
          bar.style.borderColor = color;
        }

        // Update color picker dot
        const dot = document.getElementById('colorPickerDot');
        if (dot) dot.style.background = brightColor;

        // Update detail panel border
        const panel = document.querySelector('.detail-panel');
        if (panel) panel.style.borderLeftColor = brightColor;

        // Update selected state in color picker grid
        const colorOptions = document.querySelectorAll('.color-option');
        colorOptions.forEach(opt => {
          opt.classList.toggle('selected', opt.style.background === color ||
            opt.style.backgroundColor === color ||
            rgbToHex(opt.style.backgroundColor) === color.toLowerCase());
        });
      }
    }

    // Helper to convert rgb() to hex for color comparison
    function rgbToHex(rgb) {
      if (!rgb || rgb.startsWith('#')) return rgb;
      const match = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
      if (!match) return rgb;
      return '#' + [match[1], match[2], match[3]].map(x => {
        const hex = parseInt(x).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }

    // Close color picker when clicking outside
    document.addEventListener('click', (e) => {
      const panel = document.getElementById('colorPickerPanel');
      const dot = document.getElementById('colorPickerDot');
      if (panel && !panel.contains(e.target) && e.target !== dot) {
        panel.classList.remove('visible');
      }
    });

    // Show animation details
    // PATTERN FOR EDITABLE FIELDS:
    // - In edit mode (isEditMode === true): Render <input> fields with onblur/onkeydown handlers
    // - In read mode (isEditMode === false): Render plain text (selectable but not editable)
    // - Use: if (isEditMode) { /* input */ } else { /* plain text */ }
    // - Call updateAnimationField(animIndex, fieldName, newValue) to save changes
    function showAnimationDetails(animIndex) {
      // Store the selected animation index
      selectedAnimation = animIndex;
      selectedParentedLayerIndex = null; // Clear parented layer selection

      let currentIndex = 0;
      let anim = null;
      let layer = null;
      let layerIndex = -1;

      for (let lIdx = 0; lIdx < specData.layers.length; lIdx++) {
        const l = specData.layers[lIdx];
        for (const a of l.animations) {
          if (currentIndex === animIndex) {
            anim = a;
            layer = l;
            layerIndex = lIdx;
            break;
          }
          currentIndex++;
        }
        if (anim) break;
      }

      if (!anim) return;

      const detailPanel = document.getElementById('detailPanel');
      const description = getAnimationDescription(anim.property, anim.values, anim.fitToShape, anim.description, layer.layerName);

      // Get the color for this animation type (use custom color if set)
      const colorClass = getPropertyColorClass(anim.property);
      const defaultBarColor = getPropertyColor(colorClass);
      const videoId = getCurrentVideoId();
      const customColor = getAnimationColorForVideo(anim, videoId);
      const barColor = customColor || defaultBarColor;
      const brightColor = brightenColor(barColor);

      // Define available colors for picker (sorted cool to warm, 1.2x brighter)
      const colorOptions = [
        '#056e96', // blue (coolest)
        '#056e53', // teal
        '#5b925b', // green
        '#6c1c90', // purple
        '#ca317d', // pink
        '#ca3131', // red
        '#d15519', // orange
        '#595959'  // dark grey
      ];

      let html = `<div class="detail-panel" style="border-left-color: ${brightColor};">`;
      html += `<div class="detail-panel-header">`;
      html += `<div class="detail-panel-title">`;
      html += `<div class="color-picker-dot" id="colorPickerDot" style="background: ${brightColor};" onclick="toggleColorPicker(event, ${animIndex})"></div>`;
      if (isEditMode) {
        html += `<input
          type="text"
          class="detail-title-input detail-title-input-section"
          value="${layer.layerName.replace(/"/g, '&quot;')}"
          maxlength="21"
          onfocus="this.select()"
          onblur="updateLayerField(${layerIndex}, 'layerName', this.value)"
          oninput="autoResizeTitleInput(this)"
          onkeydown="if(event.key === 'Enter') { this.blur(); }"
        />`;
        html += `<span>  </span>`;
        html += `<input
          type="text"
          class="detail-title-input detail-title-input-property"
          value="${anim.property.replace(/"/g, '&quot;')}"
          maxlength="21"
          onfocus="this.select()"
          onblur="updateAnimationField(${animIndex}, 'property', this.value)"
          oninput="autoResizeTitleInput(this)"
          onkeydown="if(event.key === 'Enter') { this.blur(); }"
        />`;
      } else {
        html += `<span>${layer.layerName}  ${anim.property}</span>`;
      }

      // Color picker panel
      html += `<div class="color-picker-panel" id="colorPickerPanel">`;
      html += `<div class="color-picker-grid">`;
      colorOptions.forEach(color => {
        const selected = color === barColor ? 'selected' : '';
        html += `<div class="color-option ${selected}" style="background: ${color};" onclick="changeAnimationColor(${animIndex}, '${color}')"></div>`;
      });
      html += `</div></div>`;
      html += `</div>`;

      if (isEditMode) {
        html += `<div class="detail-panel-actions">`;
        html += `<button class="detail-panel-action-btn delete" onclick="deleteAnimation(${animIndex})"><span style="font-size: 11px; position: relative; top: -1px; margin-right: -2px;"></span>&nbsp; Delete</button>`;
        html += `<button class="detail-panel-close" onclick="document.getElementById('detailPanel').innerHTML=''; selectedAnimation = null; document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected')); document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected')); document.querySelectorAll('.timeline-label.child-layer-header').forEach(l => l.classList.remove('selected')); requestAnimationFrame(() => updatePlayhead());">&times;</button>`;
        html += `</div>`;
      } else {
        html += `<button class="detail-panel-close" onclick="document.getElementById('detailPanel').innerHTML=''; selectedAnimation = null; document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected')); document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected')); document.querySelectorAll('.timeline-label.child-layer-header').forEach(l => l.classList.remove('selected')); requestAnimationFrame(() => updatePlayhead());">&times;</button>`;
      }

      html += `</div>`;

      // Description - full width above other fields (no label, just as subheader)
      // Description - editable in edit mode, plain text in read mode
      if (isEditMode) {
        html += `
          <div class="detail-description">
            <input
              type="text"
              class="detail-description-input"
              value="${description.replace(/"/g, '&quot;')}"
              placeholder="Enter description..."
              onfocus="this.select()"
              onblur="updateAnimationField(${animIndex}, 'customDescription', this.value)"
              onkeydown="if(event.key === 'Enter') { this.blur(); }"
            />
          </div>
        `;
      } else {
        html += `
          <div class="detail-description">${description}</div>
        `;
      }

      html += `<div class="detail-grid">`;

      // Animation details (delay, duration, easing, values)
      {
        // Delay - editable in edit mode
        html += `<div class="detail-item">`;
        html += `<div class="detail-label">DELAY (ms)</div>`;
        if (isEditMode) {
          html += `
            <div class="detail-value">
              <input
                type="text"
                class="detail-value-input"
                value="${anim.timing.delay}"
                onfocus="this.select()"
                onblur="updateAnimationField(${animIndex}, 'delay', this.value)"
                onkeydown="if(event.key === 'Enter') { this.blur(); }"
              />
            </div>
          `;
        } else {
          html += `<div class="detail-value">${anim.timing.delay}ms</div>`;
        }
        html += `</div>`;

        // Duration - always editable in edit mode
        // For springs from import (not yet edited), show "-"
        const durationIsNumeric = typeof anim.timing.duration === 'number' && !isNaN(anim.timing.duration);
        const userSetDuration = anim.durationUserSet === true;
        const isImportedSpring = !userSetDuration && anim.easing.type === 'spring' && durationIsNumeric;

        const durationInputValue = isImportedSpring ? '-' : (durationIsNumeric ? anim.timing.duration : '-');
        const durationDisplayValue = isImportedSpring ? '-' : (durationIsNumeric ? `${anim.timing.duration}ms` : '-');

        html += `<div class="detail-item">`;
        html += `<div class="detail-label">DURATION (ms)</div>`;
        if (isEditMode) {
          html += `
            <div class="detail-value">
              <input
                type="text"
                class="detail-value-input"
                value="${durationInputValue}"
                onfocus="this.select()"
                onblur="updateAnimationField(${animIndex}, 'duration', this.value)"
                onkeydown="if(event.key === 'Enter') { this.blur(); }"
              />
            </div>
          `;
        } else {
          html += `<div class="detail-value">${durationDisplayValue}</div>`;
        }
        html += `</div>`;
      }

      // Easing
      {
        let easingText = '';
        let easingTextPlain = '';  // Plain text version for edit mode

        // Check for custom easing first
        if (anim.customEasing !== undefined && anim.customEasing !== null) {
          easingTextPlain = anim.customEasing;  // Plain text for textarea
          easingText = formatSpringPreset(anim.customEasing);  // HTML for read-only
        } else if (anim.easing.type === 'spring') {
          const spring = anim.easing.spring;
          const presetSprings = ['Standard Spring', 'Slow Spring', 'Fast Spring', 'Slow Bounce Spring', 'Medium Bounce Spring', 'Fast Bounce Spring'];
          const isPreset = presetSprings.includes(spring.preset);

          if (isPreset) {
            easingTextPlain = spring.preset;
            easingText = spring.preset;
          } else {
            // Custom spring values as text
            const springText = `Stiffness: ${spring.custom.stiffness}, Damping: ${spring.custom.damping}, Damping Ratio: ${spring.custom.dampingRatio}, Mass: ${spring.custom.mass}`;
            easingTextPlain = springText;
            easingText = `Stiffness: <span class="num">${spring.custom.stiffness}</span>, Damping: <span class="num">${spring.custom.damping}</span>, Damping Ratio: <span class="num">${spring.custom.dampingRatio}</span>, Mass: <span class="num">${spring.custom.mass}</span>`;
          }
        } else if (anim.easing.type === 'cubic-bezier') {
          const bezierValue = anim.easing.cubicBezier;

          // Check if preset name is already provided in JSON
          let presetName = anim.easing.cubicBezierPreset;

          // If not provided, use tolerance-based matching (0.15) to handle AE's imprecise bezier values
          if (!presetName) {
            presetName = matchCubicBezierWithTolerance(bezierValue);
          }

          easingTextPlain = presetName || bezierValue;
          easingText = presetName || bezierValue;
        } else {
          easingTextPlain = anim.easing.type;
          easingText = anim.easing.type;
        }

        html += `<div class="detail-item">`;
        html += `<div class="detail-label">Easing</div>`;
        if (isEditMode) {
          html += `
            <div class="detail-value easing-editable" data-anim-index="${animIndex}" data-plain="${easingTextPlain.replace(/"/g, '&quot;')}">${easingText}</div>
          `;
        } else {
          html += `<div class="detail-value">${easingText}</div>`;
        }
        html += `</div>`;
      }

      // Start and End Values
      if (anim.values && anim.values.formatted) {
        let startValue = anim.customStartValue !== undefined && anim.customStartValue !== null
          ? anim.customStartValue
          : formatDecimalValue(anim.values.formatted.startValue);
        let endValue = anim.customEndValue !== undefined && anim.customEndValue !== null
          ? anim.customEndValue
          : formatDecimalValue(anim.values.formatted.endValue);

        // Apply scale factor for position/dimension properties
        startValue = scaleFormattedValue(startValue, anim.property);
        endValue = scaleFormattedValue(endValue, anim.property);

        // For grouped Position, only show values that changed with (X)/(Y) labels
        if (anim.isGrouped && anim.groupType === 'position' && Array.isArray(anim.values.change)) {
          const [xChange, yChange] = anim.values.change;
          const groupedAnims = anim.groupedAnimations || [];
          const xAnim = groupedAnims.find(a => a.property?.toLowerCase().includes('x position'));
          const yAnim = groupedAnims.find(a => a.property?.toLowerCase().includes('y position'));

          const startParts = [];
          const endParts = [];

          if (xChange !== 0 && xAnim?.values) {
            startParts.push(`${scaleValue(Math.round(xAnim.values.startValue))}px (X)`);
            endParts.push(`${scaleValue(Math.round(xAnim.values.endValue))}px (X)`);
          }
          if (yChange !== 0 && yAnim?.values) {
            startParts.push(`${scaleValue(Math.round(yAnim.values.startValue))}px (Y)`);
            endParts.push(`${scaleValue(Math.round(yAnim.values.endValue))}px (Y)`);
          }

          startValue = startParts.length > 0 ? startParts.join('\n') : '-';
          endValue = endParts.length > 0 ? endParts.join('\n') : '-';
        }
        // Handle pre-combined Position format like "(197px, 538px)" from JSON
        else if (anim.property?.toLowerCase() === 'position' && startValue.includes(',')) {
          // Parse "(Xpx, Ypx)" format
          const parsePositionValue = (val) => {
            const match = val.match(/\(?\s*(-?\d+\.?\d*)px?\s*,\s*(-?\d+\.?\d*)px?\s*\)?/);
            if (match) return { x: parseFloat(match[1]), y: parseFloat(match[2]) };
            return null;
          };
          const startPos = parsePositionValue(startValue);
          const endPos = parsePositionValue(endValue);

          if (startPos && endPos) {
            const xChanged = Math.round(startPos.x) !== Math.round(endPos.x);
            const yChanged = Math.round(startPos.y) !== Math.round(endPos.y);

            const startParts = [];
            const endParts = [];

            if (xChanged) {
              startParts.push(`${scaleValue(Math.round(startPos.x))}px (X)`);
              endParts.push(`${scaleValue(Math.round(endPos.x))}px (X)`);
            }
            if (yChanged) {
              startParts.push(`${scaleValue(Math.round(startPos.y))}px (Y)`);
              endParts.push(`${scaleValue(Math.round(endPos.y))}px (Y)`);
            }

            startValue = startParts.length > 0 ? startParts.join('\n') : '-';
            endValue = endParts.length > 0 ? endParts.join('\n') : '-';
          }
        }
        // Handle Scale format like "100%, 100%" - simplify to single value if X and Y are same
        else if (anim.property?.toLowerCase().includes('scale') && startValue.includes(',')) {
          const parseScaleValue = (val) => {
            const match = val.match(/(-?\d+\.?\d*)%?\s*,\s*(-?\d+\.?\d*)%?/);
            if (match) return { x: parseFloat(match[1]), y: parseFloat(match[2]) };
            return null;
          };
          const startScale = parseScaleValue(startValue);
          const endScale = parseScaleValue(endValue);

          if (startScale && startScale.x === startScale.y) {
            startValue = `${Math.round(startScale.x)}%`;
          }
          if (endScale && endScale.x === endScale.y) {
            endValue = `${Math.round(endScale.x)}%`;
          }
        }

        // Show "-" if empty
        if (startValue === '') startValue = '-';
        if (endValue === '') endValue = '-';

        html += `<div class="detail-item">`;
        html += `<div class="detail-label">Start Value</div>`;
        if (isEditMode) {
          const hasNewline = startValue.includes('\n');
          if (hasNewline) {
            html += `
              <div class="detail-value">
                <textarea
                  class="detail-value-input"
                  rows="2"
                  onfocus="this.select()"
                  onblur="updateAnimationField(${animIndex}, 'startValue', this.value)"
                  onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); this.blur(); }"
                >${startValue.replace(/"/g, '&quot;')}</textarea>
              </div>
            `;
          } else {
            html += `
              <div class="detail-value">
                <input
                  type="text"
                  class="detail-value-input"
                  value="${startValue.replace(/"/g, '&quot;')}"
                  onfocus="this.select()"
                  onblur="updateAnimationField(${animIndex}, 'startValue', this.value)"
                  onkeydown="if(event.key === 'Enter') { this.blur(); }"
                />
              </div>
            `;
          }
        } else {
          html += `<div class="detail-value">${startValue.replace(/\n/g, '<br>')}</div>`;
        }
        html += `</div>`;

        html += `<div class="detail-item">`;
        html += `<div class="detail-label">End Value</div>`;
        if (isEditMode) {
          const hasNewline = endValue.includes('\n');
          if (hasNewline) {
            html += `
              <div class="detail-value">
                <textarea
                  class="detail-value-input"
                  rows="2"
                  onfocus="this.select()"
                  onblur="updateAnimationField(${animIndex}, 'endValue', this.value)"
                  onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); this.blur(); }"
                >${endValue.replace(/"/g, '&quot;')}</textarea>
              </div>
            `;
          } else {
            html += `
              <div class="detail-value">
                <input
                  type="text"
                  class="detail-value-input"
                  value="${endValue.replace(/"/g, '&quot;')}"
                  onfocus="this.select()"
                  onblur="updateAnimationField(${animIndex}, 'endValue', this.value)"
                  onkeydown="if(event.key === 'Enter') { this.blur(); }"
                />
              </div>
            `;
          }
        } else {
          html += `<div class="detail-value">${endValue.replace(/\n/g, '<br>')}</div>`;
        }
        html += `</div>`;
      }

      html += `</div></div>`;
      detailPanel.innerHTML = html;

      // Function to resize all textareas to fit their content
      function resizeTextareas() {
        const textareas = detailPanel.querySelectorAll('textarea.detail-value-input');
        textareas.forEach(textarea => {
          textarea.style.height = 'auto';
          // Add 4px buffer to prevent scrollbar from appearing
          textarea.style.height = (textarea.scrollHeight + 4) + 'px';
        });
      }

      // Auto-resize all textareas to fit their content
      // Use requestAnimationFrame to ensure DOM is fully rendered
      requestAnimationFrame(() => {
        resizeTextareas();
      });

      // Auto-resize title input fields to fit their content
      const titleInputs = detailPanel.querySelectorAll('.detail-title-input');
      titleInputs.forEach(input => autoResizeTitleInput(input));

      // Setup click-to-edit for easing field (shows formatted HTML until clicked)
      const easingEditable = detailPanel.querySelector('.easing-editable');
      if (easingEditable) {
        easingEditable.addEventListener('click', function() {
          const animIdx = parseInt(this.dataset.animIndex);
          const plainText = this.dataset.plain;

          // Replace with textarea
          const textarea = document.createElement('textarea');
          textarea.className = 'detail-value-input';
          textarea.rows = 1;
          textarea.value = plainText;
          textarea.style.width = '100%';
          textarea.dataset.animIndex = animIdx; // Store anim index for preset selection

          this.replaceWith(textarea);
          textarea.focus();
          textarea.select();

          // Auto-resize
          textarea.style.height = 'auto';
          textarea.style.height = (textarea.scrollHeight + 4) + 'px';

          // Show autocomplete
          showEasingAutocomplete(textarea, textarea.value.trim());

          // Handle blur to save and re-render
          // Use setTimeout to allow any pending click events (like preset selection) to fire first
          textarea.addEventListener('blur', () => {
            setTimeout(() => {
              // Only save if the textarea is still in the DOM (wasn't replaced by preset selection)
              if (document.body.contains(textarea)) {
                hideEasingAutocomplete();
                updateAnimationField(animIdx, 'easing', textarea.value);
              }
            }, 100);
          });

          textarea.addEventListener('input', () => {
            hideEasingAutocomplete();
            textarea.style.height = 'auto';
            textarea.style.height = (textarea.scrollHeight + 4) + 'px';
          });

          textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              hideEasingAutocomplete();
              textarea.blur();
            }
          });
        });
      }

      // Remove old resize listener if it exists
      if (window.textareaResizeListener) {
        window.removeEventListener('resize', window.textareaResizeListener);
      }

      // Add resize listener to handle window resizing
      window.textareaResizeListener = () => resizeTextareas();
      window.addEventListener('resize', window.textareaResizeListener);

      // Update playhead position after info box is shown
      requestAnimationFrame(() => {
        updatePlayhead();

        // Smart scroll: ensure the selected row isn't hidden by the detail panel
        const timelineContainer = document.querySelector('.timeline-container');
        const selectedBar = document.querySelector('.timeline-bar.selected');

        if (timelineContainer && selectedBar && detailPanel) {
          const containerRect = timelineContainer.getBoundingClientRect();
          const barRect = selectedBar.getBoundingClientRect();
          const panelRect = detailPanel.getBoundingClientRect();

          // Calculate the bottom edge of visible area (above the detail panel)
          const visibleBottom = panelRect.top - 20; // 20px margin

          // If the selected bar is below the visible area or will be covered by the panel
          if (barRect.bottom > visibleBottom) {
            // Calculate how much to scroll
            const scrollAmount = barRect.bottom - visibleBottom;
            timelineContainer.scrollTop += scrollAmount;
          }
        }
      });
    }

    // Show info box for section headers (layer name, parent to dropdown, delete)
    function showSectionHeaderDetails(layerIndex) {
      const layer = specData.layers[layerIndex];
      if (!layer) return;
      // Don't show this for layers that are already parented (use showParentedLayerDetails for those)
      if (layer.parenting) return;

      selectedAnimation = null;
      selectedParentedLayerIndex = null;
      selectedSectionHeaderIndex = layerIndex;

      const detailPanel = document.getElementById('detailPanel');

      // Get a color for the border (use first animation's color or default)
      let barColor = '#595959';
      if (layer.animations.length > 0) {
        const colorClass = getPropertyColorClass(layer.animations[0].property);
        barColor = getPropertyColor(colorClass);
        const videoId = getCurrentVideoId();
        const customColor = getAnimationColorForVideo(layer.animations[0], videoId);
        if (customColor) barColor = customColor;
      }
      const brightColor = brightenColor(barColor);

      let html = `<div class="detail-panel" style="border-left-color: ${brightColor};">`;
      html += `<div class="detail-panel-header">`;
      html += `<div class="detail-panel-title">`;

      if (isEditMode) {
        html += `<input
          type="text"
          class="detail-title-input detail-title-input-section"
          value="${layer.layerName.replace(/"/g, '&quot;')}"
          maxlength="21"
          onfocus="this.select()"
          onblur="updateLayerField(${layerIndex}, 'layerName', this.value)"
          oninput="autoResizeTitleInput(this)"
          onkeydown="if(event.key === 'Enter') { this.blur(); }"
        />`;
      } else {
        html += `<span>${layer.layerName}</span>`;
      }

      html += `</div>`;

      if (isEditMode) {
        html += `<div class="detail-panel-actions">`;

        // Parent to dropdown
        const parentOptions = getAvailableParentLayers(layerIndex);
        html += `<div class="parent-selector-container">`;
        html += `<span class="parent-selector-label">Parented to:</span>`;
        html += `<select class="parent-selector" onchange="setLayerParentFromSection(${layerIndex}, this.value)">`;
        html += `<option value="">None</option>`;
        parentOptions.forEach(opt => {
          html += `<option value="${opt.name}">${opt.name}</option>`;
        });
        html += `</select>`;
        html += `</div>`;

        html += `<button class="detail-panel-action-btn delete" onclick="deleteSection(${layerIndex})"><span style="font-size: 11px; position: relative; top: -1px; margin-right: -2px;"></span>&nbsp; Delete</button>`;
        html += `<button class="detail-panel-close" onclick="closeSectionDetails()">&times;</button>`;
        html += `</div>`;
      } else {
        html += `<button class="detail-panel-close" onclick="closeSectionDetails()">&times;</button>`;
      }

      html += `</div>`; // detail-panel-header
      html += `</div>`; // detail-panel
      detailPanel.innerHTML = html;

      // Auto-resize title input
      const titleInput = detailPanel.querySelector('.detail-title-input');
      if (titleInput) autoResizeTitleInput(titleInput);

      requestAnimationFrame(() => updatePlayhead());
    }

    // Close the section header detail panel
    function closeSectionDetails() {
      selectedSectionHeaderIndex = null;
      const detailPanel = document.getElementById('detailPanel');
      if (detailPanel) detailPanel.innerHTML = '';
      document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
      document.querySelectorAll('.timeline-label.layer-header').forEach(l => l.classList.remove('selected'));
      requestAnimationFrame(() => updatePlayhead());
    }

    // Set a layer's parent from section header context
    function setLayerParentFromSection(layerIndex, parentName) {
      if (!specData || layerIndex < 0 || layerIndex >= specData.layers.length) return;

      saveSnapshot();

      const layer = specData.layers[layerIndex];

      if (!parentName || parentName === '') {
        // Remove parenting (already not parented in section context, so nothing to do)
        return;
      }

      // Find the parent layer to get its ID
      const parentLayer = specData.layers.find(l => l.layerName === parentName);
      if (!parentLayer || !parentLayer.id) return;

      // Set the parent using unique ID
      layer.parenting = {
        parentId: parentLayer.id,
        parentName: parentName, // Keep for display/export compatibility
        animatingProperties: layer.animations.map(a => a.property)
      };

      // Find the parent layer's index
      const parentIndex = specData.layers.findIndex(l => l.id === parentLayer.id);
      if (parentIndex !== -1 && parentIndex !== layerIndex) {
        // Remove the layer from its current position
        const [movedLayer] = specData.layers.splice(layerIndex, 1);

        // Find where to insert it (right after the parent and any existing children)
        let insertIndex = parentIndex + 1;
        while (insertIndex < specData.layers.length &&
               specData.layers[insertIndex].parenting?.parentId === parentLayer.id) {
          insertIndex++;
        }

        // Adjust insert index if we removed from before the insert position
        if (layerIndex < insertIndex) {
          insertIndex--;
        }

        // Insert the layer at the new position
        specData.layers.splice(insertIndex, 0, movedLayer);
      }

      setCurrentSpecData(specData);
      refreshActiveView();

      // After parenting, show the parented layer details (since it's now a child)
      const newLayerIndex = specData.layers.findIndex(l => l.layerName === layer.layerName);
      if (newLayerIndex !== -1) {
        // Select the child layer header
        selectedSectionHeaderIndex = null;
        const childHeader = document.querySelector(`.timeline-label.child-layer-header[data-layer-index="${newLayerIndex}"]`);
        if (childHeader) {
          childHeader.classList.add('selected');
        }
        showParentedLayerDetails(newLayerIndex);
      }
    }

    // Change a layer's parent (can unparent or switch to different parent)
    function changeLayerParent(layerIndex, newParentName) {
      if (!specData || layerIndex < 0 || layerIndex >= specData.layers.length) return;

      saveSnapshot();

      const layer = specData.layers[layerIndex];
      const layerName = layer.layerName;
      const wasParented = !!layer.parenting;

      if (!newParentName || newParentName === '') {
        // Unparent - make it a top-level layer
        delete layer.parenting;
        delete layer.parentingDescription;
        delete layer.parentingColor;
      } else {
        // Find the new parent layer to get its ID
        const newParentLayer = specData.layers.find(l => l.layerName === newParentName);
        if (!newParentLayer || !newParentLayer.id) return;

        // Set the new parent using unique ID
        layer.parenting = {
          parentId: newParentLayer.id,
          parentName: newParentName, // Keep for display/export compatibility
          animatingProperties: layer.animations.map(a => a.property)
        };
      }

      // Reorder layers if needed
      if (newParentName && newParentName !== '') {
        // Moving to a parent - position after parent and its children
        const newParentLayer = specData.layers.find(l => l.layerName === newParentName);
        const parentIndex = newParentLayer ? specData.layers.findIndex(l => l.id === newParentLayer.id) : -1;
        if (parentIndex !== -1 && parentIndex !== layerIndex && newParentLayer) {
          const [movedLayer] = specData.layers.splice(layerIndex, 1);
          let insertIndex = parentIndex + 1;
          while (insertIndex < specData.layers.length &&
                 specData.layers[insertIndex].parenting?.parentId === newParentLayer.id) {
            insertIndex++;
          }
          if (layerIndex < insertIndex) insertIndex--;
          specData.layers.splice(insertIndex, 0, movedLayer);
        }
      }

      setCurrentSpecData(specData);
      refreshActiveView();

      // Show appropriate info box after change
      const newLayerIndex = specData.layers.findIndex(l => l.layerName === layerName);
      if (newLayerIndex !== -1) {
        if (specData.layers[newLayerIndex].parenting) {
          // Still parented - show child layer details
          selectedParentedLayerIndex = newLayerIndex;
          selectedSectionHeaderIndex = null;
          const childHeader = document.querySelector(`.timeline-label.child-layer-header[data-layer-index="${newLayerIndex}"]`);
          if (childHeader) childHeader.classList.add('selected');
          showParentedLayerDetails(newLayerIndex);
        } else {
          // Unparented - show section header details
          selectedSectionHeaderIndex = newLayerIndex;
          selectedParentedLayerIndex = null;
          const layerHeader = document.querySelector(`.timeline-label.layer-header[data-layer-index="${newLayerIndex}"]`);
          if (layerHeader) layerHeader.classList.add('selected');
          showSectionHeaderDetails(newLayerIndex);
        }
      }
    }

    // Delete a section (layer) and all its children
    function deleteSection(layerIndex) {
      const layer = specData.layers[layerIndex];
      if (!layer) return;

      const layerName = layer.layerName;
      const layerId = layer.id;
      if (!confirm(`Delete "${layerName}" section and all its animations?`)) {
        return;
      }

      saveSnapshot();

      // Find and delete any child layers first (using parentId for accurate matching)
      const childrenToDelete = specData.layers
        .map((l, i) => ({ layer: l, index: i }))
        .filter(item => item.layer.parenting?.parentId === layerId)
        .map(item => item.index)
        .sort((a, b) => b - a); // Sort descending to delete from end first

      childrenToDelete.forEach(idx => {
        specData.layers.splice(idx, 1);
      });

      // Recalculate the layer index after child deletions
      const newLayerIndex = specData.layers.findIndex(l => l.id === layerId);
      if (newLayerIndex !== -1) {
        specData.layers.splice(newLayerIndex, 1);
      }

      setCurrentSpecData(specData);
      closeSectionDetails();
      refreshActiveView();
    }

    // Show simplified info box for parented layers (just layer name, description, color picker)
    function showParentedLayerDetails(layerIndex) {
      const layer = specData.layers[layerIndex];
      if (!layer || !layer.parenting) return;

      selectedAnimation = null; // Clear animation selection
      selectedParentedLayerIndex = layerIndex; // Track for info box refresh

      const detailPanel = document.getElementById('detailPanel');
      const parentName = layer.parenting.parentName;
      const parentId = layer.parenting.parentId;

      // Get inherited properties for the title display (LayerName  Position, Scale)
      const inheritableProps = ['position', 'scale', 'rotation', 'opacity'];
      const parentLayer = parentId ? specData.layers.find(l => l.id === parentId) : specData.layers.find(l => l.layerName === parentName);
      const allParentProps = parentLayer ? parentLayer.animations.map(a => a.property.toLowerCase()) : [];
      const animatingProps = inheritableProps.filter(p => allParentProps.includes(p));
      const capsProps = animatingProps.map(p => p.charAt(0).toUpperCase() + p.slice(1));
      const propsDisplay = capsProps.join(', ');

      // Simple default description - user can customize if needed
      const defaultDescription = `Attached to ${parentName}`;
      const description = layer.parentingDescription || defaultDescription;

      // Use layer's custom color or a default grey
      const videoId = getCurrentVideoId();
      const customColor = layer.parentingColor || '#595959';
      const brightColor = brightenColor(customColor);

      // Define available colors for picker
      const colorOptions = [
        '#056e96', '#056e53', '#5b925b', '#6c1c90',
        '#ca317d', '#ca3131', '#d15519', '#595959'
      ];

      let html = `<div class="detail-panel" style="border-left-color: ${brightColor};">`;
      html += `<div class="detail-panel-header">`;
      html += `<div class="detail-panel-title">`;

      if (isEditMode) {
        html += `<input
          type="text"
          class="detail-title-input detail-title-input-section"
          value="${layer.layerName.replace(/"/g, '&quot;')}"
          maxlength="21"
          onfocus="this.select()"
          onblur="updateParentedPropertyLabel(${layerIndex}, this.value)"
          oninput="autoResizeTitleInput(this)"
          onkeydown="if(event.key === 'Enter') { this.blur(); }"
        />`;
        html += `<span>  </span>`;
        html += `<input
          type="text"
          class="detail-title-input detail-title-input-property"
          value="${propsDisplay.replace(/"/g, '&quot;')}"
          maxlength="40"
          onfocus="this.select()"
          onblur="updateParentedAnimatingProperties(${layerIndex}, this.value)"
          oninput="autoResizeTitleInput(this)"
          onkeydown="if(event.key === 'Enter') { this.blur(); }"
        />`;
      } else {
        html += `<span>${layer.layerName}  ${propsDisplay}</span>`;
      }

      html += `</div>`;

      if (isEditMode) {
        html += `<div class="detail-panel-actions">`;

        // Parent to dropdown (allows changing parent or unparenting)
        const parentOptions = getAvailableParentLayers(layerIndex);
        html += `<div class="parent-selector-container">`;
        html += `<span class="parent-selector-label">Parented to:</span>`;
        html += `<select class="parent-selector" onchange="changeLayerParent(${layerIndex}, this.value)">`;
        html += `<option value="">None</option>`;
        parentOptions.forEach(opt => {
          const selected = opt.name === parentName ? 'selected' : '';
          html += `<option value="${opt.name}" ${selected}>${opt.name}</option>`;
        });
        html += `</select>`;
        html += `</div>`;

        html += `<button class="detail-panel-action-btn delete" onclick="deleteParentedLayer(${layerIndex})"><span style="font-size: 11px; position: relative; top: -1px; margin-right: -2px;"></span>&nbsp; Delete</button>`;
        html += `<button class="detail-panel-close" onclick="closeParentedDetails()">&times;</button>`;
        html += `</div>`;
      } else {
        html += `<button class="detail-panel-close" onclick="closeParentedDetails()">&times;</button>`;
      }

      html += `</div>`;

      // Description - editable in edit mode (no border since it's the last element)
      if (isEditMode) {
        html += `
          <div class="detail-description no-border">
            <input
              type="text"
              class="detail-description-input"
              value="${description.replace(/"/g, '&quot;')}"
              placeholder="Enter description..."
              onfocus="this.select()"
              onblur="updateParentedDescription(${layerIndex}, this.value)"
              onkeydown="if(event.key === 'Enter') { this.blur(); }"
            />
          </div>
        `;
      } else {
        html += `<div class="detail-description no-border">${description}</div>`;
      }

      html += `</div>`;
      detailPanel.innerHTML = html;

      // Auto-resize title input
      const titleInput = detailPanel.querySelector('.detail-title-input');
      if (titleInput) autoResizeTitleInput(titleInput);

      // Update playhead position after info box is shown
      requestAnimationFrame(() => updatePlayhead());
    }

    // Close the parented layer detail panel
    function closeParentedDetails() {
      selectedParentedLayerIndex = null; // Clear selection tracking
      const detailPanel = document.getElementById('detailPanel');
      if (detailPanel) detailPanel.innerHTML = '';
      document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
      document.querySelectorAll('.timeline-label.child-layer-header').forEach(l => l.classList.remove('selected'));
      requestAnimationFrame(() => updatePlayhead());
    }

    // Update parented layer description
    function updateParentedDescription(layerIndex, value) {
      saveSnapshot();
      const layer = specData.layers[layerIndex];
      if (layer) {
        layer.parentingDescription = value;
        setCurrentSpecData(specData);
        // Update the bar text
        const bar = document.querySelector(`.timeline-bar.bar-attached[data-layer-index="${layerIndex}"]`);
        if (bar) {
          const textSpan = bar.querySelector('.timeline-bar-text');
          if (textSpan) textSpan.textContent = value;
        }
      }
    }

    // Update parented layer property label (the layer name shown in the info box)
    function updateParentedPropertyLabel(layerIndex, value) {
      // Use updateLayerField for consistency - it handles refreshActiveView
      updateLayerField(layerIndex, 'layerName', value);
    }

    // Update parented layer's animating properties
    function updateParentedAnimatingProperties(layerIndex, value) {
      saveSnapshot();
      const layer = specData.layers[layerIndex];
      if (layer && layer.parenting) {
        // Parse comma-separated values and convert to lowercase for storage
        const props = value.split(',')
          .map(p => p.trim().toLowerCase())
          .filter(p => p.length > 0);
        layer.parenting.animatingProperties = props;
        setCurrentSpecData(specData);
      }
    }

    // Delete a parented layer (removes the entire layer)
    function deleteParentedLayer(layerIndex) {
      const layer = specData.layers[layerIndex];
      if (!layer) return;

      const layerName = layer.layerName;
      if (!confirm(`Delete "${layerName}" section?`)) {
        return;
      }

      saveSnapshot();

      // Close the detail panel
      closeParentedDetails();

      // Remove the layer from specData
      specData.layers.splice(layerIndex, 1);

      // Update the tab's specData to reflect the changes
      setCurrentSpecData(specData);

      // Re-render based on current view mode
      if (viewMode === 'table') {
        renderTableView();
      } else {
        renderTimeline();
      }

      // Force recheck spacing since content was deleted
      requestAnimationFrame(() => {
        requestAnimationFrame(() => updateSectionSpacing(true));
      });
    }

    // Move entire layer up in the timeline
    function moveLayerUp(layerIndex) {
      if (layerIndex === 0) return; // Already at top
      saveSnapshot();

      // Swap layers
      const temp = specData.layers[layerIndex];
      specData.layers[layerIndex] = specData.layers[layerIndex - 1];
      specData.layers[layerIndex - 1] = temp;

      // Re-render timeline
      renderTimeline();

      // If an animation was selected, update the selection
      if (selectedAnimation !== null) {
        // Calculate new animation index after the swap
        let animsBefore = 0;
        for (let i = 0; i < layerIndex - 1; i++) {
          animsBefore += specData.layers[i].animations.length;
        }

        // Find which animation in the layer was selected
        let currentIndex = 0;
        let animIndexInLayer = -1;
        for (let lIdx = 0; lIdx < specData.layers.length; lIdx++) {
          const layer = specData.layers[lIdx];
          for (let aIdx = 0; aIdx < layer.animations.length; aIdx++) {
            if (currentIndex === selectedAnimation) {
              if (lIdx === layerIndex) {
                animIndexInLayer = aIdx;
              }
            }
            currentIndex++;
          }
        }

        if (animIndexInLayer !== -1) {
          const newAnimIndex = animsBefore + animIndexInLayer;
          setTimeout(() => {
            showAnimationDetails(newAnimIndex);
            const bar = document.querySelector(`.timeline-bar[data-anim-index="${newAnimIndex}"]`);
            const label = document.querySelector(`.timeline-label.indented[data-anim-index="${newAnimIndex}"]`);
            if (bar) bar.classList.add('selected');
            if (label) label.classList.add('selected');
          }, 0);
        }
      }
    }

    // Move entire layer down in the timeline
    function moveLayerDown(layerIndex) {
      if (layerIndex === specData.layers.length - 1) return; // Already at bottom
      saveSnapshot();

      // Swap layers
      const temp = specData.layers[layerIndex];
      specData.layers[layerIndex] = specData.layers[layerIndex + 1];
      specData.layers[layerIndex + 1] = temp;

      // Re-render timeline
      renderTimeline();

      // If an animation was selected, update the selection
      if (selectedAnimation !== null) {
        // Calculate new animation index after the swap
        let animsBefore = 0;
        for (let i = 0; i < layerIndex; i++) {
          animsBefore += specData.layers[i].animations.length;
        }

        // Find which animation in the layer was selected
        let currentIndex = 0;
        let animIndexInLayer = -1;
        for (let lIdx = 0; lIdx < specData.layers.length; lIdx++) {
          const layer = specData.layers[lIdx];
          for (let aIdx = 0; aIdx < layer.animations.length; aIdx++) {
            if (currentIndex === selectedAnimation) {
              if (lIdx === layerIndex) {
                animIndexInLayer = aIdx;
              }
            }
            currentIndex++;
          }
        }

        if (animIndexInLayer !== -1) {
          const newAnimIndex = animsBefore + specData.layers[layerIndex + 1].animations.length + animIndexInLayer;
          setTimeout(() => {
            showAnimationDetails(newAnimIndex);
            const bar = document.querySelector(`.timeline-bar[data-anim-index="${newAnimIndex}"]`);
            const label = document.querySelector(`.timeline-label.indented[data-anim-index="${newAnimIndex}"]`);
            if (bar) bar.classList.add('selected');
            if (label) label.classList.add('selected');
          }, 0);
        }
      }
    }

    // Move individual animation up within its layer
    function moveAnimationUp(layerIndex, animIndexInLayer) {
      if (animIndexInLayer === 0) return; // Already at top of layer
      saveSnapshot();

      const layer = specData.layers[layerIndex];

      // Swap animations within the layer
      const temp = layer.animations[animIndexInLayer];
      layer.animations[animIndexInLayer] = layer.animations[animIndexInLayer - 1];
      layer.animations[animIndexInLayer - 1] = temp;

      // Re-render timeline
      renderTimeline();

      // Update selection if this animation was selected
      if (selectedAnimation !== null) {
        // Calculate the new global animation index
        let animsBefore = 0;
        for (let i = 0; i < layerIndex; i++) {
          animsBefore += specData.layers[i].animations.length;
        }
        const newAnimIndex = animsBefore + (animIndexInLayer - 1);

        setTimeout(() => {
          showAnimationDetails(newAnimIndex);
          const bar = document.querySelector(`.timeline-bar[data-anim-index="${newAnimIndex}"]`);
          const label = document.querySelector(`.timeline-label.indented[data-anim-index="${newAnimIndex}"]`);
          if (bar) bar.classList.add('selected');
          if (label) label.classList.add('selected');
        }, 0);
      }
    }

    // Move individual animation down within its layer
    function moveAnimationDown(layerIndex, animIndexInLayer) {
      const layer = specData.layers[layerIndex];
      if (animIndexInLayer === layer.animations.length - 1) return; // Already at bottom of layer
      saveSnapshot();

      // Swap animations within the layer
      const temp = layer.animations[animIndexInLayer];
      layer.animations[animIndexInLayer] = layer.animations[animIndexInLayer + 1];
      layer.animations[animIndexInLayer + 1] = temp;

      // Re-render timeline
      renderTimeline();

      // Update selection if this animation was selected
      if (selectedAnimation !== null) {
        // Calculate the new global animation index
        let animsBefore = 0;
        for (let i = 0; i < layerIndex; i++) {
          animsBefore += specData.layers[i].animations.length;
        }
        const newAnimIndex = animsBefore + (animIndexInLayer + 1);

        setTimeout(() => {
          showAnimationDetails(newAnimIndex);
          const bar = document.querySelector(`.timeline-bar[data-anim-index="${newAnimIndex}"]`);
          const label = document.querySelector(`.timeline-label.indented[data-anim-index="${newAnimIndex}"]`);
          if (bar) bar.classList.add('selected');
          if (label) label.classList.add('selected');
        }, 0);
      }
    }

    // Delete parameter row from timeline
    function deleteAnimation(animIndex) {
      if (!specData) return;

      // Find which layer and animation this belongs to
      let currentIndex = 0;
      let layerIndex = -1;
      let animInLayerIndex = -1;

      for (let lIdx = 0; lIdx < specData.layers.length; lIdx++) {
        const layer = specData.layers[lIdx];
        for (let aIdx = 0; aIdx < layer.animations.length; aIdx++) {
          if (currentIndex === animIndex) {
            layerIndex = lIdx;
            animInLayerIndex = aIdx;
            break;
          }
          currentIndex++;
        }
        if (layerIndex !== -1) break;
      }

      if (layerIndex === -1) return;

      const layer = specData.layers[layerIndex];
      const animation = layer.animations[animInLayerIndex];
      const propertyName = animation.property;
      const layerName = layer.layerName;

      // Check if this is the last parameter in the section
      const isLastParam = layer.animations.length === 1;
      const isChildLayer = layer.parenting != null;

      if (isLastParam && !isChildLayer) {
        // For regular layers, prompt to delete entire section when removing last param
        if (!confirm(`This is the last parameter in "${layerName}". Delete this parameter and the entire section?`)) {
          return;
        }
        // Remove the entire layer
        saveSnapshot();
        specData.layers.splice(layerIndex, 1);
      } else {
        // Remove just this animation
        // For child layers, they can exist with no animations (just shows "Attached to Parent")
        saveSnapshot();
        layer.animations.splice(animInLayerIndex, 1);
      }

      // Update the tab's specData to reflect the changes
      setCurrentSpecData(specData);

      // Close detail panel if it exists
      const detailPanel = document.getElementById('detailPanel');
      if (detailPanel) {
        detailPanel.innerHTML = '';
      }
      selectedAnimation = null;
      document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
      document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected'));

      // Sync the changes back to legacy specData variable
      syncLegacyVariables();

      // Save scroll position before re-render
      const timelineOuter = document.querySelector('.timeline-outer-wrapper');
      const scrollTop = timelineOuter ? timelineOuter.scrollTop : 0;

      // Re-render based on current view mode
      refreshActiveView();

      // Restore scroll position and recheck spacing after re-render
      requestAnimationFrame(() => {
        const newTimelineOuter = document.querySelector('.timeline-outer-wrapper');
        if (newTimelineOuter) {
          newTimelineOuter.scrollTop = scrollTop;
        }
        // Force recheck spacing since content was deleted
        requestAnimationFrame(() => updateSectionSpacing(true));
      });
    }

    // Render the default timeline
    // Note: specData is already initialized via syncLegacyVariables() which sets it to tabs[0].specData
    // Don't reassign specData here as it would break the connection to tabs[0].specData
    renderTimeline();

    // Load timeline description for initial tab
    loadTimelineDescription();
  </script>

  <!-- Help tooltips (export only) -->
  <div id="helpScrim" class="help-scrim export-only"></div>
  <div id="helpTooltipPlayhead" class="help-tooltip arrow-down-center export-only">Drag playhead to scrub the video</div>
  <div id="helpTooltipViewMode" class="help-tooltip arrow-up-center export-only">Switch between view modes</div>
  <div id="helpTooltipColorBar" class="help-tooltip arrow-up-center export-only">Click to see animation details</div>
  <div id="helpTooltipSlack" class="help-tooltip arrow-right export-only">Questions? Find us in <a href="https://airbnb.enterprise.slack.com/archives/C0A48KDC0" target="_blank">#motion</a></div>

</body>
</html>
