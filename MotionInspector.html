<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Motion Inspector</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Generator:%20Adobe%20Illustrator%2027.9.0,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%206.00%20Build%200)%20--%3e%3csvg%20version='1.1'%20id='Layer_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%20150%20150'%20style='enable-background:new%200%200%20150%20150;'%20xml:space='preserve'%3e%3cstyle%20type='text/css'%3e%20.st0{fill:%23FF385C;fill-rule:evenodd;clip-rule:evenodd;}%20%3c/style%3e%3cg%20id='Layer_1_00000076594398665045771890000013973700932976003724_'%3e%3cg%3e%3cpath%20class='st0'%20d='M131.3,118c-1.1,7.2-5.9,13.5-12.9,16.2c-3.4,1.3-7.1,1.9-10.7,1.3c-3.6-0.4-7.1-1.6-10.7-3.6%20c-5.1-2.8-10.2-7.2-16-13.5c9.3-11.3,15-21.7,17-31c0.9-4.3,1.2-8.3,0.7-11.9c-0.5-3.5-1.7-6.7-3.8-9.5%20c-4.3-6.3-11.7-9.9-19.8-9.9c-8.2,0-15.6,3.8-19.8,9.9c-1.9,2.8-3.2,6-3.8,9.5c-0.5,3.6-0.4,7.6,0.7,11.9c2.1,9.3,7.9,19.7,17,31%20c-5.8,6.4-10.9,10.7-16,13.5c-3.6,2-7.2,3.2-10.7,3.6c-3.8,0.4-7.4,0-10.7-1.3c-6.8-2.8-11.8-9-12.9-16.2c-0.5-3.6-0.1-7,1.2-10.9%20c0.5-1.3,1.1-2.8,1.9-4.4c1.1-2.3,2.1-4.7,3.2-7l0.1-0.3c9.7-20.9,20.1-42,30.8-62.9l0.4-0.8c1.1-2.1,2.3-4.3,3.4-6.4%20c1.2-2.1,2.4-4.3,4-6.2c3-3.5,6.8-5.2,11.3-5.2c4.4,0,8.3,1.9,11.3,5.2c1.6,1.9,2.8,4,4,6.2c1.1,2.1,2.3,4.3,3.4,6.4l0.4,0.9%20c10.9,20.8,21.2,42,30.8,62.9l0.1,0.1c1.1,2.3,2.1,4.7,3.2,7.1c0.7,1.6,1.3,3.1,1.9,4.4C131.4,111.1,131.8,114.6,131.3,118z%20M74.9,111.6c-7.6-9.7-12.5-18.5-14.2-26c-0.7-3.1-0.9-6-0.5-8.6c0.4-2.1,1.1-4.2,2.3-5.9c2.7-3.8,7.2-6,12.5-6%20c5.1,0,9.8,2.3,12.5,6c1.2,1.7,1.9,3.6,2.3,5.9c0.4,2.5,0.3,5.5-0.5,8.6C87.4,93.1,82.6,102,74.9,111.6z%20M138.5,104.2%20c-0.7-1.7-1.3-3.5-2-5.1c-1.1-2.4-2.1-4.8-3.4-7.2l-0.1-0.1c-9.8-20.9-20.2-42.2-31.1-63.2l-0.4-0.9c-1.1-2.1-2.3-4.3-3.5-6.6%20c-1.3-2.5-3-5.2-5.1-7.8C88.2,8,81.9,5,74.8,5c-7,0-13.4,3-18.1,8.3c-2.1,2.5-3.6,5.2-5.1,7.8c-1.2,2.1-2.3,4.4-3.5,6.6l-0.4,0.8%20C37.1,49.7,26.7,70.8,16.9,91.9l-0.1,0.3c-1.1,2.3-2.1,4.7-3.2,7.1c-0.7,1.6-1.5,3.2-2,5.1c-1.9,5.1-2.4,10.1-1.6,15%20c1.5,10.5,8.6,19.3,18.4,23.3c3.6,1.5,7.5,2.3,11.5,2.3c1.2,0,2.4-0.1,3.8-0.3c4.7-0.5,9.5-2.1,14.1-4.7%20c5.8-3.2,11.4-7.9,17.4-14.5c6.2,6.7,11.8,11.4,17.4,14.5c4.7,2.5,9.4,4.2,14.1,4.7c1.2,0.1,2.4,0.3,3.8,0.3c4,0,7.9-0.8,11.5-2.3%20c9.8-3.9,16.9-12.9,18.4-23.3C140.8,114.4,140.3,109.5,138.5,104.2z'/%3e%3c/g%3e%3c/g%3e%3cg%20id='Dimensions'%3e%3c/g%3e%3c/svg%3e">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    @font-face {
      font-family: 'Airbnb Cereal VF';
      src: url('https://a0.muscache.com/airbnb/static/fonts/CircularAirPro-Book.woff2') format('woff2');
      font-weight: 400;
      font-style: normal;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      padding: 20px 20px 6px 20px;
      overflow: auto;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .container {
      max-width: 100%;
    }

    .header-section {
      padding: 4px 20px 0 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 28px;
    }

    h1 {
      font-family: 'Airbnb Cereal VF', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 24px;
      font-weight: 300;
      margin: 0;
      letter-spacing: 0;
      color: #ffffff;
    }

    h1[contenteditable="true"] {
      cursor: text;
      outline: none;
      padding: 2px 8px;
      margin: -2px -8px;
      border-radius: 4px;
    }

    h1[contenteditable="true"]:hover {
      background: #222222;
      outline: 1px solid #3a3a3a;
      outline-offset: 2px;
    }

    h1[contenteditable="true"]:focus {
      background: #252525;
      outline: 1px solid #4a90e2;
      outline-offset: 2px;
    }

    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .btn {
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }

    .btn-primary {
      background: #4a90e2;
      color: white;
    }

    .btn-primary:hover {
      background: #357abd;
    }

    .btn-secondary {
      background: #333;
      color: #e0e0e0;
      border: 1px solid rgba(85, 85, 85, 0.8);
    }

    .btn-secondary:hover {
      background: #444;
    }

    .btn-circular {
      width: 40px;
      height: 40px;
      padding: 0;
      border: none;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .btn-circular svg {
      display: block;
    }

    .btn-circular::after {
      content: attr(data-tooltip);
      position: absolute;
      top: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      color: #fff;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 10000;
    }

    .btn-circular:hover::after {
      opacity: 1;
    }

    /* View mode segmented control */
    .view-mode-control {
      display: inline-flex;
      background: #2a2a2a;
      border-radius: 20px;
      padding: 4px;
      gap: 4px;
      position: relative;
    }

    .view-mode-btn {
      padding: 8px 16px;
      width: 80px;
      background: transparent;
      border: none;
      color: #888;
      font-size: 13px;
      font-weight: 500;
      line-height: 16px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      box-sizing: border-box;
    }

    .view-mode-btn:first-child {
      border-radius: 16px 0 0 16px;
    }

    /* Create divider with pseudo-element on first button */
    .view-mode-btn:first-child::after {
      content: '';
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 1px;
      height: 20px;
      background: #555;
    }

    /* Hide divider when first button is selected */
    .view-mode-btn:first-child.selected::after {
      display: none;
    }

    /* Hide divider when second button is selected (using ~ general sibling) */
    .view-mode-btn.selected ~ .view-mode-btn:first-child::after,
    .view-mode-btn:first-child:has(~ .view-mode-btn.selected)::after {
      display: none;
    }

    .view-mode-btn:last-child {
      border-radius: 0 16px 16px 0;
    }

    .view-mode-btn:hover {
      background: #3a3a3a;
      border-radius: 16px;
    }

    .view-mode-btn.selected {
      background: #444;
      color: #ffffff;
      border-radius: 16px;
      z-index: 1;
    }

    /* Make emojis in buttons 2px larger */
    .btn-emoji {
      font-size: 15px;
    }

    #videoInput {
      display: none;
    }

    .main-content {
      display: grid;
      grid-template-columns: 448px 20px 1fr;
      gap: 0;
      grid-auto-rows: max-content;
      position: relative;
    }

    .main-content.split-layout {
      grid-template-columns: 1fr 20px 1fr;
    }

    .resize-handle {
      cursor: col-resize;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      user-select: none;
    }

    .resize-handle::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 4px;
      height: 40px;
      background: #4a4a4a;
      border-radius: 2px;
      transition: background 0.2s;
    }

    .resize-handle:hover::before,
    .resize-handle.dragging::before {
      background: #4a90e2;
    }

    .video-section {
      background: #000;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0;
      height: calc(100vh - 110px);
      max-height: calc(100vh - 110px);
      min-width: 448px;
      padding: 48px;
      box-sizing: border-box;
    }

    .video-section:not(:has(video[src])) {
      min-height: calc(100vh - 110px);
    }

    .video-container {
      display: none;
      flex: 1;
      min-height: 0;
    }

    .video-container.has-video {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }

    .video-container.has-video.width-constrained {
      align-items: center;
    }

    .video-wrapper {
      position: relative;
      display: inline-block;
      max-width: 100%;
      padding: 10px;
      background: #282828;
      border-radius: 46px;
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.25);
      line-height: 0;
      box-sizing: border-box;
    }

    video {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 37px;
      background: #000;
      position: relative;
      z-index: 1;
      overflow: hidden;
    }

    .video-overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      width: calc(100% - 20px);
      height: calc(100% - 20px);
      background: rgba(0, 0, 0, 0);
      border-radius: 37px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all 0.1s ease;
      pointer-events: none;
      cursor: pointer;
      z-index: 2;
    }

    .video-wrapper:hover .video-overlay {
      background: rgba(0, 0, 0, 0.8);
      opacity: 1;
      pointer-events: auto;
    }

    .video-replace-btn {
      padding: 8px 16px;
      border-radius: 8px;
      background: #333;
      color: #e0e0e0;
      border: 1px solid #555;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      line-height: 1.5;
      min-height: 38px;
      box-sizing: border-box;
    }

    .video-overlay:hover .video-replace-btn {
      background: #444;
      border-color: #666;
    }

    .video-empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 300px;
      height: 600px;
      border: 2px dashed rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      flex-shrink: 0;
    }

    .video-empty-state:hover {
      border-color: rgba(255, 255, 255, 0.2);
      background: rgba(255, 255, 255, 0.02);
    }

    .video-empty-state.hidden {
      display: none;
    }

    .video-empty-state-btn {
      padding: 8px 16px;
      border-radius: 8px;
      background: #333;
      color: #e0e0e0;
      border: 1px solid #555;
      font-size: 13px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s ease;
      position: relative;
      z-index: 1;
    }

    .video-empty-state:hover .video-empty-state-btn {
      background: #444;
    }

    .playback-controls {
      display: none;
    }

    .timeline-wrapper {
      display: flex;
      flex-direction: column;
      height: calc(100vh - 110px + 25px); /* Add tab height to total height */
      position: relative;
      margin-top: -25px; /* Pull up by tab height so tabs poke above baseline */
    }

    .timeline-section {
      background: #242424;
      border-radius: 8px;
      padding: 16px;
      overflow: visible;
      border: 1px solid #383838;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      position: relative;
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    .timeline-section:has(#timelineContent:empty) {
      min-height: calc(100vh - 110px);
    }

    #timelineContent {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    .playhead-time {
      font-size: 13px;
      color: #7db3ea;
      font-weight: 500;
      height: 44px;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 0 12px;
      border-bottom: 1px solid #333;
      box-sizing: border-box;
      background: #0a0a0a;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .playhead-time #playPauseBtn {
      padding: 0;
      background: #4a90e2;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      color: white;
      cursor: pointer;
      font-size: 11px;
      width: 50px;
      height: 29px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
    }

    .playhead-time #playPauseBtn:hover {
      background: #357abd;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
    }

    .playhead-time #playPauseBtn .icon {
      font-size: 12px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: translate(1px, 1px) scale(0.95);
    }

    .playhead-time #playPauseBtn .icon.pause {
      font-size: 14px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: none;
    }

    .speed-btn {
      padding: 0;
      background: transparent;
      border: none;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 11px;
      font-weight: 400;
      opacity: 0.5;
      transition: all 0.2s;
    }

    .speed-btn:hover {
      opacity: 0.7;
    }

    .speed-btn.selected {
      opacity: 1;
      font-weight: 500;
    }

    /* Zoom controls */
    .zoom-controls {
      position: absolute;
      top: 8px;
      right: 16px;
      display: flex;
      align-items: center;
      background: #2a2a2a;
      border-radius: 6px;
      border: 1px solid #444;
      z-index: 101;
      overflow: visible;
    }

    .zoom-controls::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      right: calc(100% + 1px);
      width: 40px;
      background: linear-gradient(to right, transparent 0%, #0a0a0a 100%);
      pointer-events: none;
    }

    .zoom-btn {
      width: 28px;
      height: 24px;
      background: transparent;
      border: none;
      color: #fff;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .zoom-btn:hover:not(:disabled) {
      background: #3a3a3a;
    }

    .zoom-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .zoom-btn:first-child {
      border-right: 1px solid #444;
    }

    .zoom-duration {
      font-size: 11px;
      color: #fff;
      white-space: nowrap;
      font-variant-numeric: tabular-nums;
      max-width: 0;
      opacity: 0;
      overflow: hidden;
      padding: 0;
      margin: 0;
      border-right: none;
    }

    .zoom-controls:hover .zoom-duration {
      max-width: 160px;
      opacity: 1;
      padding: 0 8px;
      margin-right: 4px;
      border-right: 1px solid #444;
    }

    /* Color picker */
    .color-picker-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      cursor: pointer;
      margin-right: 8px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      transition: border-color 0.15s ease;
      flex-shrink: 0;
    }

    .color-picker-dot:hover {
      border-color: rgba(255, 255, 255, 0.6);
    }

    .color-picker-panel {
      position: absolute;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      display: none;
    }

    .color-picker-panel.visible {
      display: block;
    }

    .color-picker-panel::before {
      content: '';
      position: absolute;
      bottom: -6px;
      left: 62px;
      width: 12px;
      height: 12px;
      background: #2a2a2a;
      border-right: 1px solid #444;
      border-bottom: 1px solid #444;
      transform: rotate(45deg);
    }

    .color-picker-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 12px;
    }

    .color-option {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.15s ease;
      border: 2px solid transparent;
    }

    .color-option:hover {
      transform: scale(1.1);
    }

    .color-option.selected {
      border-color: rgba(255, 255, 255, 0.8);
      box-shadow: 0 0 0 2px #2a2a2a, 0 0 0 4px rgba(255, 255, 255, 0.3);
    }

    /* Easing autocomplete dropdown */
    .easing-autocomplete {
      position: absolute;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      display: none;
      min-width: 200px;
      max-height: 300px;
      overflow-y: auto;
    }

    .easing-autocomplete.visible {
      display: block;
    }

    .easing-autocomplete-item {
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 4px;
      font-size: 12px;
      color: #e0e0e0;
      transition: background 0.15s ease;
      font-family: 'SFMono-Regular', ui-monospace, Menlo, Monaco, 'Roboto Mono', monospace;
    }

    .easing-autocomplete-item:hover {
      background: #3a3a3a;
    }

    .easing-autocomplete-item.spring-preset {
      color: #9fd4ff;
    }

    .easing-autocomplete-item.curve-preset {
      color: #ffb38a;
    }

    /* ===== TABS STYLING ===== */
    .tabs-container {
      position: relative;
      z-index: 100;
      margin-bottom: -1px; /* Overlap border with timeline-section */
    }

    .tabs-bar {
      display: flex;
      gap: 4px;
      background: transparent;
      align-items: flex-end;
      position: relative;
      padding-left: 24px; /* Align tabs with timeline content */
    }

    .tabs-bar-left {
      display: flex;
      gap: 4px;
      align-items: flex-end;
    }

    .tab {
      position: relative;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 12px;
      background: #2a2a2a;
      border: none;
      border-bottom: 1px solid #383838;
      border-radius: 6px 6px 0 0;
      cursor: pointer;
      transition: background 0.15s ease, box-shadow 0.15s ease;
      min-width: 100px;
      max-width: 200px;
      z-index: 1;
      height: 26px;
      box-sizing: border-box;
      box-shadow: inset 0 -4px 6px -3px rgba(0, 0, 0, 0.25);
    }

    .tab.active {
      background: #242424;
      border: 1px solid #383838;
      border-bottom-color: #242424;
      z-index: 10;
      box-shadow: none;
    }

    .tab:hover:not(.active) {
      background: #333;
    }

    .tab-name {
      flex: 1;
      color: #888;
      font-size: 11px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
      user-select: none;
      outline: none;
      padding: 2px 4px;
      border-radius: 3px;
    }

    .tab-name[contenteditable="true"] {
      user-select: text;
      background: rgba(255, 255, 255, 0.1);
      cursor: text;
    }

    .tab.active .tab-name {
      color: #d0d0d0;
    }

    .tab-close {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      background: transparent;
      border: none;
      color: #888;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      padding: 0;
      flex-shrink: 0;
      margin-left: 16px;
      margin-right: -6px;
    }

    .tab-close:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }

    .tab-add-btn {
      position: relative;
      padding: 0;
      background: transparent;
      border: none;
      color: #888;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.15s ease;
      min-width: auto;
      height: 26px;
      width: 26px;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1;
      margin-left: 0;
      top: -1px;
    }

    .tab-add-btn:hover {
      color: #fff;
    }
    /* ===== END TABS STYLING ===== */

    /* DevTools-style timeline */
    .timeline-container {
      display: grid;
      grid-template-columns: 180px 1fr;
      gap: 0;
      border-radius: 6px;
      overflow-y: auto;
      overflow-x: hidden;
      border: 1px solid rgba(255, 255, 255, 0.12);
      flex: 1;
      min-height: 0;
      position: relative;
    }

    .timeline-content-column {
      position: relative;
      box-shadow: inset -6px -6px 14px -4px rgba(0, 0, 0, 0.25);
      background: #1a1a1a;
    }

    /* Dark theme scrollbar styling */
    .timeline-container::-webkit-scrollbar {
      width: 12px;
    }

    .timeline-container::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 0 6px 6px 0;
    }

    .timeline-container::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 6px;
      border: 2px solid #1a1a1a;
    }

    .timeline-container::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    .timeline-labels-column {
      background: #0a0a0a;
    }

    .timeline-bottom-divider {
      border-top: 1px solid #4a4a4a;
      margin-top: 15px;
      height: 15px;
      position: relative;
    }

    .timeline-bottom-track {
      border-top: 1px solid #4a4a4a;
      margin-top: 15px;
      height: 15px;
      border-bottom: none;
    }

    .timeline-bottom-track .table-cell {
      border-right: none !important;
    }

    .timeline-ruler {
      position: sticky;
      top: 0;
      height: 44px;
      background: #0a0a0a;
      border-bottom: 1px solid #333;
      margin-bottom: 0;
      box-sizing: border-box;
      padding-right: 80px;
      z-index: 100;
    }

    .timeline-tick {
      font-size: 11px;
      color: #e0e0e0;
      padding-left: 6px;
      display: flex;
      align-items: center;
      height: 100%;
      white-space: nowrap;
    }

    .timeline-rows {
      position: relative;
    }

    .timeline-row {
      min-height: 32px;
      border-bottom: 1px solid #1a1a1a;
      position: relative;
    }

    .timeline-row:hover .timeline-label,
    .timeline-row:hover .timeline-track {
      background: #282828;
    }

    /* Table mode hover effect */
    body.table-view-active .timeline-label.table-hover {
      background: #121212;
    }

    body.table-view-active .timeline-track.table-row.table-hover,
    body.table-view-active .timeline-track.table-row.table-hover .table-cell {
      background: #1e1e1e;
    }

    .timeline-label.layer-header {
      background: transparent;
      font-weight: 600;
      border-bottom: 1px solid #1a1a1a;
      height: 32px;
    }

    .timeline-track.layer-header {
      background: transparent;
      font-weight: 600;
      border-bottom: 1px solid #2a2a2a;
      height: 32px;
    }

    .timeline-label.layer-header.has-divider,
    .timeline-track.layer-header.has-divider {
      border-top: 1px solid #4a4a4a;
      padding-top: 8px;
      margin-top: 15px;
    }

    .timeline-label.layer-header:hover {
      background: transparent;
    }

    .timeline-track.layer-header:hover {
      background: transparent;
    }

    .timeline-label {
      padding: 8px 12px;
      font-size: 12px;
      color: #e0e0e0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      white-space: nowrap;
      overflow: visible;
      text-overflow: ellipsis;
      height: 32px;
      border-bottom: 1px solid #1a1a1a;
      position: relative;
      box-sizing: border-box;
      cursor: grab;
    }

    .timeline-label:active {
      cursor: grabbing;
    }

    .timeline-label-text {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: #e0e0e0;
    }

    .timeline-label-text[contenteditable="true"] {
      outline: 1px solid #3a3a3a;
      outline-offset: 2px;
      background: #252525;
      padding: 2px 4px;
      margin: -2px -4px;
      border-radius: 3px;
      cursor: text;
      overflow: visible;
      white-space: normal;
    }

    .timeline-label:hover .timeline-label-text {
      color: #ffffff;
    }

    .timeline-label-add-btn {
      position: absolute;
      right: 8px;
      bottom: 0;
      transform: translateY(50%);
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #2a2a2a;
      border: 1px solid #555;
      color: #ccc;
      font-size: 16px;
      font-weight: bold;
      line-height: 23px;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      transition: all 0.15s ease;
      pointer-events: auto;
    }

    .timeline-label-add-btn.visible {
      display: flex;
    }

    .timeline-label-add-btn:hover {
      background: #4a4a4a;
      border-color: #666;
      color: #fff;
    }

    /* Section divider add button */
    .section-divider-add-btn {
      position: absolute;
      left: 50%;
      top: 0;
      transform: translate(-50%, -50%);
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #2a2a2a;
      border: 1px solid #555;
      color: #ccc;
      font-size: 16px;
      font-weight: bold;
      line-height: 23px;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      transition: all 0.15s ease;
      pointer-events: auto;
    }

    .section-divider-add-btn.visible {
      display: flex;
    }

    .section-divider-add-btn:hover {
      background: #4a4a4a;
      border-color: #666;
      color: #fff;
    }

    .timeline-label.dragging {
      opacity: 0.5;
    }

    .timeline-bar.dragging-vertical {
      opacity: 0.5;
      cursor: grabbing !important;
    }

    /* Drop indicators - only on labels, extended to span full timeline width */
    .timeline-label.drag-over-top::before,
    .timeline-label.drag-over-bottom::after {
      content: '';
      position: absolute;
      left: 0;
      right: -3000px; /* Extend across entire timeline width */
      height: 2px;
      background: #4a90e2;
      z-index: 1000;
      pointer-events: none;
    }

    /* Track indicators for label-based dragging */
    .timeline-track.drag-over-top::before,
    .timeline-track.drag-over-bottom::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: #4a90e2;
      z-index: 1000;
      pointer-events: none;
    }

    .timeline-label.drag-over-top::before,
    .timeline-track.drag-over-top::before {
      top: -1px;
    }

    .timeline-label.drag-over-bottom::after,
    .timeline-track.drag-over-bottom::after {
      bottom: -1px;
    }

    .timeline-bottom-divider.drag-over-top,
    .timeline-bottom-track.drag-over-top {
      border-top-color: #4a90e2;
      border-top-width: 2px;
    }

    .timeline-label.indented {
      padding-left: 32px;
      color: #b0b0b0;
      position: relative;
    }

    .timeline-label.indented.selected {
      color: #ffffff;
      font-weight: 600;
    }

    /* Red circle button for parameters */
    .param-action-btn {
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: rgba(231, 76, 60, 0.15);
      border: 1px solid rgba(231, 76, 60, 0.4);
      cursor: pointer;
      opacity: 0;
      pointer-events: none;
      padding: 0;
      transition: opacity 0.2s ease, background 0.15s ease, border-color 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: #e74c3c;
      line-height: 1;
    }

    .param-action-btn::before {
      content: 'Ã—';
      font-weight: bold;
      position: relative;
      top: 0.5px;
    }

    .param-action-btn:hover {
      background: rgba(231, 76, 60, 0.25);
      border-color: rgba(231, 76, 60, 0.6);
    }

    .param-action-btn.visible {
      opacity: 1;
      pointer-events: auto;
    }

    /* Hide delete button when dragging */
    .timeline-label.dragging .param-action-btn {
      opacity: 0;
      pointer-events: none;
    }

    .timeline-track {
      position: relative;
      height: 32px;
      border-bottom: 1px solid #2a2a2a;
      display: flex;
      align-items: center;
      padding-right: 80px;
      margin-right: -80px;
      overflow: visible; /* Changed from hidden to allow drop indicators to extend */
      box-sizing: border-box;
    }

    .table-row {
      display: grid;
      grid-template-columns: minmax(220px, 1fr) 80px 80px var(--table-easing-width, 200px);
      align-items: center;
      padding: 0 12px;
      padding-right: 0;
      margin-right: 0;
      column-gap: 0;
    }

    .timeline-ruler.table-row {
      display: grid;
      grid-template-columns: minmax(220px, 1fr) 80px 80px var(--table-easing-width, 200px);
      padding-right: 0;
    }

    .timeline-track.table-row {
      display: grid;
      grid-template-columns: minmax(220px, 1fr) 80px 80px var(--table-easing-width, 200px);
      padding-right: 0;
      margin-right: 0;
    }

    .table-cell {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      height: 100%;
      font-size: 12px;
      padding: 0 12px;
      box-sizing: border-box;
      user-select: text;
      cursor: text;
    }

    .table-cell.editable-cell[contenteditable="true"] {
      cursor: text;
      outline: none;
    }

    .table-cell.editable-cell[contenteditable="true"]:focus {
      background: #252525;
      outline: 1px solid #3a3a3a;
      outline-offset: -1px;
    }

    .table-cell.editable-cell[contenteditable="true"]:hover:not(:focus) {
      background: #222222;
    }

    .table-cell--desc {
      display: flex;
      align-items: center;
      height: 100%;
      padding-left: 0;
      padding-right: 12px;
      border-right: 1px solid #2a2a2a;
      color: #c0c0c0;
      white-space: normal;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .table-desc-text {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      line-height: 1.4;
      word-break: break-word;
      overflow-wrap: anywhere;
      max-height: calc(1.4em * 2);
      width: 100%;
    }

    .table-cell--delay,
    .table-cell--duration {
      border-right: 1px solid #2a2a2a;
      color: #c0c0c0;
    }

    .table-cell--easing {
      color: #c0c0c0;
      font-size: 11px;
      font-family: monospace;
      white-space: nowrap;
      padding-right: 12px;
    }

    .table-cell--easing .num {
      color: #6DB3E8;
    }

    .table-row--header .table-cell {
      font-weight: 600;
      color: #e0e0e0;
      font-family: inherit;
      font-size: 12px;
    }

    .table-row--header .table-cell--easing {
      font-size: 12px;
      font-family: inherit;
    }

    .table-row--layer .table-cell {
      font-weight: 600;
      color: inherit;
      border-right: 1px solid #2a2a2a;
    }

    .table-row--layer .table-cell:last-child {
      border-right: none;
    }

    .table-row:not(.table-row--header) .table-desc-text {
      font-family: 'SFMono-Regular', ui-monospace, Menlo, Monaco, 'Roboto Mono', monospace;
      font-size: 11px;
      color: #c0c0c0;
    }

    .table-row:not(.table-row--header) .table-cell--delay,
    .table-row:not(.table-row--header) .table-cell--duration,
    .table-row:not(.table-row--header) .table-cell--easing {
      font-family: 'SFMono-Regular', ui-monospace, Menlo, Monaco, 'Roboto Mono', monospace;
      font-size: 11px;
      color: #c0c0c0;
    }

    .timeline-track.table-row.table-row--layer {
      margin-top: 0;
      padding-top: 0;
      border-top: none;
    }

    .timeline-track.table-row.table-row--layer.has-divider {
      margin-top: 15px;
      padding-top: 0;
      border-top: 1px solid #4a4a4a;
    }

    body.table-view-active .timeline-label.layer-header.has-divider {
      margin-top: 15px;
      padding-top: 0;
      border-top: 1px solid #4a4a4a;
    }

    body.table-view-active .timeline-label.layer-header {
      border-bottom: 1px solid #1a1a1a;
      padding: 0 12px;
    }

    body.table-view-active .timeline-label {
      height: 32px;
      border-bottom: 1px solid #1a1a1a;
      box-sizing: border-box;
    }

    body.table-view-active .timeline-label.layer-header {
      border-bottom: 1px solid #1a1a1a;
    }

    body.table-view-active .timeline-label.indented {
      padding-left: 32px;
      border-bottom: 1px solid #1a1a1a;
    }

    body.table-view-active .timeline-track.table-row {
      height: 32px;
    }

    .table-gap-label {
      height: 8px;
      min-height: 8px;
      border-top: none;
      border-bottom: none;
      background: #0a0a0a;
      padding: 0;
      cursor: default;
      display: flex;
      align-items: center;
    }

    .table-gap-row {
      height: 8px;
      min-height: 8px !important;
      border-top: 1px solid #1a1a1a;
      border-bottom: none !important;
    }

    .table-gap-row .table-cell {
      padding: 0;
      border-right: 1px solid #2a2a2a;
      height: 100%;
      min-height: inherit;
    }

    .table-gap-row .table-cell:last-child {
      border-right: none;
    }

    .timeline-bar {
      position: absolute;
      height: 24px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      padding: 0 8px;
      font-size: 11px;
      color: white;
      cursor: grab;
      transition: all 0.1s;
      z-index: 1;
      white-space: nowrap;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.12);
    }

    .timeline-bar:active {
      cursor: grabbing;
    }

    .timeline-bar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 6px;
      pointer-events: none;
      z-index: 10;
    }

    .timeline-bar:hover,
    .timeline-bar.dragging-resize {
      filter: brightness(1.2);
      z-index: 1;
    }

    .timeline-bar.selected {
      filter: brightness(1.2);
      z-index: 2;
      box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.4);
    }

    .timeline-bar.selected.bar-spring {
      box-shadow: none;
    }

    .timeline-bar.selected.bar-spring::before {
      background: rgba(255, 255, 255, 0.4);
      padding: 2px;
    }

    .timeline-bar-text {
      position: relative;
      z-index: 5;
    }

    .timeline-bar-text[contenteditable="true"] {
      cursor: grab;
      outline: none;
      user-select: none;
      white-space: nowrap;
    }

    .timeline-bar-text[contenteditable="true"]:focus {
      cursor: text;
      user-select: text;
      outline: 1px solid #4a90e2;
      outline-offset: 2px;
      background: #252525;
      border-radius: 3px;
      padding: 2px 4px;
      margin: -2px -4px;
    }

    /* Resize handles */
    .timeline-bar-resize-handle {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 8px;
      cursor: ew-resize !important;
      z-index: 15;
    }

    .timeline-bar-resize-handle.left {
      left: 0;
    }

    .timeline-bar-resize-handle.right {
      right: 0;
    }

    /* Text fade overlays - match each bar's background color */
    .timeline-bar.has-text-overflow::after {
      content: '';
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 40px;
      pointer-events: none;
      z-index: 10;
      border-radius: 0 6px 6px 0;
    }

    .timeline-bar.has-text-overflow.bar-opacity::after {
      background: linear-gradient(to right, rgba(4, 92, 69, 0) 0%, rgba(4, 92, 69, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-scale::after {
      background: linear-gradient(to right, rgba(168, 41, 104, 0) 0%, rgba(168, 41, 104, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-rotation::after {
      background: linear-gradient(to right, rgba(104, 34, 133, 0) 0%, rgba(104, 34, 133, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-position-x::after,
    .timeline-bar.has-text-overflow.bar-position-y::after {
      background: linear-gradient(to right, rgba(4, 92, 125, 0) 0%, rgba(4, 92, 125, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-width::after,
    .timeline-bar.has-text-overflow.bar-height::after {
      background: linear-gradient(to right, rgba(4, 92, 69, 0) 0%, rgba(4, 92, 69, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-blur::after {
      background: linear-gradient(to right, rgba(74, 74, 74, 0) 0%, rgba(74, 74, 74, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-transform::after {
      background: linear-gradient(to right, rgba(90, 23, 120, 0) 0%, rgba(90, 23, 120, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-default::after {
      background: linear-gradient(to right, rgba(4, 76, 125, 0) 0%, rgba(4, 76, 125, 1) 100%);
    }

    /* Property-specific colors */
    .bar-opacity { background: #045c45; }
    .bar-scale { background: #a82968; }
    .bar-rotation { background: #682285; }
    .bar-position-x { background: #045c7d; }
    .bar-position-y { background: #045c7d; }
    .bar-width { background: #045c45; }
    .bar-height { background: #045c45; }
    .bar-blur { background: #4a4a4a; }
    .bar-transform { background: #5a1778; }
    .bar-default { background: #044c7d; }

    /* Spring gradient fade-out */
    .bar-spring.bar-opacity { background: linear-gradient(90deg, #045c45 0%, #045c45 50%, rgba(4, 92, 69, 0) 100%); }
    .bar-spring.bar-scale { background: linear-gradient(90deg, #a82968 0%, #a82968 50%, rgba(168, 41, 104, 0) 100%); }
    .bar-spring.bar-rotation { background: linear-gradient(90deg, #682285 0%, #682285 50%, rgba(104, 34, 133, 0) 100%); }
    .bar-spring.bar-position-x { background: linear-gradient(90deg, #045c7d 0%, #045c7d 50%, rgba(4, 92, 125, 0) 100%); }
    .bar-spring.bar-position-y { background: linear-gradient(90deg, #045c7d 0%, #045c7d 50%, rgba(4, 92, 125, 0) 100%); }
    .bar-spring.bar-width { background: linear-gradient(90deg, #045c45 0%, #045c45 50%, rgba(4, 92, 69, 0) 100%); }
    .bar-spring.bar-height { background: linear-gradient(90deg, #045c45 0%, #045c45 50%, rgba(4, 92, 69, 0) 100%); }
    .bar-spring.bar-blur { background: linear-gradient(90deg, #4a4a4a 0%, #4a4a4a 50%, rgba(74, 74, 74, 0) 100%); }
    .bar-spring.bar-transform { background: linear-gradient(90deg, #5a1778 0%, #5a1778 50%, rgba(90, 23, 120, 0) 100%); }
    .bar-spring.bar-default { background: linear-gradient(90deg, #044c7d 0%, #044c7d 50%, rgba(4, 76, 125, 0) 100%); }

    /* Spring bars - remove base box-shadow, use gradient border instead */
    .bar-spring { box-shadow: none; }

    /* Spring gradient borders that fade out with the fill */
    .bar-spring::before {
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0);
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.12) 50%, rgba(255, 255, 255, 0) 100%);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      padding: 1px;
    }

    .playhead {
      position: fixed;
      width: 2px;
      background: #4a90e2;
      z-index: 200;
      cursor: ew-resize;
      box-shadow: -2px 0 0 0 #242424, 2px 0 0 0 #242424;
      pointer-events: none;
    }

    .playhead::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: -10px;
      right: -10px;
      cursor: ew-resize;
      pointer-events: auto;
    }


    .playhead-handle {
      position: absolute;
      top: -11.5px; /* Vertically center at bottom of 44px row */
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 8px;
      background: #4a90e2;
      color: #ffffff;
      font-size: 11px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      cursor: ew-resize;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      pointer-events: auto;
      transition: all 0.2s;
      white-space: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }

    .playhead-handle:hover {
      background: #357abd;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.5);
    }

    .detail-panel {
      margin-top: 20px;
      padding: 14px 20px 20px 20px;
      background: #2a2a2a;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-left-width: 3px;
      font-size: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      flex-shrink: 0;
      position: relative;
      z-index: 400;
    }

    .detail-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .detail-panel-title {
      font-weight: 700;
      color: #ffffff;
      font-size: 14px;
      display: flex;
      align-items: center;
      position: relative;
    }

    .detail-title-input {
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      padding: 2px 6px;
      margin-left: -2px;
      font-size: 14px;
      font-weight: 700;
      color: #ffffff;
      font-family: inherit;
      outline: none;
      transition: border-color 0.2s, background-color 0.2s;
      box-sizing: border-box;
      max-width: 200px;
      min-width: 40px;
    }

    .detail-title-input:hover {
      border-color: #555;
      background: rgba(255, 255, 255, 0.03);
    }

    .detail-title-input:focus {
      border-color: #4a90e2;
      background: rgba(255, 255, 255, 0.05);
    }

    .detail-title-input-property {
      margin-left: 2px;
    }

    .detail-panel-close {
      background: #333;
      border: none;
      color: #e0e0e0;
      font-size: 16px;
      cursor: pointer;
      padding: 0;
      padding-top: 2px;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s;
    }

    .detail-panel-close:hover {
      background: #444;
    }

    .detail-panel-actions {
      display: flex;
      gap: 14px;
      align-items: center;
    }

    .detail-panel-action-btn {
      background: #333;
      border: 1px solid #555;
      color: #e0e0e0;
      font-size: 12px;
      cursor: pointer;
      padding: 6px 12px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      transition: all 0.2s;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      gap: 4px;
    }

    .detail-panel-action-btn:hover {
      background: #444;
      border-color: #666;
    }

    .detail-panel-action-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .detail-panel-action-btn:disabled:hover {
      background: #333;
      border-color: #555;
    }

    .detail-panel-action-btn .arrow {
      font-size: 10px;
    }

    .detail-panel-action-btn.delete {
      background: #333;
      border-color: #664444;
      font-size: 12px;
      font-weight: 500;
      padding: 6px 10px;
      color: #e0e0e0;
    }

    .detail-panel-action-btn.delete:hover {
      background: #444;
      border-color: #775555;
      color: #ffffff;
    }

    .detail-panel-action-btn.delete:disabled:hover {
      background: #333;
      border-color: #664444;
      color: #e0e0e0;
    }

    .detail-panel-separator {
      color: #666;
      font-size: 12px;
      margin: 0 4px;
    }

    .detail-description {
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid #333;
      font-size: 13px;
      color: #ffffff;
    }

    .detail-description-input {
      width: 100%;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      padding: 6px 8px;
      margin-left: -8px;
      font-size: 13px;
      color: #ffffff;
      font-family: inherit;
      outline: none;
      transition: border-color 0.2s, background-color 0.2s;
      box-sizing: border-box;
    }

    .detail-description-input:hover {
      border-color: #555;
      background: rgba(255, 255, 255, 0.03);
    }

    .detail-description-input:focus {
      border-color: #4a90e2;
      background: rgba(255, 255, 255, 0.05);
    }

    .detail-value-input {
      width: 100%;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      padding: 4px 6px;
      margin-left: -6px;
      font-size: 12px;
      color: #ffffff;
      font-family: 'SFMono-Regular', ui-monospace, Menlo, Monaco, 'Roboto Mono', monospace;
      outline: none;
      transition: border-color 0.2s, background-color 0.2s;
      box-sizing: border-box;
      white-space: normal;
      word-wrap: break-word;
      overflow-wrap: break-word;
      min-height: 24px;
      resize: none;
    }

    .detail-value-input:hover {
      border-color: #555;
      background: rgba(255, 255, 255, 0.03);
    }

    .detail-value-input:focus {
      border-color: #4a90e2;
      background: rgba(255, 255, 255, 0.05);
    }

    .detail-value-input.invalid {
      border-color: #a82929;
    }

    /* Scrollbar styling for textarea inputs */
    .detail-value-input::-webkit-scrollbar {
      width: 8px;
    }

    .detail-value-input::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 4px;
    }

    .detail-value-input::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 4px;
      border: 2px solid #1a1a1a;
    }

    .detail-value-input::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    .detail-grid {
      display: grid;
      grid-template-columns: 1fr 1fr 1.5fr 1fr 1fr;
      gap: 20px;
      align-items: start;
    }

    .detail-item {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .detail-label {
      color: #999;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      font-weight: 600;
    }

    .detail-value {
      color: #e0e0e0;
      font-weight: 400;
      font-size: 13px;
      line-height: 1.4;
    }

    .spring-params, .bezier-curve {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 13px;
      line-height: 1.4;
      color: #e0e0e0;
    }

    .bezier-curve {
      color: #e0e0e0;
    }

    .spring-link {
      color: #e0e0e0;
      text-decoration: underline;
      cursor: pointer;
      transition: color 0.2s;
    }

    .spring-link:hover {
      color: #ffffff;
    }

    .empty-state {
      padding: 40px 20px;
      color: #666;
      opacity: 0.4;
    }

    .empty-timeline-ruler {
      height: 32px;
      background: #1f1f1f;
      border-bottom: 1px solid #333;
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 60px;
      font-size: 11px;
      color: #555;
    }

    .empty-timeline-tracks {
      padding: 20px;
    }

    .empty-timeline-row {
      display: flex;
      align-items: center;
      height: 32px;
      margin-bottom: 8px;
    }

    .empty-timeline-label {
      width: 150px;
      height: 24px;
      background: #222;
      border-radius: 4px;
      margin-right: 20px;
    }

    .empty-timeline-bar {
      height: 24px;
      background: #252525;
      border-radius: 4px;
      flex: 1;
      max-width: 70%;
    }

    /* Edit/Read Mode System */
    body[data-mode="read"] .edit-only {
      display: none !important;
    }

    body[data-mode="edit"] .read-only {
      display: none !important;
    }

    body[data-mode="read"] .timeline-label,
    body[data-mode="read"] .timeline-label:active,
    body[data-mode="read"] .timeline-bar,
    body[data-mode="read"] .timeline-bar:active {
      cursor: default !important;
    }

    .export-only {
      display: none !important;
    }

    /* Adjust grid layout in read mode when resize handle is hidden */
    body[data-mode="read"] .main-content {
      grid-template-columns: 448px 1fr;
      gap: 20px;
    }

  </style>
</head>
<body>
  <div class="container">
    <div class="header-section">
      <h1 id="pageTitle" contenteditable="false">Motion Inspector</h1>
      <div class="controls">
        <input type="file" id="videoInput" accept="video/*" class="edit-only main-only">
        <div class="view-mode-control">
          <button class="view-mode-btn selected" data-view="timeline" onclick="switchToView('timeline')">Timeline</button>
          <button class="view-mode-btn" data-view="table" onclick="switchToView('table')">Table</button>
        </div>
        <button class="btn btn-secondary edit-only main-only" onclick="pasteSpec()">
          <span class="btn-emoji">ðŸ“‹</span>&nbsp;&nbsp;Paste Spec
        </button>
        <button class="btn btn-secondary edit-only main-only" onclick="exportZip()">
          <span class="btn-emoji">ðŸ“¦</span>&nbsp;&nbsp;Export Zip
        </button>
      </div>
    </div>

    <div class="main-content">
      <div class="video-section">
        <div id="videoEmptyState" class="video-empty-state edit-only" onclick="document.getElementById('videoInput').click()">
          <div class="video-empty-state-btn">
            <span>ðŸ“</span>
            <span>Add Video</span>
          </div>
        </div>
        <div id="videoContainer" class="video-container">
          <div class="video-wrapper">
            <video id="videoPlayer"></video>
            <div class="video-overlay edit-only" onclick="document.getElementById('videoInput').click()">
              <div class="video-replace-btn">
                <span>ðŸ“</span>
                <span>Replace Video</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="resize-handle edit-only" id="resizeHandle"></div>

      <div class="timeline-wrapper">
        <div class="tabs-container">
          <div class="tabs-bar">
            <!-- Tabs will be rendered here by JavaScript -->
          </div>
        </div>
        <div class="timeline-section">
          <div id="timelineContent"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== TABS DATA STRUCTURE =====
    // Create default spec template
    function createDefaultSpec() {
      return {
        compName: "Motion Inspector",
        workArea: {
          duration: 2000
        },
        layers: [
          {
            layerName: "Section 1",
            animations: [
              {
                property: "Add parameter",
                description: "Add description",
                timing: {
                  delay: 0,
                  duration: 300
                },
                easing: {
                  type: "-",
                  cubicBezier: ""
                },
                values: {
                  formatted: {
                    startValue: "-",
                    endValue: "-"
                  }
                }
              }
            ]
          }
        ]
      };
    }

    // Initialize with Tab 1
    const initialSpec = createDefaultSpec();
    groupAnimations(initialSpec);
    let tabs = [
      {
        id: 1,
        name: "Tab 1",
        specData: initialSpec,
        videoSrc: null,
        uploadedVideoFile: null
      }
    ];
    let currentTabIndex = 0; // Start with Tab 1 active
    let nextTabId = 2;
    const MAX_TABS = 6;

    // Helper functions to get current tab data
    function getCurrentTab() {
      if (currentTabIndex === -1) return null;
      return tabs[currentTabIndex];
    }

    function getCurrentSpecData() {
      if (currentTabIndex === -1) return null;
      return tabs[currentTabIndex].specData;
    }

    function getCurrentVideoSrc() {
      if (currentTabIndex === -1) return null;
      return tabs[currentTabIndex].videoSrc;
    }

    function setCurrentSpecData(data) {
      if (currentTabIndex === -1) return;
      tabs[currentTabIndex].specData = data;
    }

    function setCurrentVideoSrc(src) {
      if (currentTabIndex === -1) return;
      tabs[currentTabIndex].videoSrc = src;
    }

    function setCurrentUploadedVideoFile(file) {
      if (currentTabIndex === -1) return;
      tabs[currentTabIndex].uploadedVideoFile = file;
    }

    // Sync legacy variables with current tab
    function syncLegacyVariables() {
      if (currentTabIndex === -1) {
        specData = null;
        uploadedVideoFile = null;
      } else {
        specData = getCurrentSpecData();
        uploadedVideoFile = tabs[currentTabIndex].uploadedVideoFile;
      }
    }

    // Maintain legacy references for backward compatibility
    let specData = initialSpec; // Start with Tab 1's spec
    let uploadedVideoFile = null;
    let videoDuration = 0;
    let isDraggingPlayhead = false;
    let selectedAnimation = null;
    const isExportMode = false;
    let isEditMode = true; // Can be toggled in exported files
    let animationFrameId = null;
    let lastDraggedSpecTimeMs = null;
    let viewDuration = null; // Current zoom level (visible duration in ms)
    let lastDraggedVideoTime = null;
    let justFinishedDragging = false;
    let pendingVideoSeek = null;
    let videoSeekScheduled = false;
    let viewMode = 'timeline'; // 'timeline' or 'table'
    let savedVideoSectionWidth = null;

    // Hide main-only buttons in exported files
    if (isExportMode) {
      document.querySelectorAll('.main-only').forEach(el => el.style.display = 'none');
    }

    // Video timing offset in milliseconds (adjust this to sync video with timeline)
    // Positive values shift timeline markers earlier (if video content appears late)
    const VIDEO_OFFSET_MS = 30;

    const video = document.getElementById('videoPlayer');

    // ===== TAB MANAGEMENT FUNCTIONS =====

    // Create a new tab
    function createNewTab() {
      if (tabs.length >= MAX_TABS) {
        alert(`Maximum of ${MAX_TABS} tabs allowed`);
        return;
      }

      // Add a new tab
      const newTabSpec = createDefaultSpec();
      // Copy Tab 1's title to maintain global title across all tabs
      if (tabs.length > 0 && tabs[0].specData && tabs[0].specData.compName) {
        newTabSpec.compName = tabs[0].specData.compName;
      }

      const newTab = {
        id: nextTabId++,
        name: `Tab ${tabs.length + 1}`,
        specData: newTabSpec,
        videoSrc: null,
        uploadedVideoFile: null
      };
      groupAnimations(newTab.specData);
      tabs.push(newTab);
      switchTab(tabs.length - 1); // Switch to new tab

      renderTabs();
    }

    // Delete a tab
    function deleteTab(index) {
      // Can't delete the last tab
      if (tabs.length === 1) {
        alert("Cannot delete the last tab");
        return;
      }

      const tab = tabs[index];
      if (!confirm(`Delete "${tab.name}"?`)) {
        return;
      }

      tabs.splice(index, 1);

      // If deleting current tab, switch to first tab
      if (index === currentTabIndex) {
        currentTabIndex = 0;
        switchTab(0);
      } else if (index < currentTabIndex) {
        // Adjust current index if tab before it was deleted
        currentTabIndex--;
      }

      renderTabs();
    }

    // Switch to a different tab
    function switchTab(index) {
      if (index === currentTabIndex) return;

      // Close info box
      const detailPanel = document.getElementById('detailPanel');
      if (detailPanel) {
        detailPanel.innerHTML = '';
      }
      selectedAnimation = null;
      document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
      document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected'));

      // Switch tab
      currentTabIndex = index;

      // Sync legacy variables
      syncLegacyVariables();

      // Reset playhead to 0
      currentTime = 0;

      // Reset zoom level
      viewDuration = null;

      // Update video element (only if src changed to avoid reload flash)
      const videoElement = document.getElementById('videoPlayer');
      const videoSrc = getCurrentVideoSrc();
      const videoWrapper = document.querySelector('.video-wrapper');
      let videoSrcChanged = false;

      if (videoElement) {
        const currentSrc = videoElement.src;
        const newSrc = videoSrc || '';

        // Only update src if it actually changed
        if (currentSrc !== newSrc) {
          // Hide video wrapper during load to prevent dimension flash
          if (videoWrapper) {
            videoWrapper.style.visibility = 'hidden';
          }

          videoElement.src = newSrc;
          videoSrcChanged = true;

          // Show wrapper once new video is loaded
          if (newSrc) {
            const showVideo = () => {
              if (videoWrapper) {
                videoWrapper.style.visibility = 'visible';
              }
              updateVideoAlignment();
              videoElement.removeEventListener('loadedmetadata', showVideo);
            };
            videoElement.addEventListener('loadedmetadata', showVideo, { once: true });
          } else {
            // No video, show wrapper immediately
            if (videoWrapper) {
              videoWrapper.style.visibility = 'visible';
            }
          }
        } else if (videoSrc) {
          // Same video - just reset to beginning without reload
          videoElement.currentTime = 0;
          // Update alignment immediately since it's the same video
          if (videoElement.readyState >= 1) {
            updateVideoAlignment();
          }
        }
      }

      // Update video container visibility
      const emptyState = document.getElementById('videoEmptyState');
      const videoContainer = document.getElementById('videoContainer');
      if (videoSrc) {
        if (emptyState) emptyState.classList.add('hidden');
        if (videoContainer) videoContainer.classList.add('has-video');
      } else {
        if (emptyState) emptyState.classList.remove('hidden');
        if (videoContainer) videoContainer.classList.remove('has-video');
      }

      // Update page title (always use Tab 1's title)
      const pageTitle = document.getElementById('pageTitle');
      const tab1Spec = tabs.length > 0 ? tabs[0].specData : null;
      if (pageTitle && tab1Spec && tab1Spec.compName) {
        pageTitle.textContent = tab1Spec.compName;
        document.title = tab1Spec.compName;
      } else if (pageTitle) {
        pageTitle.textContent = 'Motion Inspector';
        document.title = 'Motion Inspector';
      }

      // Re-render appropriate view
      refreshActiveView();
      renderTabs();

      // Update playhead position
      if (typeof updatePlayhead === 'function') {
        updatePlayhead();
      }
    }

    // Rename a tab
    function renameTab(index, newName) {
      if (newName.trim() === '') return;
      tabs[index].name = newName.trim();
      renderTabs();
    }

    // Render the tabs bar
    function renderTabs() {
      const tabsBar = document.querySelector('.tabs-bar');
      if (!tabsBar) return;

      let tabsHtml = '';
      let addBtnHtml = '';

      // Render existing tabs
      tabs.forEach((tab, index) => {
        const isActive = index === currentTabIndex;
        const showCloseBtn = tabs.length > 1; // Only show close button when multiple tabs exist
        tabsHtml += `
          <div class="tab ${isActive ? 'active' : ''}" data-tab-index="${index}">
            <span class="tab-name">${tab.name}</span>
            ${showCloseBtn ? `<button class="tab-close edit-only" onclick="event.stopPropagation(); deleteTab(${index})">Ã—</button>` : ''}
          </div>
        `;
      });

      // Add + button if under limit
      if (tabs.length < MAX_TABS) {
        const initialClass = tabs.length === 0 ? 'initial' : '';
        addBtnHtml = `<button class="tab-add-btn edit-only ${initialClass}" onclick="createNewTab()">+</button>`;
      }

      // Always wrap tabs in tabs-bar-left for consistent layout
      tabsBar.innerHTML = `<div class="tabs-bar-left">${tabsHtml}</div>${addBtnHtml}`;

      // Add click listeners for tab switching
      document.querySelectorAll('.tab').forEach(tab => {
        const tabIndex = parseInt(tab.dataset.tabIndex);
        tab.addEventListener('click', (e) => {
          // Don't switch if clicking close button or editing name
          if (e.target.classList.contains('tab-close') ||
              e.target.classList.contains('tab-name') && e.target.getAttribute('contenteditable') === 'true') {
            return;
          }
          switchTab(tabIndex);
        });
      });

      // Add double-click listeners for renaming
      document.querySelectorAll('.tab-name').forEach(tabName => {
        const tab = tabName.closest('.tab');
        const tabIndex = parseInt(tab.dataset.tabIndex);

        tabName.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          const originalName = tabs[tabIndex].name;

          // Make editable
          tabName.setAttribute('contenteditable', 'true');
          tabName.focus();

          // Select all text
          const range = document.createRange();
          range.selectNodeContents(tabName);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);

          // Handle blur (when user clicks away)
          const handleBlur = () => {
            tabName.setAttribute('contenteditable', 'false');
            const newName = tabName.textContent.trim();
            if (newName === '' || newName === originalName) {
              tabName.textContent = originalName;
            } else {
              renameTab(tabIndex, newName);
            }
            tabName.removeEventListener('blur', handleBlur);
          };

          // Handle Enter key (finish editing)
          const handleKeydown = (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              tabName.blur();
              tabName.removeEventListener('keydown', handleKeydown);
            } else if (e.key === 'Escape') {
              e.preventDefault();
              tabName.textContent = originalName;
              tabName.blur();
              tabName.removeEventListener('keydown', handleKeydown);
            }
          };

          tabName.addEventListener('blur', handleBlur);
          tabName.addEventListener('keydown', handleKeydown);
        });
      });
    }

    // Helper to refresh the active view (timeline or table)
    function refreshActiveView() {
      // Don't render if no tabs exist
      if (currentTabIndex === -1) return;

      // Use global viewMode
      if (viewMode === 'table') {
        switchToTableView();
      } else {
        if (typeof renderTimeline === 'function') {
          renderTimeline();
        }
      }

      // Update view mode buttons
      document.querySelectorAll('.view-mode-btn').forEach(btn => {
        btn.classList.remove('selected');
      });
      const selectedBtn = document.querySelector(`.view-mode-btn[data-view="${viewMode}"]`);
      if (selectedBtn) {
        selectedBtn.classList.add('selected');
      }
    }

    // ===== END TAB MANAGEMENT FUNCTIONS =====

    // Update the UI mode (edit vs read)
    function updateMode() {
      const mode = isEditMode ? 'edit' : 'read';
      document.body.setAttribute('data-mode', mode);

      // Update page title editability
      const pageTitle = document.getElementById('pageTitle');
      if (pageTitle) {
        pageTitle.contentEditable = isEditMode;
      }
    }

    // Toggle between edit and read modes
    function toggleEditMode() {
      isEditMode = !isEditMode;
      updateMode();
      // Re-render timeline to update draggable attributes and buttons
      if (specData) {
        renderTimeline();
      }
    }

    // Initialize mode on page load
    updateMode();

    // Initialize tabs
    syncLegacyVariables();
    renderTabs();

    // Setup page title editing
    const pageTitle = document.getElementById('pageTitle');
    if (pageTitle) {
      // Store original value on focus
      pageTitle.addEventListener('focus', (e) => {
        pageTitle.dataset.originalValue = pageTitle.textContent.trim();
        // Select all text on focus
        const range = document.createRange();
        range.selectNodeContents(pageTitle);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
      });

      // Handle Enter and Escape keys
      pageTitle.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          pageTitle.blur();
        } else if (e.key === 'Escape') {
          // Restore original value
          pageTitle.textContent = pageTitle.dataset.originalValue || 'Motion Inspector';
          pageTitle.blur();
        }
      });

      // Save changes on blur
      pageTitle.addEventListener('blur', (e) => {
        let newTitle = pageTitle.textContent.trim();

        // If empty, restore original
        if (!newTitle) {
          newTitle = pageTitle.dataset.originalValue || 'Motion Inspector';
          pageTitle.textContent = newTitle;
        }

        // Update ALL tabs' compName to maintain global title
        tabs.forEach(tab => {
          if (tab.specData) {
            tab.specData.compName = newTitle;
          }
        });
        if (specData) {
          specData.compName = newTitle;
        }

        // Update document title
        document.title = newTitle;

        // Clear selection when blurring
        window.getSelection().removeAllRanges();
      });

      // Clear selection when clicking outside the title
      document.addEventListener('mousedown', (e) => {
        if (!pageTitle.contains(e.target)) {
          window.getSelection().removeAllRanges();
        }
      });
    }

    // Throttled video seek using RAF to prevent multiple competing seeks
    function scheduleVideoSeek(targetTime) {
      pendingVideoSeek = targetTime;

      if (!videoSeekScheduled) {
        videoSeekScheduled = true;
        requestAnimationFrame(() => {
          if (pendingVideoSeek !== null) {
            video.currentTime = pendingVideoSeek;
            pendingVideoSeek = null;
          }
          videoSeekScheduled = false;
        });
      }
    }

    // Video upload handler
    // Check if video is width-constrained and update alignment
    function updateVideoAlignment() {
      const videoContainer = document.getElementById('videoContainer');
      const videoWrapper = document.querySelector('.video-wrapper');
      const videoOverlay = document.querySelector('.video-overlay');
      if (!videoContainer || !videoWrapper || !video || !video.videoWidth) return;

      const containerWidth = videoContainer.clientWidth;
      if (containerWidth <= 0) return;

      const aspectRatio = video.videoWidth / video.videoHeight;
      if (!Number.isFinite(aspectRatio) || aspectRatio <= 0) return;

      // Detect if video is square or landscape (wider)
      const isSquareOrWider = aspectRatio >= 1;

      // Use smaller bezel and rounding for square/landscape videos
      const bezelPadding = isSquareOrWider ? 10 : 20; // 5px or 10px padding on each side
      const videoBorderRadius = isSquareOrWider ? 8 : 37;
      const bezelBorderRadius = isSquareOrWider ? 13 : 46;

      // Adjust video section padding for landscape videos
      const videoSection = document.querySelector('.video-section');
      if (videoSection) {
        videoSection.style.padding = isSquareOrWider ? '24px' : '48px';
      }

      const viewportMaxHeight = Math.max(0, window.innerHeight - 110);
      const containerHeight = videoContainer.clientHeight;
      const heightLimits = [];

      if (viewportMaxHeight > 0) heightLimits.push(viewportMaxHeight);
      if (containerHeight > 0) heightLimits.push(containerHeight);

      // Start with max available width for the video (excluding bezel)
      let videoWidth = containerWidth - bezelPadding;
      let videoHeight = videoWidth / aspectRatio;

      // Check if height constraint is exceeded
      if (heightLimits.length) {
        const maxAllowedHeight = Math.min(...heightLimits);
        if (videoHeight > maxAllowedHeight) {
          videoHeight = maxAllowedHeight;
          videoWidth = videoHeight * aspectRatio;
        }
      }

      if (!Number.isFinite(videoWidth) || !Number.isFinite(videoHeight) || videoWidth <= 0 || videoHeight <= 0) {
        return;
      }

      // Set wrapper size to video size + bezel padding
      const wrapperWidth = videoWidth + bezelPadding;
      const wrapperHeight = videoHeight + bezelPadding;

      videoWrapper.style.width = `${wrapperWidth}px`;
      videoWrapper.style.height = `${wrapperHeight}px`;

      // Apply border radius based on aspect ratio
      videoWrapper.style.borderRadius = `${bezelBorderRadius}px`;
      video.style.borderRadius = `${videoBorderRadius}px`;

      // Update bezel padding
      const paddingPx = bezelPadding / 2;
      videoWrapper.style.padding = `${paddingPx}px`;

      // Update overlay positioning to match bezel padding
      if (videoOverlay) {
        videoOverlay.style.borderRadius = `${videoBorderRadius}px`;
        videoOverlay.style.top = `${paddingPx}px`;
        videoOverlay.style.left = `${paddingPx}px`;
        videoOverlay.style.width = `calc(100% - ${bezelPadding}px)`;
        videoOverlay.style.height = `calc(100% - ${bezelPadding}px)`;
      }

      // If video is using full container width (within 5px threshold), it's width-constrained
      if (Math.abs(containerWidth - wrapperWidth) < 5) {
        videoContainer.classList.add('width-constrained');
      } else {
        videoContainer.classList.remove('width-constrained');
      }

      if (viewMode === 'table') {
        requestAnimationFrame(updateTableEasingWidth);
      }
    }

    const videoInput = document.getElementById('videoInput');
    if (videoInput) {
      videoInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const url = URL.createObjectURL(file);

          // If no tabs exist, create the first tab
          if (tabs.length === 0) {
            const newTab = {
              id: nextTabId++,
              name: `Tab 1`,
              specData: createDefaultSpec(),
              videoSrc: url,
              uploadedVideoFile: file
            };
            groupAnimations(newTab.specData);
            tabs.push(newTab);
            currentTabIndex = 0;
            syncLegacyVariables();
            renderTabs();
          } else {
            // Store for current tab
            setCurrentUploadedVideoFile(file);
            uploadedVideoFile = file; // Also update legacy variable
            setCurrentVideoSrc(url);
          }

          video.src = url;

          // Hide empty state and show video container when video is loaded
          const emptyState = document.getElementById('videoEmptyState');
          if (emptyState) {
            emptyState.classList.add('hidden');
          }
          const videoContainer = document.getElementById('videoContainer');
          if (videoContainer) {
            videoContainer.classList.add('has-video');
          }

          video.addEventListener('loadedmetadata', () => {
            videoDuration = video.duration * 1000; // Convert to ms
            // Ensure video starts at exactly 0
            video.currentTime = 0;
            if (getCurrentSpecData()) {
              renderTimeline();
          }
          // Check alignment after video loads
          setTimeout(() => {
            updateVideoAlignment();
            if (viewMode === 'table') {
              updateTableEasingWidth();
            }
          }, 100);
        });
      }
    });
    }

    // Update alignment on window resize
    window.addEventListener('resize', () => {
      updateVideoAlignment();
      if (viewMode === 'table') {
        requestAnimationFrame(updateTableEasingWidth);
      }
    });

    // Resize handle functionality
    const resizeHandle = document.getElementById('resizeHandle');
    const mainContent = document.querySelector('.main-content');
    let isResizing = false;
    let startX = 0;
    let startWidth = 448;

    if (resizeHandle) {
      resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startWidth = document.querySelector('.video-section').offsetWidth;
        resizeHandle.classList.add('dragging');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
      });

      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;

        const deltaX = e.clientX - startX;
        const newWidth = startWidth + deltaX;
        const containerWidth = mainContent.offsetWidth;
        const minWidth = 448;
        const handleWidth = 20;
        const maxWidth = (containerWidth - handleWidth) / 2;

        // Clamp width between min and max
        const clampedWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));

        // Update grid column
        mainContent.style.gridTemplateColumns = `${clampedWidth}px 20px 1fr`;

        // Update playhead position during resize
        requestAnimationFrame(() => {
          updatePlayhead();
          updateVideoAlignment();
          if (viewMode === 'table') {
            updateTableEasingWidth();
          }
        });
      });

      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          resizeHandle.classList.remove('dragging');
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
          updateVideoAlignment();
          if (viewMode === 'table') {
            updateTableEasingWidth();
          }
        }
      });
    }

    // Play/pause toggle
    function togglePlayPause() {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (video.paused) {
        video.play();
        if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon pause">â¸</span>';
        startPlayheadAnimation();
      } else {
        video.pause();
        if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon">â–¶</span>';
        stopPlayheadAnimation();
      }
    }

    // Set playback speed
    function setPlaybackSpeed(speed) {
      video.playbackRate = speed;

      // Update button states
      document.querySelectorAll('.speed-btn').forEach(btn => {
        btn.classList.remove('selected');
      });

      const selectedBtn = document.querySelector(`.speed-btn[data-speed="${speed}"]`);
      if (selectedBtn) {
        selectedBtn.classList.add('selected');
      }
    }

    // Duration controls - extend/shorten timeline
    function zoomIn() {
      if (!specData) return;

      // Extend timeline duration by 100ms
      specData.workArea.duration += 100;

      // Reset view duration to show full timeline
      viewDuration = null;

      renderTimeline();
    }

    function zoomOut() {
      if (!specData) return;

      // Shorten timeline duration by 100ms (minimum 100ms)
      const newDuration = Math.max(100, specData.workArea.duration - 100);
      specData.workArea.duration = newDuration;

      // Reset view duration to show full timeline
      viewDuration = null;

      renderTimeline();
    }

    // Toggle layout between vertical (400px | 1fr) and 50/50 split
    function toggleLayout() {
      const mainContent = document.querySelector('.main-content');
      mainContent.classList.toggle('split-layout');

      // Update button emoji based on current state
      const toggleBtn = event.currentTarget;
      if (mainContent.classList.contains('split-layout')) {
        // Now in 50/50 split, show desktop emoji
        toggleBtn.innerHTML = '<span class="btn-emoji">ðŸ–¥ï¸</span>&nbsp;&nbsp;Toggle Layout';
      } else {
        // Now in narrow layout, show smartphone emoji
        toggleBtn.innerHTML = '<span class="btn-emoji">ðŸ“±</span>&nbsp;&nbsp;Toggle Layout';
      }

      // Update playhead position after layout change
      requestAnimationFrame(() => {
        updatePlayhead();
        updateVideoAlignment();
        if (viewMode === 'table') {
          updateTableEasingWidth();
        }
      });
    }

    // Smooth playhead animation using RAF
    function animatePlayhead() {
      if (!isDraggingPlayhead && !video.paused) {
        updatePlayhead();
        updateTimeDisplays();
        animationFrameId = requestAnimationFrame(animatePlayhead);
      }
    }

    function startPlayheadAnimation() {
      if (animationFrameId === null) {
        animationFrameId = requestAnimationFrame(animatePlayhead);
      }
    }

    function stopPlayheadAnimation() {
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    }

    // Video events
    video.addEventListener('play', () => {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon pause">â¸</span>';
      startPlayheadAnimation();
    });

    video.addEventListener('pause', () => {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon">â–¶</span>';
      stopPlayheadAnimation();
    });

    video.addEventListener('ended', () => {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon">â–¶</span>';
      stopPlayheadAnimation();
    });

    // Update time displays
    function updateTimeDisplays() {
      // If we just finished dragging, use the stored position instead of recalculating
      let specTimeMs;
      if (justFinishedDragging && lastDraggedSpecTimeMs !== null) {
        specTimeMs = lastDraggedSpecTimeMs;
      } else {
        // Calculate spec time as direct time mapping (not percentage-based)
        specTimeMs = video.currentTime * 1000; // Convert to milliseconds
      }

      const playheadTimeDisplay = document.getElementById('playheadTimeDisplay');
      if (playheadTimeDisplay) {
        playheadTimeDisplay.textContent = `${specTimeMs.toFixed(0)}ms`;
      }
    }

    // Update playhead position
    function updatePlayhead() {
      // Don't update position during or right after dragging - user has direct control
      if (isDraggingPlayhead || justFinishedDragging) return;

      const playhead = document.querySelector('.playhead');
      const timelineContainer = document.querySelector('.timeline-container');
      const timelineContent = document.querySelector('.timeline-content-column');

      if (playhead && timelineContainer && timelineContent) {
        const positionPercent = getTimelinePosition(video.currentTime);
        const containerRect = timelineContainer.getBoundingClientRect();
        const contentRect = timelineContent.getBoundingClientRect();

        // Calculate pixel position relative to viewport
        const leftPosition = contentRect.left + (positionPercent / 100 * contentRect.width);
        playhead.style.left = `${leftPosition}px`;
        playhead.style.top = `${containerRect.top + 44}px`;
        playhead.style.bottom = `${window.innerHeight - containerRect.bottom}px`;
      }
    }

    // Paste spec from clipboard
    async function pasteSpec() {
      try {
        const text = await navigator.clipboard.readText();
        console.log('Clipboard text:', text);
        const data = JSON.parse(text);

        // If no tabs exist, create the first tab
        if (tabs.length === 0) {
          const newTab = {
            id: nextTabId++,
            name: `Tab 1`,
            specData: data,
            videoSrc: null,
            uploadedVideoFile: null
          };
          groupAnimations(newTab.specData);
          tabs.push(newTab);
          currentTabIndex = 0;
          syncLegacyVariables();
        } else {
          // Update current tab's spec
          setCurrentSpecData(data);
          specData = data; // Also update legacy variable
          groupAnimations(getCurrentSpecData()); // Group matching X/Y Position and Width/Height
        }

        viewDuration = null; // Reset zoom level for new spec

        // Update page title only if pasting into Tab 1 (global title)
        const pageTitle = document.getElementById('pageTitle');
        if (pageTitle && data.compName && currentTabIndex === 0) {
          pageTitle.textContent = data.compName;
          document.title = data.compName;
          // Update ALL tabs' compName to maintain global title
          tabs.forEach(tab => {
            if (tab.specData) {
              tab.specData.compName = data.compName;
            }
          });
        }

        renderTimeline();
        renderTabs(); // Update tabs display
      } catch (err) {
        alert('Failed to paste or parse JSON.\n\nError: ' + err.message + '\n\nCheck the browser console for more details.');
        console.error('Parse error:', err);
        console.error('Clipboard content:', await navigator.clipboard.readText());
      }
    }

    // Copy spec JSON to clipboard (for exported files)
    async function copySpecJson() {
      try {
        // Export only current tab's spec
        const currentSpec = getCurrentSpecData();
        const jsonString = JSON.stringify(currentSpec, null, 2);
        await navigator.clipboard.writeText(jsonString);
        alert('Spec JSON copied to clipboard!\n\nYou can paste this into MotionInspector.html to edit.');
      } catch (err) {
        alert('Failed to copy to clipboard: ' + err.message);
        console.error(err);
      }
    }

    // Switch between timeline and table view modes
    function switchToView(view) {
      // Update global view mode
      viewMode = view;

      // Update button states
      document.querySelectorAll('.view-mode-btn').forEach(btn => {
        btn.classList.remove('selected');
      });
      const selectedBtn = document.querySelector(`.view-mode-btn[data-view="${view}"]`);
      if (selectedBtn) {
        selectedBtn.classList.add('selected');
      }

      // Switch view
      if (view === 'table') {
        switchToTableView();
      } else {
        switchToTimelineView();
      }
    }

    // Switch to table view
    function switchToTableView() {
      console.log('[TABLE] Switching to table view');
      document.body.classList.add('table-view-active');
      const videoSection = document.querySelector('.video-section');
      const mainContent = document.querySelector('.main-content');
      const timelineContent = document.getElementById('timelineContent');

      console.log('[TABLE] timelineContent:', timelineContent);

      // Save current video section width
      savedVideoSectionWidth = videoSection.offsetWidth;
      console.log('[TABLE] Saved video section width:', savedVideoSectionWidth);

      // Set video section to minimum width
      // Check if in edit mode (has resize handle) or read mode (no resize handle)
      if (isEditMode) {
        mainContent.style.gridTemplateColumns = '448px 20px 1fr';
      } else {
        mainContent.style.gridTemplateColumns = '448px 1fr';
      }

      // Clear timeline content (will be replaced with table)
      timelineContent.innerHTML = '';
      console.log('[TABLE] Cleared timeline content');

      // Render table
      renderTableView();
      requestAnimationFrame(() => {
        updateVideoAlignment();
        updateTableEasingWidth();
        syncTableRowHeights();
      });
      console.log('[TABLE] Table rendered');
    }

    // Switch back to timeline view
    function switchToTimelineView() {
      console.log('[TABLE] Switching back to timeline view');
      document.body.classList.remove('table-view-active');
      const mainContent = document.querySelector('.main-content');
      const timelineContent = document.getElementById('timelineContent');

      // Restore video section width
      if (savedVideoSectionWidth) {
        // Check if in edit mode (has resize handle) or read mode (no resize handle)
        if (isEditMode) {
          mainContent.style.gridTemplateColumns = `${savedVideoSectionWidth}px 20px 1fr`;
        } else {
          mainContent.style.gridTemplateColumns = `${savedVideoSectionWidth}px 1fr`;
        }
        console.log('[TABLE] Restored video section width:', savedVideoSectionWidth);
      }

      // Clear table content
      timelineContent.innerHTML = '';
      console.log('[TABLE] Cleared table content');

      // Re-render timeline
      const contentColumn = document.querySelector('.timeline-content-column');
      if (contentColumn) {
        contentColumn.style.removeProperty('--table-easing-width');
      }

      document.querySelectorAll('.timeline-label').forEach((label) => {
        label.style.removeProperty('height');
        label.style.removeProperty('min-height');
      });

      renderTimeline();
      requestAnimationFrame(() => updateVideoAlignment());
      console.log('[TABLE] Timeline re-rendered');
    }

    function updateTableEasingWidth() {
      if (viewMode !== 'table') return;

      const contentColumn = document.querySelector('.timeline-content-column');
      if (!contentColumn) return;

      const easingCells = contentColumn.querySelectorAll('.table-cell--easing');
      if (!easingCells.length) return;

      let requiredWidth = 200;

      contentColumn.style.setProperty('--table-easing-width', 'max-content');

      easingCells.forEach((cell) => {
        const cellWidth = Math.ceil(cell.scrollWidth);
        if (cellWidth > requiredWidth) {
          requiredWidth = cellWidth;
        }
      });

      requiredWidth = Math.max(200, Math.min(requiredWidth, 520));
      contentColumn.style.setProperty('--table-easing-width', `${requiredWidth}px`);
      requestAnimationFrame(syncTableRowHeights);
    }

    function syncTableRowHeights() {
      if (viewMode !== 'table') return;

      const leftRows = Array.from(document.querySelectorAll('.timeline-labels-column .timeline-label'));
      const rightRows = Array.from(document.querySelectorAll('.timeline-content-column .timeline-track.table-row'));

      if (!leftRows.length || leftRows.length !== rightRows.length) return;

      // Clear all inline height styles to let CSS control them
      leftRows.forEach((row) => {
        row.style.removeProperty('height');
        row.style.removeProperty('min-height');
      });

      rightRows.forEach((row) => {
        row.style.removeProperty('height');
        row.style.removeProperty('min-height');
      });

      requestAnimationFrame(() => {
        leftRows.forEach((leftRow, index) => {
          const rightRow = rightRows[index];
          if (!rightRow) return;

          const isGapRow = leftRow.classList.contains('table-gap-label') || rightRow.classList.contains('table-gap-row');
          if (isGapRow) {
            // Gap rows use CSS height (8px), no inline styles needed
            return;
          }

          const height = Math.max(leftRow.offsetHeight, rightRow.offsetHeight, 32);
          leftRow.style.height = `${height}px`;
          leftRow.style.minHeight = `${height}px`;
          rightRow.style.height = `${height}px`;
          rightRow.style.minHeight = `${height}px`;
        });
      });
    }

    // Helper function to wrap numbers in spans for styling
    function wrapNumbers(text) {
      // Match numbers (including decimals and negatives)
      return text.replace(/(-?\d+\.?\d*)/g, '<span class="num">$1</span>');
    }

    // Helper function to format easing preset names (springs and curves) with hyperlinks
    function formatSpringPreset(text) {
      const presetLinks = {
        // Spring presets
        'Standard Spring': 'https://air.bb/standard-spring',
        'Slow Spring': 'https://air.bb/slow-spring',
        'Fast Spring': 'https://air.bb/fast-spring',
        'Slow Bounce Spring': 'https://air.bb/slow-bounce-spring',
        'Medium Bounce Spring': 'https://air.bb/medium-bounce-spring',
        'Fast Bounce Spring': 'https://air.bb/fast-bounce-spring',
        // Curve presets
        'Standard Curve': 'https://air.bb/standard-curve',
        'Enter Curve': 'https://air.bb/enter-curve',
        'Exit Curve': 'https://air.bb/exit-curve'
      };

      // Check if text matches a preset name (case-insensitive)
      const trimmedText = text.trim();
      for (const [presetName, link] of Object.entries(presetLinks)) {
        if (trimmedText.toLowerCase() === presetName.toLowerCase()) {
          return `<a href="${link}" target="_blank" rel="noopener noreferrer" class="spring-link">${presetName}</a>`;
        }
      }

      // Not a preset, wrap numbers in the text
      return wrapNumbers(text);
    }

    // Easing autocomplete functionality
    let easingAutocomplete = null;
    let autocompleteTarget = null;

    function createEasingAutocomplete() {
      const presets = [
        { name: 'Standard Spring', type: 'spring' },
        { name: 'Slow Spring', type: 'spring' },
        { name: 'Fast Spring', type: 'spring' },
        { name: 'Slow Bounce Spring', type: 'spring' },
        { name: 'Medium Bounce Spring', type: 'spring' },
        { name: 'Fast Bounce Spring', type: 'spring' },
        { name: 'Standard Curve', type: 'curve' },
        { name: 'Enter Curve', type: 'curve' },
        { name: 'Exit Curve', type: 'curve' }
      ];

      // Create dropdown if it doesn't exist
      if (!easingAutocomplete) {
        easingAutocomplete = document.createElement('div');
        easingAutocomplete.className = 'easing-autocomplete';
        document.body.appendChild(easingAutocomplete);
      }

      return { dropdown: easingAutocomplete, presets };
    }

    function showEasingAutocomplete(inputElement, filterText = '') {
      const { dropdown, presets } = createEasingAutocomplete();
      autocompleteTarget = inputElement;

      // Check if input is in info box (detail panel)
      const isInInfoBox = inputElement.closest('#detailPanel') !== null;

      // Always show all presets (no filtering)
      let filtered = [...presets];

      // Reverse order for info box (curves first, then springs)
      if (isInInfoBox) {
        filtered = filtered.reverse();
      }

      // Build dropdown HTML
      let html = '';
      filtered.forEach(preset => {
        const className = preset.type === 'spring' ? 'spring-preset' : 'curve-preset';
        html += `<div class="easing-autocomplete-item ${className}" data-preset="${preset.name}">${preset.name}</div>`;
      });

      dropdown.innerHTML = html;

      // Show dropdown first to get its height
      dropdown.classList.add('visible');

      // Position the dropdown
      const rect = inputElement.getBoundingClientRect();
      dropdown.style.left = (rect.left + window.scrollX) + 'px';

      // Use fixed width for consistent sizing
      dropdown.style.minWidth = '220px';
      dropdown.style.width = '220px';

      if (isInInfoBox) {
        // Position above the input for info box
        const dropdownHeight = dropdown.offsetHeight;
        dropdown.style.top = (rect.top + window.scrollY - dropdownHeight - 4) + 'px';
        dropdown.style.bottom = 'auto';
      } else {
        // Position below the input for table mode
        dropdown.style.top = (rect.bottom + window.scrollY + 4) + 'px';
        dropdown.style.bottom = 'auto';
      }

      // Use event delegation on the dropdown itself (prevents duplicate listeners)
      dropdown.onclick = (e) => {
        const item = e.target.closest('.easing-autocomplete-item');
        if (!item) return;

        e.preventDefault();
        e.stopPropagation();

        const presetName = item.dataset.preset;
        console.log('Selected preset:', presetName, 'Element type:', inputElement.tagName);

        hideEasingAutocomplete();

        // Determine if this is a spring or curve preset
        const springPresets = ['Standard Spring', 'Slow Spring', 'Fast Spring', 'Slow Bounce Spring', 'Medium Bounce Spring', 'Fast Bounce Spring'];
        const isSpring = springPresets.includes(presetName);

        // Set the value and trigger save based on element type
        if (inputElement.tagName === 'TEXTAREA' || inputElement.tagName === 'INPUT') {
          // For info box elements, extract animIndex from the onblur handler
          const onblurAttr = inputElement.getAttribute('onblur');
          const match = onblurAttr.match(/updateAnimationField\((\d+),\s*'easing'/);
          if (match) {
            const animIndex = parseInt(match[1]);
            console.log('Extracted animIndex:', animIndex);

            // Find the animation in specData
            let currentIndex = 0;
            for (let layerIndex = 0; layerIndex < specData.layers.length; layerIndex++) {
              const layer = specData.layers[layerIndex];
              for (let animIdx = 0; animIdx < layer.animations.length; animIdx++) {
                if (currentIndex === animIndex) {
                  const anim = layer.animations[animIdx];

                  // Update duration based on preset type
                  if (isSpring) {
                    // Spring: set duration to "-"
                    anim.timing.duration = '-';
                    anim.durationUserSet = true;
                  } else {
                    // Curve: if duration is "-" or not set, use default 300ms
                    if (anim.timing.duration === '-' || anim.timing.duration === undefined || anim.timing.duration === null) {
                      anim.timing.duration = 300;
                      anim.durationUserSet = true;
                    }
                    // If duration is already a number, keep it
                  }

                  break;
                }
                currentIndex++;
              }
            }

            // Update easing field
            updateAnimationField(animIndex, 'easing', presetName);
          }
        } else {
          // Contenteditable DIV (table mode)
          const row = inputElement.closest('.table-row');
          const layerIndex = parseInt(row.dataset.layerIndex);
          const animIndex = parseInt(row.dataset.animIndex);

          inputElement.textContent = presetName;
          console.log('Set contenteditable to:', inputElement.textContent);

          // Manually trigger save for table mode
          const layer = specData.layers[layerIndex];
          if (layer) {
            const anim = layer.animations[animIndex];
            if (anim) {
              anim.customEasing = presetName;

              // Update duration based on preset type
              if (isSpring) {
                // Spring: set duration to "-"
                anim.timing.duration = '-';
                anim.durationUserSet = true;
              } else {
                // Curve: if duration is "-" or not set, use default 300ms
                if (anim.timing.duration === '-' || anim.timing.duration === undefined || anim.timing.duration === null) {
                  anim.timing.duration = 300;
                  anim.durationUserSet = true;
                }
                // If duration is already a number, keep it
              }

              console.log('Saved to specData:', presetName);
              renderTableView();
            }
          }
        }
      };
    }

    function hideEasingAutocomplete() {
      if (easingAutocomplete) {
        easingAutocomplete.classList.remove('visible');
        autocompleteTarget = null;
      }
    }

    // Close autocomplete when clicking outside
    document.addEventListener('mousedown', (e) => {
      // Check if clicking on an easing field (which would open the autocomplete)
      const isEasingTextarea = e.target.tagName === 'TEXTAREA' &&
                               e.target.classList.contains('detail-value-input');
      const isEasingCell = e.target.dataset && e.target.dataset.field === 'easing';
      const isEasingField = isEasingTextarea || isEasingCell;

      if (easingAutocomplete &&
          easingAutocomplete.classList.contains('visible') &&
          !easingAutocomplete.contains(e.target) &&
          !isEasingField) {
        hideEasingAutocomplete();
      }
    });

    // Render table view
    function renderTableView() {
      console.log('[TABLE] renderTableView called');
      if (!specData) {
        console.log('[TABLE] No specData, returning');
        return;
      }

      const timelineContent = document.getElementById('timelineContent');

      // Build table view HTML - must match timeline structure exactly
      let html = '';

      // Timeline container
      html += `<div class="timeline-container">`;

      // ===== LEFT COLUMN - Keep exactly the same as timeline =====
      html += `<div class="timeline-labels-column" style="border-right: 1px solid #2a2a2a;">`;

      // Top section - playhead-time (44px) - matches timeline-ruler height
      html += `<div class="playhead-time" style="cursor: default;">
      </div>`;

      // Labels - exactly the same as timeline mode
      specData.layers.forEach((layer, layerIndex) => {
        // Layer header label
        const dividerClass = layerIndex > 0 ? ' has-divider' : '';
        html += `<div class="timeline-label layer-header${dividerClass}"
                      data-row-type="layer"
                      data-layer-index="${layerIndex}"
                      draggable="${isEditMode}"
                      data-drag-type="layer"
                      data-is-section-divider="${layerIndex > 0 ? 'true' : 'false'}">
          <span class="timeline-label-text">${layer.layerName}</span>
          <button class="timeline-label-add-btn edit-only" draggable="false">+</button>
          ${layerIndex > 0 ? '<button class="section-divider-add-btn edit-only" draggable="false">+</button>' : ''}
        </div>`;

        // Animation labels
        layer.animations.forEach((anim, animIndexInLayer) => {
          // Calculate global animation index
          let globalAnimIndex = 0;
          for (let i = 0; i < layerIndex; i++) {
            globalAnimIndex += specData.layers[i].animations.length;
          }
          globalAnimIndex += animIndexInLayer;

          html += `<div class="timeline-label indented"
                        data-row-type="animation"
                        data-layer-index="${layerIndex}"
                        data-anim-index="${animIndexInLayer}"
                        draggable="${isEditMode}"
                        data-drag-type="animation"
                        data-anim-in-layer="${animIndexInLayer}">
            <span class="timeline-label-text">${anim.property}</span>
            <button class="param-action-btn edit-only" draggable="false"></button>
            <button class="timeline-label-add-btn edit-only" draggable="false">+</button>
          </div>`;
        });
      });

      // Bottom section divider for adding new sections at the end
      html += `<div class="timeline-bottom-divider">
        <button class="section-divider-add-btn edit-only" draggable="false">+</button>
      </div>`;

      html += `</div>`; // timeline-labels-column

      // ===== RIGHT COLUMN - Table data =====
      html += `<div class="timeline-content-column">`;

      // Table header row - matches timeline-ruler styling (44px)
      html += `<div class="timeline-ruler table-row table-row--header">
        <div class="table-cell table-cell--desc"><span class="table-desc-text">Description</span></div>
        <div class="table-cell table-cell--delay">Delay</div>
        <div class="table-cell table-cell--duration">Duration</div>
        <div class="table-cell table-cell--easing">Easing</div>
      </div>`;

      // Table rows - each row exactly 32px to match timeline tracks
      specData.layers.forEach((layer, layerIndex) => {
        // Layer header row (empty cells to match left column layer header)
        const dividerClass = layerIndex > 0 ? ' has-divider' : '';
        html += `<div class="timeline-track layer-header${dividerClass} table-row table-row--layer" data-layer-index="${layerIndex}">
          <div class="table-cell table-cell--desc"></div>
          <div class="table-cell table-cell--delay"></div>
          <div class="table-cell table-cell--duration"></div>
          <div class="table-cell table-cell--easing"></div>
        </div>`;

        // Animation rows
        layer.animations.forEach((anim, animIndex) => {
          const description = getAnimationDescription(anim.property, anim.values, anim.fitToShape, anim.description, layer.layerName);

          // For Fit to Shape or other special animations, only show description
          const isFitToShape = anim.isFitToShape || anim.fitToShape;

          let delay, duration, easingText;

          if (isFitToShape) {
            delay = '-';
            duration = '-';
            easingText = '-';
          } else {
            delay = anim.timing.delay + 'ms';
            // Display duration: show "-" for imported springs (not yet edited)
            const durationIsNumeric = typeof anim.timing.duration === 'number' && !isNaN(anim.timing.duration);
            const userSetDuration = anim.durationUserSet === true;
            const isImportedSpring = !userSetDuration && anim.easing.type === 'spring' && durationIsNumeric;
            duration = isImportedSpring ? '-' : (durationIsNumeric ? anim.timing.duration + 'ms' : '-');

            // Check for custom easing first
            if (anim.customEasing !== undefined && anim.customEasing !== null) {
              easingText = formatSpringPreset(anim.customEasing);
            } else if (anim.easing.type === 'spring') {
              const spring = anim.easing.spring;
              const presetSprings = ['Standard Spring', 'Slow Spring', 'Fast Spring', 'Slow Bounce Spring', 'Medium Bounce Spring', 'Fast Bounce Spring'];
              const springLinks = {
                'Standard Spring': 'https://air.bb/standard-spring',
                'Slow Spring': 'https://air.bb/slow-spring',
                'Fast Spring': 'https://air.bb/fast-spring',
                'Slow Bounce Spring': 'https://air.bb/slow-bounce-spring',
                'Medium Bounce Spring': 'https://air.bb/medium-bounce-spring',
                'Fast Bounce Spring': 'https://air.bb/fast-bounce-spring'
              };
              const isPreset = presetSprings.includes(spring.preset);

              if (isPreset) {
                const link = springLinks[spring.preset];
                easingText = `<a href="${link}" target="_blank" rel="noopener noreferrer" class="spring-link">${spring.preset}</a>`;
              } else {
                // Wrap numbers in spans for styling with non-breaking spaces
                if (isEditMode) {
                  easingText = `Stiffness:&nbsp;<span class="num">${spring.custom.stiffness}</span>, Damping:&nbsp;<span class="num">${spring.custom.damping}</span>, Damping Ratio:&nbsp;<span class="num">${spring.custom.dampingRatio}</span>, Mass:&nbsp;<span class="num">${spring.custom.mass}</span>`;
                } else {
                  easingText = `Stiffness:&nbsp;<span class="num">${spring.custom.stiffness}</span>,&nbsp;Damping:&nbsp;<span class="num">${spring.custom.damping}</span>,&nbsp;Damping Ratio:&nbsp;<span class="num">${spring.custom.dampingRatio}</span>,&nbsp;Mass:&nbsp;<span class="num">${spring.custom.mass}</span>`;
                }
              }
            } else if (anim.easing.type === 'cubic-bezier') {
              const bezierValue = anim.easing.cubicBezier;

              // Check if preset name is already provided in JSON
              let presetName = anim.easing.cubicBezierPreset;

              // If not provided, detect from the bezier values
              if (!presetName) {
                // Normalize the bezier string by removing spaces and parsing numbers
                const normalized = bezierValue.replace(/\s+/g, '').toLowerCase();
                const curvePresets = {
                  'cubic-bezier(0.2,0,0.2,1)': 'Standard Curve',
                  'cubic-bezier(0.20,0.00,0.20,1.00)': 'Standard Curve',
                  'cubic-bezier(0.1,1,0.2,1)': 'Enter Curve',
                  'cubic-bezier(0.10,1.00,0.20,1.00)': 'Enter Curve',
                  'cubic-bezier(0.4,0,1,1)': 'Exit Curve',
                  'cubic-bezier(0.40,0.00,1.00,1.00)': 'Exit Curve'
                };
                presetName = curvePresets[normalized];
              }

              const curveLinks = {
                'Standard Curve': 'https://air.bb/standard-curve',
                'Enter Curve': 'https://air.bb/enter-curve',
                'Exit Curve': 'https://air.bb/exit-curve'
              };

              if (presetName && curveLinks[presetName]) {
                const link = curveLinks[presetName];
                easingText = `<a href="${link}" target="_blank" rel="noopener noreferrer" class="spring-link">${presetName}</a>`;
              } else {
                // Extract just the numbers from "cubic-bezier(x, y, z, w)" to "(x, y, z, w)"
                if (bezierValue.includes('cubic-bezier')) {
                  easingText = wrapNumbers(bezierValue.replace('cubic-bezier', ''));
                } else {
                  easingText = wrapNumbers(`(${bezierValue})`);
                }
              }
            } else if (anim.easing.type === 'linear') {
              easingText = 'linear';
            } else {
              easingText = anim.easing.type || '-';
            }
          }

          html += `<div class="timeline-track table-row" data-row-type="animation" data-layer-index="${layerIndex}" data-anim-index="${animIndex}">
            <div class="table-cell table-cell--desc editable-cell" contenteditable="${isEditMode}" data-field="description"><span class="table-desc-text">${description}</span></div>
            <div class="table-cell table-cell--delay editable-cell" contenteditable="${isEditMode && !isFitToShape}" data-field="delay">${delay}</div>
            <div class="table-cell table-cell--duration editable-cell" contenteditable="${isEditMode && !isFitToShape}" data-field="duration">${duration}</div>
            <div class="table-cell table-cell--easing editable-cell" contenteditable="${isEditMode && !isFitToShape}" data-field="easing">${easingText}</div>
          </div>`;
        });
      });

      // Bottom divider for right column to match left column
      html += `<div class="timeline-bottom-track table-row">
        <div class="table-cell table-cell--desc"></div>
        <div class="table-cell table-cell--delay"></div>
        <div class="table-cell table-cell--duration"></div>
        <div class="table-cell table-cell--easing"></div>
      </div>`;

      html += `</div>`; // timeline-content-column
      html += `</div>`; // timeline-container

      timelineContent.innerHTML = html;
      console.log('[TABLE] Table view rendered');

      updateTableEasingWidth();
      syncTableRowHeights();
      addTableHoverListeners();
      setupTableDragAndDrop();
      setupTableAddButtonHandlers();
      setupTableAddButtonHoverZones();
      setupParamActionButtonHoverHandlers();
      setupTableEditableFields();
    }

    // Setup hover handlers for param action buttons to show only one at a time
    function setupParamActionButtonHoverHandlers() {
      const paramRows = document.querySelectorAll('.timeline-label.indented');

      paramRows.forEach(row => {
        row.addEventListener('mouseenter', () => {
          // Hide all param action buttons
          document.querySelectorAll('.param-action-btn').forEach(btn => {
            btn.classList.remove('visible');
          });

          // Show only this row's button
          const btn = row.querySelector('.param-action-btn');
          if (btn) {
            btn.classList.add('visible');
          }
        });

        row.addEventListener('mouseleave', () => {
          // Hide this row's button
          const btn = row.querySelector('.param-action-btn');
          if (btn) {
            btn.classList.remove('visible');
          }
        });

        // Add click handler to the delete button
        const btn = row.querySelector('.param-action-btn');
        if (btn) {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();

            // Calculate global animation index
            const layerIndex = parseInt(row.dataset.layerIndex);
            const animInLayer = parseInt(row.dataset.animInLayer);

            let globalAnimIndex = 0;
            for (let i = 0; i < layerIndex; i++) {
              globalAnimIndex += specData.layers[i].animations.length;
            }
            globalAnimIndex += animInLayer;

            // Call the delete function
            deleteAnimation(globalAnimIndex);
          });
        }
      });
    }

    // Add hover event listeners to sync hover state between left and right columns in table view
    function addTableHoverListeners() {
      const leftLabels = document.querySelectorAll('.timeline-labels-column .timeline-label[data-row-type]');
      const rightRows = document.querySelectorAll('.timeline-content-column .timeline-track.table-row[data-row-type]');

      // Add listeners to left column labels
      leftLabels.forEach(leftLabel => {
        const rowType = leftLabel.getAttribute('data-row-type');
        const layerIndex = leftLabel.getAttribute('data-layer-index');
        const animIndex = leftLabel.getAttribute('data-anim-index');

        leftLabel.addEventListener('mouseenter', () => {
          // Find matching right row
          let selector = `.timeline-track.table-row[data-row-type="${rowType}"][data-layer-index="${layerIndex}"]`;
          if (animIndex !== null) {
            selector += `[data-anim-index="${animIndex}"]`;
          }
          const rightRow = document.querySelector(selector);

          if (rightRow) {
            leftLabel.classList.add('table-hover');
            rightRow.classList.add('table-hover');
          }
        });

        leftLabel.addEventListener('mouseleave', () => {
          // Find matching right row
          let selector = `.timeline-track.table-row[data-row-type="${rowType}"][data-layer-index="${layerIndex}"]`;
          if (animIndex !== null) {
            selector += `[data-anim-index="${animIndex}"]`;
          }
          const rightRow = document.querySelector(selector);

          if (rightRow) {
            leftLabel.classList.remove('table-hover');
            rightRow.classList.remove('table-hover');
          }
        });
      });

      // Add listeners to right column rows
      rightRows.forEach(rightRow => {
        const rowType = rightRow.getAttribute('data-row-type');
        const layerIndex = rightRow.getAttribute('data-layer-index');
        const animIndex = rightRow.getAttribute('data-anim-index');

        rightRow.addEventListener('mouseenter', () => {
          // Find matching left label
          let selector = `.timeline-label[data-row-type="${rowType}"][data-layer-index="${layerIndex}"]`;
          if (animIndex !== null) {
            selector += `[data-anim-index="${animIndex}"]`;
          }
          const leftLabel = document.querySelector(selector);

          if (leftLabel) {
            leftLabel.classList.add('table-hover');
            rightRow.classList.add('table-hover');
          }
        });

        rightRow.addEventListener('mouseleave', () => {
          // Find matching left label
          let selector = `.timeline-label[data-row-type="${rowType}"][data-layer-index="${layerIndex}"]`;
          if (animIndex !== null) {
            selector += `[data-anim-index="${animIndex}"]`;
          }
          const leftLabel = document.querySelector(selector);

          if (leftLabel) {
            leftLabel.classList.remove('table-hover');
            rightRow.classList.remove('table-hover');
          }
        });
      });
    }

    // Setup drag and drop for table mode (reuses timeline drag logic)
    function setupTableDragAndDrop() {
      const labels = document.querySelectorAll('.timeline-labels-column .timeline-label[draggable="true"]');

      labels.forEach(label => {
        // Dragstart - record what's being dragged
        label.addEventListener('dragstart', (e) => {
          draggedElement = label;
          draggedType = label.dataset.dragType;
          draggedLayerIndex = parseInt(label.dataset.layerIndex);
          draggedAnimIndex = label.dataset.animInLayer ? parseInt(label.dataset.animInLayer) : null;

          label.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/html', label.innerHTML);

          // Find and add dragging class to corresponding right row
          const rightRow = findCorrespondingRightRow(label);
          if (rightRow) {
            rightRow.classList.add('dragging');
          }

          // Hide all add buttons during drag
          document.querySelectorAll('.timeline-label-add-btn, .section-divider-add-btn').forEach(btn => {
            btn.classList.remove('visible');
          });
        });

        // Dragend - cleanup
        label.addEventListener('dragend', (e) => {
          label.classList.remove('dragging');

          // Remove all drop indicators from both columns
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(el => {
            el.classList.remove('drag-over-top', 'drag-over-bottom', 'dragging');
          });

          draggedElement = null;
          draggedType = null;
          draggedLayerIndex = null;
          draggedAnimIndex = null;
        });

        // Dragover - show drop indicator
        label.addEventListener('dragover', (e) => {
          if (!draggedElement || draggedElement === label) return;

          const targetType = label.dataset.dragType;
          const targetLayerIndex = parseInt(label.dataset.layerIndex);

          // Check if this drop is valid
          let isValidDrop = false;
          let isDropOnLayerHeader = false;

          if (draggedType === 'animation' && targetType === 'animation') {
            isValidDrop = true;
          } else if (draggedType === 'animation' && targetType === 'layer') {
            isValidDrop = true;
            isDropOnLayerHeader = true;
          } else if (draggedType === 'layer' && targetType === 'layer') {
            isValidDrop = true;
          }

          if (!isValidDrop) return;

          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';

          // Determine drop position
          const rect = label.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          const dropPosition = e.clientY < midpoint ? 'before' : 'after';

          // Check if this drop would actually change position
          let wouldChangePosition = false;

          if (isDropOnLayerHeader) {
            wouldChangePosition = draggedLayerIndex !== targetLayerIndex;
          } else if (draggedType === 'layer' && targetType === 'layer') {
            const distanceFromTop = e.clientY - rect.top;
            if (distanceFromTop <= 10) {
              let targetIndex = targetLayerIndex;
              if (draggedLayerIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedLayerIndex !== targetIndex;
            }
          } else if (draggedType === 'animation' && targetType === 'animation') {
            if (draggedLayerIndex !== targetLayerIndex) {
              wouldChangePosition = true;
            } else {
              const targetAnimIndex = parseInt(label.dataset.animInLayer);
              let targetIndex = targetAnimIndex;
              if (dropPosition === 'after') targetIndex++;
              if (draggedAnimIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedAnimIndex !== targetIndex;
            }
          }

          if (!wouldChangePosition) return;

          // Clear all indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(el => {
            el.classList.remove('drag-over-top', 'drag-over-bottom');
          });

          // Add indicator to both left label and right row
          const rightRow = findCorrespondingRightRow(label);

          if (isDropOnLayerHeader) {
            label.classList.add('drag-over-bottom');
            if (rightRow) rightRow.classList.add('drag-over-bottom');
          } else if (draggedType === 'layer' && targetType === 'layer') {
            const distanceFromTop = e.clientY - rect.top;
            if (distanceFromTop <= 10) {
              label.classList.add('drag-over-top');
              if (rightRow) rightRow.classList.add('drag-over-top');
            }
          } else {
            if (dropPosition === 'before') {
              label.classList.add('drag-over-top');
              if (rightRow) rightRow.classList.add('drag-over-top');
            } else {
              label.classList.add('drag-over-bottom');
              if (rightRow) rightRow.classList.add('drag-over-bottom');
            }
          }
        });

        // Drop - perform the reorder
        label.addEventListener('drop', (e) => {
          e.preventDefault();

          if (!draggedElement || draggedElement === label) return;

          const targetType = label.dataset.dragType;
          const targetLayerIndex = parseInt(label.dataset.layerIndex);
          const targetAnimIndex = label.dataset.animInLayer ? parseInt(label.dataset.animInLayer) : null;

          // Determine drop position
          const rect = label.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          const dropPosition = e.clientY < midpoint ? 'before' : 'after';

          // For layer drops: only allow drops in top half (before)
          if (draggedType === 'layer' && targetType === 'layer') {
            if (dropPosition === 'after') return;
            performLayerMove(draggedLayerIndex, targetLayerIndex, dropPosition);
          }
          // For dropping animations on layer headers
          else if (draggedType === 'animation' && targetType === 'layer') {
            const sourceLayer = specData.layers[draggedLayerIndex];
            const targetLayer = specData.layers[targetLayerIndex];
            const anim = sourceLayer.animations.splice(draggedAnimIndex, 1)[0];
            targetLayer.animations.splice(0, 0, anim);
            renderTableView();
          }
          // For animation drops
          else if (draggedType === 'animation' && targetType === 'animation') {
            if (draggedLayerIndex === targetLayerIndex) {
              performAnimationMove(draggedLayerIndex, draggedAnimIndex, targetAnimIndex, dropPosition);
            } else {
              const sourceLayer = specData.layers[draggedLayerIndex];
              const targetLayer = specData.layers[targetLayerIndex];
              const anim = sourceLayer.animations.splice(draggedAnimIndex, 1)[0];

              let insertIndex = targetAnimIndex;
              if (dropPosition === 'after') insertIndex++;
              targetLayer.animations.splice(insertIndex, 0, anim);
              renderTableView();
            }
          }

          // Clear all indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(el => {
            el.classList.remove('drag-over-top', 'drag-over-bottom');
          });
        });
      });
    }

    // Helper function to find the corresponding right row for a left label
    function findCorrespondingRightRow(label) {
      const rowType = label.getAttribute('data-row-type');
      const layerIndex = label.getAttribute('data-layer-index');
      const animIndex = label.getAttribute('data-anim-index');

      let selector = `.timeline-track.table-row[data-row-type="${rowType}"][data-layer-index="${layerIndex}"]`;
      if (animIndex !== null) {
        selector += `[data-anim-index="${animIndex}"]`;
      }

      return document.querySelector(selector);
    }

    // Setup add button click handlers for table mode
    function setupTableAddButtonHandlers() {
      // Set up + button handlers for adding parameters
      const addButtons = document.querySelectorAll('.timeline-label-add-btn');
      addButtons.forEach(btn => {
        // Prevent drag when clicking the + button
        btn.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();

          // Get the parent label to find which layer and position
          const label = btn.closest('.timeline-label');
          if (!label) return;

          const layerIndex = parseInt(label.dataset.layerIndex);
          const layer = specData.layers[layerIndex];
          if (!layer) return;

          // Determine insert position
          let insertIndex;
          if (label.classList.contains('layer-header')) {
            // If clicking on header, add to end of layer
            insertIndex = layer.animations.length;
          } else {
            // If clicking on animation row, add after it
            const animInLayer = parseInt(label.dataset.animInLayer);
            insertIndex = animInLayer + 1;
          }

          // Create new animation with default values
          const newAnimation = {
            property: "Add parameter",
            description: "Add description",
            timing: {
              delay: 0,
              duration: 300
            },
            easing: {
              type: "-",
              cubicBezier: ""
            },
            values: {
              formatted: {
                startValue: "-",
                endValue: "-"
              }
            }
          };

          // Insert the new animation
          layer.animations.splice(insertIndex, 0, newAnimation);

          // Re-render table
          renderTableView();

          // Calculate the global animation index for the newly added animation
          let globalAnimIndex = 0;
          for (let i = 0; i < layerIndex; i++) {
            globalAnimIndex += specData.layers[i].animations.length;
          }
          globalAnimIndex += insertIndex;

          // Show the info box for the newly added animation
          setTimeout(() => {
            showAnimationDetails(globalAnimIndex);

            // Add selected class to the new label
            const newLabel = document.querySelector(`.timeline-label[data-layer-index="${layerIndex}"][data-anim-in-layer="${insertIndex}"]`);
            if (newLabel) {
              newLabel.classList.add('selected');
            }
          }, 50);
        });
      });

      // Set up section divider button handlers
      const sectionDividerButtons = document.querySelectorAll('.section-divider-add-btn');
      sectionDividerButtons.forEach(btn => {
        btn.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();

          // Determine insert position
          let insertIndex;
          const parentLabel = btn.closest('.timeline-label');
          const isBottomDivider = btn.closest('.timeline-bottom-divider');

          if (isBottomDivider) {
            // Bottom divider - add to end
            insertIndex = specData.layers.length;
          } else if (parentLabel) {
            // Section header button - insert before this layer
            const layerIndex = parseInt(parentLabel.dataset.layerIndex);
            insertIndex = layerIndex;
          } else {
            return;
          }

          // Create new layer with one default animation
          const newLayer = {
            layerName: "New section",
            animations: [
              {
                property: "Add parameter",
                description: "Add description",
                timing: {
                  delay: 0,
                  duration: 300
                },
                easing: {
                  type: "-",
                  cubicBezier: ""
                },
                values: {
                  formatted: {
                    startValue: "-",
                    endValue: "-"
                  }
                }
              }
            ]
          };

          // Insert the new layer
          specData.layers.splice(insertIndex, 0, newLayer);

          // Re-render table
          renderTableView();

          // Calculate the global animation index for the newly added parameter
          let globalAnimIndex = 0;
          for (let i = 0; i < insertIndex; i++) {
            globalAnimIndex += specData.layers[i].animations.length;
          }
          // The new parameter is at index 0 in the new layer

          // Show the info box for the newly added animation
          setTimeout(() => {
            showAnimationDetails(globalAnimIndex);

            // Add selected class to the new layer header
            const newLayerHeader = document.querySelector(`.timeline-label.layer-header[data-layer-index="${insertIndex}"]`);
            if (newLayerHeader) {
              newLayerHeader.classList.add('selected');
            }
          }, 50);
        });
      });
    }

    // Setup editable fields for table mode
    function setupTableEditableFields() {
      // Handle right column editable cells
      const editableCells = document.querySelectorAll('.editable-cell[contenteditable="true"]');

      editableCells.forEach(cell => {
        // Store original value on focus
        cell.addEventListener('focus', (e) => {
          cell.dataset.originalValue = cell.textContent.trim();
          // Select all text on focus
          const range = document.createRange();
          range.selectNodeContents(cell);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);

          // Show autocomplete for easing fields
          if (cell.dataset.field === 'easing') {
            showEasingAutocomplete(cell, cell.textContent.trim());
          }
        });

        // Update autocomplete filter on input for easing fields
        if (cell.dataset.field === 'easing') {
          cell.addEventListener('input', (e) => {
            showEasingAutocomplete(cell, cell.textContent.trim());
          });
        }

        // Handle Enter key
        cell.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            cell.blur();
          } else if (e.key === 'Escape') {
            // Restore original value
            cell.textContent = cell.dataset.originalValue || '';
            cell.blur();
          }
        });

        // Save changes on blur
        cell.addEventListener('blur', (e) => {
          const row = cell.closest('.table-row');
          const layerIndex = parseInt(row.dataset.layerIndex);
          const animIndex = parseInt(row.dataset.animIndex);
          const fieldName = cell.dataset.field;
          let newValue = cell.textContent.trim();

          // Get the animation
          const layer = specData.layers[layerIndex];
          if (!layer) return;
          const anim = layer.animations[animIndex];
          if (!anim) return;

          // Apply validation and update based on field type
          if (fieldName === 'description') {
            // Update custom description
            anim.description = newValue || undefined;
          } else if (fieldName === 'delay') {
            // Parse delay - remove "ms" suffix if present
            newValue = newValue.replace(/ms$/i, '').trim();
            const numValue = parseFloat(newValue);
            if (!isNaN(numValue)) {
              anim.timing.delay = numValue;
            } else {
              // Invalid - restore original
              cell.textContent = cell.dataset.originalValue || '';
              return;
            }
          } else if (fieldName === 'duration') {
            // Parse duration - remove "ms" suffix if present
            newValue = newValue.replace(/ms$/i, '').trim();

            const numValue = parseFloat(newValue);
            if (!isNaN(numValue) && numValue >= 0) {
              // Valid number - set duration
              anim.timing.duration = numValue;
              anim.durationUserSet = true;
            } else if (newValue === '-' || newValue === '') {
              // "-" or empty - spring style (no defined end time)
              anim.timing.duration = '-';
              anim.durationUserSet = true;
            } else {
              // Invalid - restore original
              cell.textContent = cell.dataset.originalValue || '';
              return;
            }
          } else if (fieldName === 'easing') {
            // Store custom easing as plain text
            anim.customEasing = newValue || undefined;
          }

          // Refresh the view to show updates
          renderTableView();
        });
      });

      // Setup label editing
      setupLabelEditing();
    }

    // Setup label editing for both timeline and table modes
    function setupLabelEditing() {
      // Handle left column label editing with drag threshold
      const leftLabels = document.querySelectorAll('.timeline-labels-column .timeline-label[draggable="true"]');

      leftLabels.forEach(label => {
        const labelText = label.querySelector('.timeline-label-text');
        if (!labelText) return;

        let mouseDownX = 0;
        let mouseDownY = 0;
        let isDragging = false;
        let mouseDownTime = 0;

        labelText.addEventListener('mousedown', (e) => {
          // Don't interfere with + buttons
          if (e.target.closest('.timeline-label-add-btn, .section-divider-add-btn')) return;

          mouseDownX = e.clientX;
          mouseDownY = e.clientY;
          mouseDownTime = Date.now();
          isDragging = false;
        });

        labelText.addEventListener('mousemove', (e) => {
          if (mouseDownTime === 0) return;

          const deltaX = Math.abs(e.clientX - mouseDownX);
          const deltaY = Math.abs(e.clientY - mouseDownY);
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

          // If moved more than 5px, consider it a drag
          if (distance > 5) {
            isDragging = true;
          }
        });

        labelText.addEventListener('mouseup', (e) => {
          const clickDuration = Date.now() - mouseDownTime;
          mouseDownTime = 0;

          // If not dragging and was a quick click, enter edit mode
          if (!isDragging && clickDuration < 300) {
            e.stopPropagation();
            e.preventDefault();
            enterEditMode(label, labelText);
          }

          isDragging = false;
        });
      });

      // Function to enter edit mode for left column labels
      function enterEditMode(label, labelText) {
        const originalText = labelText.textContent.trim();
        const isLayerHeader = label.classList.contains('layer-header');
        const layerIndex = parseInt(label.dataset.layerIndex);
        const animIndex = isLayerHeader ? null : parseInt(label.dataset.animInLayer);

        // Make the span contenteditable
        labelText.contentEditable = true;
        labelText.focus();

        // Select all text
        const range = document.createRange();
        range.selectNodeContents(labelText);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        // Temporarily disable dragging
        label.draggable = false;

        // Handle Enter key
        const handleKeyDown = (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            labelText.blur();
          } else if (e.key === 'Escape') {
            labelText.textContent = originalText;
            labelText.blur();
          }
        };

        // Save changes on blur
        const handleBlur = () => {
          const newText = labelText.textContent.trim();
          labelText.contentEditable = false;
          label.draggable = true;

          // Remove event listeners
          labelText.removeEventListener('keydown', handleKeyDown);
          labelText.removeEventListener('blur', handleBlur);

          // Update specData if text changed
          if (newText && newText !== originalText) {
            if (isLayerHeader) {
              updateLayerField(layerIndex, 'layerName', newText);
            } else {
              // Calculate global animation index
              let globalAnimIndex = 0;
              for (let i = 0; i < layerIndex; i++) {
                globalAnimIndex += getCurrentSpecData().layers[i].animations.length;
              }
              globalAnimIndex += animIndex;
              updateAnimationField(globalAnimIndex, 'property', newText);
            }
          } else if (!newText) {
            // Restore original if empty
            labelText.textContent = originalText;
          }
        };

        labelText.addEventListener('keydown', handleKeyDown);
        labelText.addEventListener('blur', handleBlur);
      }
    }

    // Setup hover zones for add buttons in table mode
    function setupTableAddButtonHoverZones() {
      const labelsColumn = document.querySelector('.timeline-labels-column');
      const labels = document.querySelectorAll('.timeline-label');
      const bottomDivider = document.querySelector('.timeline-bottom-divider');

      if (!labelsColumn) return;

      labelsColumn.addEventListener('mousemove', (e) => {
        const mouseY = e.clientY;

        // Find all buttons and their distances
        let closestButton = null;
        let closestDistance = Infinity;

        // Check each label's divider line
        labels.forEach(label => {
          const btn = label.querySelector('.timeline-label-add-btn');
          const sectionBtn = label.querySelector('.section-divider-add-btn');
          const rect = label.getBoundingClientRect();
          const halfCellHeight = rect.height / 2;

          // Check regular divider line (at bottom of cell)
          if (btn) {
            const dividerY = rect.bottom;
            const distanceFromDivider = Math.abs(mouseY - dividerY);
            if (distanceFromDivider <= halfCellHeight) {
              if (distanceFromDivider < closestDistance) {
                closestDistance = distanceFromDivider;
                closestButton = btn;
              }
            }
          }

          // Check section divider line (at top of cell, for elements with has-divider)
          if (sectionBtn) {
            const sectionDividerY = rect.top; // Border-top is at element's top edge
            const distanceFromSectionDivider = Math.abs(mouseY - sectionDividerY);
            // Use a larger hover zone for section dividers (about 15px total margin-top / 2)
            if (distanceFromSectionDivider <= 15) {
              if (distanceFromSectionDivider < closestDistance) {
                closestDistance = distanceFromSectionDivider;
                closestButton = sectionBtn;
              }
            }
          }
        });

        // Check bottom divider
        if (bottomDivider) {
          const bottomBtn = bottomDivider.querySelector('.section-divider-add-btn');
          if (bottomBtn) {
            const rect = bottomDivider.getBoundingClientRect();
            const dividerY = rect.top;
            const distanceFromDivider = Math.abs(mouseY - dividerY);
            if (distanceFromDivider <= 15) {
              if (distanceFromDivider < closestDistance) {
                closestDistance = distanceFromDivider;
                closestButton = bottomBtn;
              }
            }
          }
        }

        // Hide all buttons first
        labels.forEach(label => {
          const btn = label.querySelector('.timeline-label-add-btn');
          const sectionBtn = label.querySelector('.section-divider-add-btn');
          if (btn) btn.classList.remove('visible');
          if (sectionBtn) sectionBtn.classList.remove('visible');
        });
        if (bottomDivider) {
          const bottomBtn = bottomDivider.querySelector('.section-divider-add-btn');
          if (bottomBtn) bottomBtn.classList.remove('visible');
        }

        // Show only the closest button
        if (closestButton) {
          closestButton.classList.add('visible');
        }
      });

      // Hide all buttons when mouse leaves the column
      labelsColumn.addEventListener('mouseleave', () => {
        // Hide all buttons when mouse leaves the column
        labels.forEach(label => {
          const btn = label.querySelector('.timeline-label-add-btn');
          const sectionBtn = label.querySelector('.section-divider-add-btn');
          if (btn) btn.classList.remove('visible');
          if (sectionBtn) sectionBtn.classList.remove('visible');
        });

        // Hide bottom divider button
        if (bottomDivider) {
          const bottomBtn = bottomDivider.querySelector('.section-divider-add-btn');
          if (bottomBtn) bottomBtn.classList.remove('visible');
        }
      });
    }

    // Get the base HTML template for export (without the export button and JSZip)
    function getExportTemplate(videoFileName, tabsJson, videoSectionWidth = 400) {
      console.log('[GET_EXPORT_TEMPLATE] videoSectionWidth:', videoSectionWidth);

      // Get all the styles from this page
      const styleElement = document.querySelector('style');
      const styles = styleElement ? styleElement.textContent : '';
      console.log('[GET_EXPORT_TEMPLATE] Styles length:', styles.length);

      // Build custom CSS for the exported file with the video section width
      const customCSS = `
    /* Preserve exported video section width */
    body[data-mode='read'] .main-content {
      grid-template-columns: ${videoSectionWidth}px 1fr;
    }
    body[data-mode='edit'] .main-content {
      grid-template-columns: ${videoSectionWidth}px 20px 1fr;
    }`;
      console.log('[GET_EXPORT_TEMPLATE] customCSS:', customCSS);

      // Get all the script content (we'll extract just the functions we need)
      const scriptElement = document.querySelector('script:not([src])');
      const scriptContent = scriptElement ? scriptElement.textContent : '';
      console.log('[GET_EXPORT_TEMPLATE] Script content length:', scriptContent.length);

      // Remove the exportZip and getExportTemplate functions from the script
      const cleanedScript = scriptContent
        .replace(/\/\/ Get the base HTML template for export[\s\S]*?return result;\s*\n\s*}\s*\n/m, '')
        .replace(/\/\/ Export everything as a zip file[\s\S]*?}\s*catch[\s\S]*?}\s*\n\s*}\s*\n/m, '')
        .replace(/let uploadedVideoFile = null;\s*\n/g, '')
        .replace(/const isExportMode = false;/g, 'const isExportMode = true;')
        .replace(/let isEditMode = true;/g, 'let isEditMode = false;')
        .replace(/\/\/ Initialize with default spec[\s\S]*?\/\/ Render the default timeline\s*\n\s*renderTimeline\(\);\s*\n/m, '');

      console.log('[GET_EXPORT_TEMPLATE] Cleaned script length after replacements:', cleanedScript.length);

      console.log('[GET_EXPORT_TEMPLATE] Cleaned script length:', cleanedScript.length);
      console.log('[GET_EXPORT_TEMPLATE] First 500 chars of cleaned script:', cleanedScript.substring(0, 500));

      const result = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Motion Inspector</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Generator:%20Adobe%20Illustrator%2027.9.0,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%206.00%20Build%200)%20--%3e%3csvg%20version='1.1'%20id='Layer_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%20150%20150'%20style='enable-background:new%200%200%20150%20150;'%20xml:space='preserve'%3e%3cstyle%20type='text/css'%3e%20.st0{fill:%23FF385C;fill-rule:evenodd;clip-rule:evenodd;}%20%3c/style%3e%3cg%20id='Layer_1_00000076594398665045771890000013973700932976003724_'%3e%3cg%3e%3cpath%20class='st0'%20d='M131.3,118c-1.1,7.2-5.9,13.5-12.9,16.2c-3.4,1.3-7.1,1.9-10.7,1.3c-3.6-0.4-7.1-1.6-10.7-3.6%20c-5.1-2.8-10.2-7.2-16-13.5c9.3-11.3,15-21.7,17-31c0.9-4.3,1.2-8.3,0.7-11.9c-0.5-3.5-1.7-6.7-3.8-9.5%20c-4.3-6.3-11.7-9.9-19.8-9.9c-8.2,0-15.6,3.8-19.8,9.9c-1.9,2.8-3.2,6-3.8,9.5c-0.5,3.6-0.4,7.6,0.7,11.9c2.1,9.3,7.9,19.7,17,31%20c-5.8,6.4-10.9,10.7-16,13.5c-3.6,2-7.2,3.2-10.7,3.6c-3.8,0.4-7.4,0-10.7-1.3c-6.8-2.8-11.8-9-12.9-16.2c-0.5-3.6-0.1-7,1.2-10.9%20c0.5-1.3,1.1-2.8,1.9-4.4c1.1-2.3,2.1-4.7,3.2-7l0.1-0.3c9.7-20.9,20.1-42,30.8-62.9l0.4-0.8c1.1-2.1,2.3-4.3,3.4-6.4%20c1.2-2.1,2.4-4.3,4-6.2c3-3.5,6.8-5.2,11.3-5.2c4.4,0,8.3,1.9,11.3,5.2c1.6,1.9,2.8,4,4,6.2c1.1,2.1,2.3,4.3,3.4,6.4l0.4,0.9%20c10.9,20.8,21.2,42,30.8,62.9l0.1,0.1c1.1,2.3,2.1,4.7,3.2,7.1c0.7,1.6,1.3,3.1,1.9,4.4C131.4,111.1,131.8,114.6,131.3,118z%20M74.9,111.6c-7.6-9.7-12.5-18.5-14.2-26c-0.7-3.1-0.9-6-0.5-8.6c0.4-2.1,1.1-4.2,2.3-5.9c2.7-3.8,7.2-6,12.5-6%20c5.1,0,9.8,2.3,12.5,6c1.2,1.7,1.9,3.6,2.3,5.9c0.4,2.5,0.3,5.5-0.5,8.6C87.4,93.1,82.6,102,74.9,111.6z%20M138.5,104.2%20c-0.7-1.7-1.3-3.5-2-5.1c-1.1-2.4-2.1-4.8-3.4-7.2l-0.1-0.1c-9.8-20.9-20.2-42.2-31.1-63.2l-0.4-0.9c-1.1-2.1-2.3-4.3-3.5-6.6%20c-1.3-2.5-3-5.2-5.1-7.8C88.2,8,81.9,5,74.8,5c-7,0-13.4,3-18.1,8.3c-2.1,2.5-3.6,5.2-5.1,7.8c-1.2,2.1-2.3,4.4-3.5,6.6l-0.4,0.8%20C37.1,49.7,26.7,70.8,16.9,91.9l-0.1,0.3c-1.1,2.3-2.1,4.7-3.2,7.1c-0.7,1.6-1.5,3.2-2,5.1c-1.9,5.1-2.4,10.1-1.6,15%20c1.5,10.5,8.6,19.3,18.4,23.3c3.6,1.5,7.5,2.3,11.5,2.3c1.2,0,2.4-0.1,3.8-0.3c4.7-0.5,9.5-2.1,14.1-4.7%20c5.8-3.2,11.4-7.9,17.4-14.5c6.2,6.7,11.8,11.4,17.4,14.5c4.7,2.5,9.4,4.2,14.1,4.7c1.2,0.1,2.4,0.3,3.8,0.3c4,0,7.9-0.8,11.5-2.3%20c9.8-3.9,16.9-12.9,18.4-23.3C140.8,114.4,140.3,109.5,138.5,104.2z'/%3e%3c/g%3e%3c/g%3e%3cg%20id='Dimensions'%3e%3c/g%3e%3c/svg%3e">
  <style>${styles}${customCSS}</style>
</head>
<body data-mode="read">
  <div class="container">
    <div class="header-section">
      <h1 id="pageTitle" contenteditable="false">Motion Inspector</h1>
      <div class="controls">
        <div class="view-mode-control">
          <button class="view-mode-btn selected" data-view="timeline" onclick="switchToView('timeline')">Timeline</button>
          <button class="view-mode-btn" data-view="table" onclick="switchToView('table')">Table</button>
        </div>
        <button class="btn btn-secondary btn-circular" onclick="copySpecJson()" data-tooltip="Copy Spec">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
        </button>
      </div>
    </div>

    <div class="main-content">
      <div class="video-section">
        <div id="videoEmptyState" class="video-empty-state edit-only" style="display: none;">
          <div class="video-empty-state-btn">
            <span>ðŸ“</span>
            <span>Add Video</span>
          </div>
        </div>
        <div id="videoContainer" class="video-container">
          <div class="video-wrapper">
            <video id="videoPlayer"></video>
            <div class="video-overlay edit-only" onclick="document.getElementById('videoInput').click()">
              <div class="video-replace-btn">
                <span>ðŸ“</span>
                <span>Replace Video</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="resize-handle edit-only" id="resizeHandle"></div>

      <div class="timeline-wrapper">
        <div class="tabs-container" id="tabsContainer">
          <div class="tabs-bar">
            <!-- Tabs will be rendered here by JavaScript -->
          </div>
        </div>
        <div class="timeline-section">
          <div id="timelineContent"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
${cleanedScript}
    // Auto-load embedded data
    const EMBEDDED_TABS = ${tabsJson};

    window.addEventListener('DOMContentLoaded', () => {
      console.log('[EXPORT] DOMContentLoaded fired');
      console.log('[EXPORT] isEditMode:', isEditMode);
      console.log('[EXPORT] body data-mode:', document.body.getAttribute('data-mode'));

      // Load tabs array
      tabs = EMBEDDED_TABS;
      currentTabIndex = 0;
      nextTabId = tabs.length > 0 ? Math.max(...tabs.map(t => t.id)) + 1 : 1;

      // Group animations for all tabs
      tabs.forEach(tab => {
        if (tab.specData) {
          groupAnimations(tab.specData);
        }
      });
      console.log('[EXPORT] Tabs loaded:', tabs);

      // Update page title (always use Tab 1's title)
      const pageTitle = document.getElementById('pageTitle');
      const tab1Spec = tabs.length > 0 ? tabs[0].specData : null;
      if (pageTitle && tab1Spec && tab1Spec.compName) {
        pageTitle.textContent = tab1Spec.compName;
        document.title = tab1Spec.compName;
      }

      // Load video for current tab
      const currentTab = tabs[currentTabIndex];
      if (currentTab && currentTab.videoSrc) {
        video.src = currentTab.videoSrc;
        const videoContainer = document.getElementById('videoContainer');
        if (videoContainer) {
          videoContainer.classList.add('has-video');
        }

        video.addEventListener('loadedmetadata', () => {
          videoDuration = video.duration * 1000;
          video.currentTime = 0;
          setTimeout(updateVideoAlignment, 100);
        });
      }

      // Set specData from current tab (required for renderTimeline)
      specData = tabs[currentTabIndex].specData;
      console.log('[EXPORT] Set specData from current tab:', specData);

      // Render tabs and timeline
      console.log('[EXPORT] About to render tabs and timeline');
      renderTabs();

      // Hide tabs container if only one tab
      if (tabs.length === 1) {
        const tabsContainer = document.getElementById('tabsContainer');
        if (tabsContainer) {
          tabsContainer.style.display = 'none';
        }

        // Reduce top spacing by 16px and keep header content centered
        const headerSection = document.querySelector('.header-section');
        if (headerSection) {
          headerSection.style.paddingTop = '0px'; // Reduced from 4px to move content up
          headerSection.style.marginBottom = '16px'; // Adjusted to maintain total reduction
          headerSection.style.transform = 'translateY(-2px)'; // Move content up 2px more without affecting containers

          // Change to grid layout to center toggle
          headerSection.style.display = 'grid';
          headerSection.style.gridTemplateColumns = '1fr auto 1fr';
          headerSection.style.alignItems = 'center';

          // Ensure header is above timeline container
          headerSection.style.position = 'relative';
          headerSection.style.zIndex = '100';
        }

        // Position controls and toggle
        const controlsDiv = document.querySelector('.controls');
        const toggle = document.querySelector('.view-mode-control');
        const copyButton = document.querySelector('.btn-circular');

        if (controlsDiv && toggle && copyButton) {
          // Move toggle out of controls div and into center position
          controlsDiv.removeChild(toggle);
          headerSection.insertBefore(toggle, controlsDiv);

          // Keep copy button in controls div on the right
          controlsDiv.style.display = 'flex';
          controlsDiv.style.justifyContent = 'flex-end';
          controlsDiv.style.gap = '0';
        }

        // Adjust container heights for reduced top spacing (110px - 16px = 94px)
        const videoSection = document.querySelector('.video-section');
        if (videoSection) {
          videoSection.style.height = 'calc(100vh - 94px)';
          videoSection.style.maxHeight = 'calc(100vh - 94px)';
        }

        const videoElement = document.querySelector('video');
        if (videoElement) {
          videoElement.style.maxHeight = 'calc(100vh - 94px)';
        }

        // Also adjust timeline wrapper height to match video section
        const timelineWrapper = document.querySelector('.timeline-wrapper');
        if (timelineWrapper) {
          timelineWrapper.style.height = 'calc(100vh - 94px)';
          timelineWrapper.style.marginTop = '0';
        }
      }

      renderTimeline();
      console.log('[EXPORT] Tabs and timeline rendered');
    });
  <\/script>
</body>
</html>`;

      console.log('[GET_EXPORT_TEMPLATE] Result length:', result.length);
      return result;
    }

    // Export everything as a zip file
    async function exportZip() {
      if (!tabs || tabs.length === 0) {
        alert('Please paste a spec first (ðŸ“‹ Paste Spec button)');
        return;
      }

      // Check if at least one tab has a video
      const hasAnyVideo = tabs.some(tab => tab.uploadedVideoFile);
      if (!hasAnyVideo) {
        alert('Please upload a video first (Upload Video button)');
        return;
      }

      try {
        // Get current video section width
        const videoSection = document.querySelector('.video-section');
        const videoSectionWidth = videoSection ? videoSection.offsetWidth : 448;
        console.log('[EXPORT] Video section width:', videoSectionWidth);

        // Create zip file
        const zip = new JSZip();

        // Prepare tabs for export and add videos to zip
        const exportTabs = tabs.map((tab, index) => {
          let videoFileName = null;

          if (tab.uploadedVideoFile) {
            // Get video file extension
            const originalName = tab.uploadedVideoFile.name;
            const videoExt = originalName.substring(originalName.lastIndexOf('.'));
            videoFileName = `video_tab${tab.id}${videoExt}`;

            // Add video to zip
            zip.file(videoFileName, tab.uploadedVideoFile);
            console.log(`[EXPORT] Added ${videoFileName} for tab ${tab.id}`);
          }

          return {
            id: tab.id,
            name: tab.name,
            specData: tab.specData,
            videoSrc: videoFileName ? `./${videoFileName}` : null
          };
        });

        // Generate clean HTML template
        const exportHtml = getExportTemplate('', JSON.stringify(exportTabs), videoSectionWidth);
        console.log('[EXPORT] Generated HTML length:', exportHtml.length);

        // Create download link with spec name
        const specName = tabs[0].specData.compName.replace(/[^a-z0-9]/gi, '_').toLowerCase();

        // Add HTML to zip
        zip.file(`${specName}.html`, exportHtml);

        // Generate zip and download
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        const zipUrl = URL.createObjectURL(zipBlob);
        const link = document.createElement('a');
        link.href = zipUrl;
        link.download = `${specName}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(zipUrl);
      } catch (err) {
        alert('Failed to create zip file: ' + err.message);
        console.error(err);
      }
    }

    // Group matching animations (X/Y Position, Width/Height)
    function groupAnimations(specData) {
      if (!specData || !specData.layers) return;

      console.log('[GROUPING] Starting animation grouping');

      specData.layers.forEach((layer, layerIdx) => {
        if (!layer.animations || layer.animations.length < 2) return;

        console.log(`[GROUPING] Checking layer "${layer.layerName}" with ${layer.animations.length} animations`);

        const toRemove = [];
        const toAdd = [];

        // Check each animation for potential grouping
        for (let i = 0; i < layer.animations.length; i++) {
          if (toRemove.includes(i)) continue;

          const anim1 = layer.animations[i];
          const prop1 = anim1.property.toLowerCase();
          console.log(`[GROUPING]   Checking "${anim1.property}" (index ${i})`);

          // Check for X Position + Y Position
          if (prop1.includes('x position')) {
            console.log(`[GROUPING]     Found X Position, looking for Y Position`);
            for (let j = i + 1; j < layer.animations.length; j++) {
              if (toRemove.includes(j)) continue;

              const anim2 = layer.animations[j];
              const prop2 = anim2.property.toLowerCase();

              if (prop2.includes('y position')) {
                console.log(`[GROUPING]     Found Y Position at index ${j}, checking if they match`);
                console.log(`[GROUPING]       anim1 delay: ${anim1.timing.delay}, duration: ${anim1.timing.duration}, easing: ${anim1.easing.type}`);
                console.log(`[GROUPING]       anim2 delay: ${anim2.timing.delay}, duration: ${anim2.timing.duration}, easing: ${anim2.easing.type}`);

                if (animationsMatch(anim1, anim2)) {
                  console.log(`[GROUPING]     âœ“ Animations match! Creating Position group`);
                  // Create combined Position animation
                  toAdd.push(createGroupedAnimation(anim1, anim2, 'Position', 'position'));
                  toRemove.push(i, j);
                  break;
                } else {
                  console.log(`[GROUPING]     âœ— Animations don't match`);
                }
              }
            }
          }

          // Check for Width + Height
          if (prop1.includes('width') && !prop1.includes('x position')) {
            console.log(`[GROUPING]     Found Width, looking for Height`);
            for (let j = i + 1; j < layer.animations.length; j++) {
              if (toRemove.includes(j)) continue;

              const anim2 = layer.animations[j];
              const prop2 = anim2.property.toLowerCase();

              if (prop2.includes('height') && !prop2.includes('y position')) {
                console.log(`[GROUPING]     Found Height at index ${j}, checking if they match`);
                console.log(`[GROUPING]       anim1 delay: ${anim1.timing.delay}, duration: ${anim1.timing.duration}, easing: ${anim1.easing.type}`);
                console.log(`[GROUPING]       anim2 delay: ${anim2.timing.delay}, duration: ${anim2.timing.duration}, easing: ${anim2.easing.type}`);

                if (animationsMatch(anim1, anim2)) {
                  console.log(`[GROUPING]     âœ“ Animations match! Creating Width & Height group`);
                  // Create combined Width & Height animation
                  toAdd.push(createGroupedAnimation(anim1, anim2, 'Width & Height', 'size'));
                  toRemove.push(i, j);
                  break;
                } else {
                  console.log(`[GROUPING]     âœ— Animations don't match`);
                }
              }
            }
          }
        }

        // Remove grouped animations and add combined ones at the original position
        if (toRemove.length > 0) {
          console.log(`[GROUPING] Removing indices ${toRemove} and adding ${toAdd.length} grouped animations`);

          // Sort toRemove to process from highest to lowest index
          toRemove.sort((a, b) => b - a);

          // Insert grouped animations at the position of the first removed animation
          const insertPosition = Math.min(...toRemove);

          // Remove the animations (in reverse order to preserve indices)
          for (const idx of toRemove) {
            layer.animations.splice(idx, 1);
          }

          // Insert grouped animations at the original position
          layer.animations.splice(insertPosition, 0, ...toAdd);
        }
      });

      console.log('[GROUPING] Grouping complete');
    }

    // Check if two animations match (same delay, duration, easing)
    function animationsMatch(anim1, anim2) {
      // Always check delay
      if (anim1.timing.delay !== anim2.timing.delay) {
        console.log(`[GROUPING]         Delay mismatch: ${anim1.timing.delay} !== ${anim2.timing.delay}`);
        return false;
      }

      // Check easing type
      if (anim1.easing.type !== anim2.easing.type) {
        console.log(`[GROUPING]         Easing type mismatch: ${anim1.easing.type} !== ${anim2.easing.type}`);
        return false;
      }

      // For cubic-bezier, check duration AND bezier values
      if (anim1.easing.type === 'cubic-bezier') {
        // Check duration for cubic-bezier animations
        if (anim1.timing.duration !== anim2.timing.duration) {
          console.log(`[GROUPING]         Duration mismatch: ${anim1.timing.duration} !== ${anim2.timing.duration}`);
          return false;
        }

        const match = anim1.easing.cubicBezier === anim2.easing.cubicBezier;
        if (!match) {
          console.log(`[GROUPING]         Cubic-bezier mismatch: ${anim1.easing.cubicBezier} !== ${anim2.easing.cubicBezier}`);
        }
        return match;
      }

      // For springs, IGNORE duration (it's calculated from physics), only check spring parameters
      if (anim1.easing.type === 'spring') {
        const spring1 = anim1.easing.spring;
        const spring2 = anim2.easing.spring;
        console.log(`[GROUPING]         (Ignoring duration for springs - calculated from physics)`);
        console.log(`[GROUPING]         Comparing spring values:`);
        console.log(`[GROUPING]           stiffness: ${spring1?.stiffness} === ${spring2?.stiffness}`);
        console.log(`[GROUPING]           damping: ${spring1?.damping} === ${spring2?.damping}`);
        console.log(`[GROUPING]           dampingRatio: ${spring1?.dampingRatio} === ${spring2?.dampingRatio}`);
        console.log(`[GROUPING]           mass: ${spring1?.mass} === ${spring2?.mass}`);

        const match = spring1?.stiffness === spring2?.stiffness &&
               spring1?.damping === spring2?.damping &&
               spring1?.dampingRatio === spring2?.dampingRatio &&
               spring1?.mass === spring2?.mass;

        if (!match) {
          console.log(`[GROUPING]         Spring values don't match`);
        }

        return match;
      }

      return true;
    }

    // Create a grouped animation from two matching animations
    function createGroupedAnimation(anim1, anim2, propertyName, groupType) {
      const grouped = { ...anim1 };
      grouped.property = propertyName;
      grouped.isGrouped = true;
      grouped.groupType = groupType; // 'position' or 'size'
      grouped.groupedAnimations = [anim1, anim2];

      // Build combined values structure for description generation
      if (groupType === 'position') {
        // Determine which is X and which is Y
        const xAnim = anim1.property.toLowerCase().includes('x position') ? anim1 : anim2;
        const yAnim = anim1.property.toLowerCase().includes('x position') ? anim2 : anim1;

        const xChange = xAnim.values?.change || 0;
        const yChange = yAnim.values?.change || 0;

        grouped.values = {
          change: [xChange, yChange],
          animatingAxes: {
            both: true,
            x: true,
            y: true
          },
          formatted: {
            startValue: `${xAnim.values?.formatted?.startValue || '-'}\n${yAnim.values?.formatted?.startValue || '-'}`,
            endValue: `${xAnim.values?.formatted?.endValue || '-'}\n${yAnim.values?.formatted?.endValue || '-'}`
          }
        };
      } else if (groupType === 'size') {
        // Determine which is Width and which is Height
        const widthAnim = anim1.property.toLowerCase().includes('width') ? anim1 : anim2;
        const heightAnim = anim1.property.toLowerCase().includes('width') ? anim2 : anim1;

        const widthChange = widthAnim.values?.change || 0;
        const heightChange = heightAnim.values?.change || 0;

        grouped.values = {
          change: [widthChange, heightChange],
          formatted: {
            startValue: `${widthAnim.values?.formatted?.startValue || '-'}\n${heightAnim.values?.formatted?.startValue || '-'}`,
            endValue: `${widthAnim.values?.formatted?.endValue || '-'}\n${heightAnim.values?.formatted?.endValue || '-'}`
          }
        };
      }

      return grouped;
    }

    // Get color class for property
    function getPropertyColorClass(property) {
      const prop = property.toLowerCase();
      if (prop.includes('add parameter')) return 'bar-scale'; // Pink color for new parameters
      if (prop.includes('width & height')) return 'bar-width'; // Grouped Width & Height uses Width color
      if (prop.includes('position')) return 'bar-position-x'; // Grouped position uses same color as X Position
      if (prop.includes('opacity')) return 'bar-opacity';
      if (prop.includes('scale')) return 'bar-scale';
      if (prop.includes('rotation') || prop.includes('rotate')) return 'bar-rotation';
      if (prop.includes('x position')) return 'bar-position-x';
      if (prop.includes('y position')) return 'bar-position-y';
      if (prop.includes('width')) return 'bar-width';
      if (prop.includes('height')) return 'bar-height';
      if (prop.includes('blur')) return 'bar-blur';
      if (prop.includes('transform')) return 'bar-transform';
      return 'bar-default';
    }

    // Get hex color for property color class
    function getPropertyColor(colorClass) {
      const colorMap = {
        'bar-opacity': '#045c45',
        'bar-scale': '#a82968',
        'bar-rotation': '#5a1778',
        'bar-position-x': '#045c7d',
        'bar-position-y': '#045c7d',
        'bar-width': '#045c45',
        'bar-height': '#045c45',
        'bar-blur': '#4a4a4a',
        'bar-transform': '#5a1778',
        'bar-default': '#045c7d'
      };
      return colorMap[colorClass] || '#045c7d';
    }

    // Brighten a hex color to match the selected state (1.2x brightness)
    function brightenColor(hex) {
      // Remove # if present
      hex = hex.replace('#', '');

      // Parse RGB
      let r = parseInt(hex.substring(0, 2), 16);
      let g = parseInt(hex.substring(2, 4), 16);
      let b = parseInt(hex.substring(4, 6), 16);

      // Apply same brightness filter as selected bars (1.2x)
      r = Math.min(255, Math.round(r * 1.2));
      g = Math.min(255, Math.round(g * 1.2));
      b = Math.min(255, Math.round(b * 1.2));

      // Add more brightness to make it pop like the stroke
      r = Math.min(255, Math.round(r * 1.3));
      g = Math.min(255, Math.round(g * 1.3));
      b = Math.min(255, Math.round(b * 1.3));

      // Convert back to hex
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    // Convert video time to timeline position percentage
    function getTimelinePosition(videoTimeSeconds) {
      if (!video.duration || !specData) return 0;
      // Direct time mapping in milliseconds (not percentage-based)
      const specTimeMs = videoTimeSeconds * 1000;
      // Position based on current view duration (accounts for zoom)
      const currentViewDuration = viewDuration || specData.workArea.duration;
      return (specTimeMs / currentViewDuration) * 100;
    }

    // Convert alignment number to text
    function getAlignmentText(alignment) {
      const alignments = {
        1: 'center',
        2: 'center left',
        3: 'center right',
        5: 'top center',
        6: 'top left',
        7: 'top right',
        9: 'bottom center',
        10: 'bottom left',
        11: 'bottom right'
      };
      return alignments[alignment] || 'unknown';
    }

    // Format numeric values to max 2 decimal places
    function formatDecimalValue(value) {
      if (value === null || value === undefined) return value;

      // Convert to string if it's a number
      const strValue = String(value);

      // Replace all numbers in the string, preserving units and formatting
      return strValue.replace(/(\d+\.?\d*)/g, (match) => {
        const num = parseFloat(match);
        if (isNaN(num)) return match;

        // If it's a whole number, return as is
        if (num % 1 === 0) return String(num);

        // Otherwise round to 2 decimal places and remove trailing zeros
        return parseFloat(num.toFixed(2)).toString();
      });
    }

    // Convert scaleTo number to text
    function getScaleToText(scaleTo) {
      const scaleOptions = {
        1: 'width',
        2: 'height',
        3: 'stretch',
        4: 'none'
      };
      return scaleOptions[scaleTo] || 'unknown';
    }

    // Get natural language description of animation
    function getAnimationDescription(property, values, fitToShape, customDescription, layerName) {
      const prop = property.toLowerCase();
      let description;

      // Check for custom description first (allow empty strings)
      if (customDescription !== undefined && customDescription !== null) {
        return customDescription;
      }

      // Handle Fit to Shape animations
      if (fitToShape) {
        const alignment = getAlignmentText(fitToShape.alignment);
        const scaleTo = getScaleToText(fitToShape.scaleTo);
        description = `Parented to ${fitToShape.containerLayerName}, fit to ${scaleTo} and aligned to ${alignment}`;
      }
      // Handle cases where values is null
      else if (!values || values.change === undefined || values.change === null) {
        description = property;
      }
      else {
        const change = values.change;
        const changeValue = Array.isArray(change) ? change[0] : change;
        const absChange = Math.abs(changeValue);

        // Handle generic "Position" property (not X/Y Position)
        if (prop === 'position' && Array.isArray(change) && values.animatingAxes) {
          const xChange = change[0];
          const yChange = change[1];
          const absXChange = Math.abs(xChange);
          const absYChange = Math.abs(yChange);

          if (values.animatingAxes.both) {
            const xDir = xChange < 0 ? 'left' : 'right';
            const yDir = yChange < 0 ? 'up' : 'down';
            description = `Moves ${xDir} ${Math.round(absXChange)}px and ${yDir} ${Math.round(absYChange)}px`;
          } else if (values.animatingAxes.x) {
            const direction = xChange < 0 ? 'left' : 'right';
            description = `Moves ${direction} ${Math.round(absXChange)}px`;
          } else if (values.animatingAxes.y) {
            const direction = yChange < 0 ? 'up' : 'down';
            description = `Moves ${direction} ${Math.round(absYChange)}px`;
          } else {
            description = property;
          }
        }
        else if (prop.includes('x position')) {
          // Check for zero change
          if (changeValue === 0) {
            description = `Position X stays at ${values.formatted?.startValue || Math.round(values.startValue)}`;
          } else {
            const direction = changeValue < 0 ? 'left' : 'right';
            description = `Moves ${direction} ${Math.round(absChange)}px`;
          }
        }
        else if (prop.includes('y position')) {
          // Check for zero change
          if (changeValue === 0) {
            description = `Position Y stays at ${values.formatted?.startValue || Math.round(values.startValue)}`;
          } else {
            const direction = changeValue < 0 ? 'up' : 'down';
            description = `Moves ${direction} ${Math.round(absChange)}px`;
          }
        }
        // Handle grouped "Width & Height" property
        else if (prop.includes('width & height') && Array.isArray(change)) {
          const widthChange = change[0];
          const heightChange = change[1];
          const widthAction = widthChange > 0 ? 'expands' : 'shrinks';
          const heightAction = heightChange > 0 ? 'expands' : 'shrinks';

          // Check if both dimensions change the same way
          if (widthAction === heightAction) {
            description = `Width and Height ${widthAction}`;
          } else {
            description = `Width ${widthAction} and Height ${heightAction}`;
          }
        }
        else if (prop.includes('width')) {
          if (changeValue === 0) {
            description = `width stays at ${values.formatted?.startValue || Math.round(values.startValue)}`;
          } else {
            const action = changeValue > 0 ? 'expands' : 'shrinks';
            description = `width ${action}`;
          }
        }
        else if (prop.includes('height')) {
          if (changeValue === 0) {
            description = `height stays at ${values.formatted?.startValue || Math.round(values.startValue)}`;
          } else {
            const action = changeValue > 0 ? 'expands' : 'shrinks';
            description = `height ${action}`;
          }
        }
        else if (prop.includes('blur radius')) {
          if (changeValue === 0) {
            description = `blur stays at ${values.formatted?.startValue || Math.round(values.startValue)}`;
          } else {
            const action = changeValue > 0 ? 'blurs' : 'unblurs';
            description = `Layer ${action}`;
          }
        }
        else if (prop.includes('amount to tint')) {
          if (changeValue === 0) {
            description = `tint stays at ${values.formatted?.startValue || Math.round(values.startValue)}`;
          } else {
            const action = changeValue > 0 ? 'tints' : 'untints';
            description = action;
          }
        }
        else if (prop.includes('scale')) {
          if (values.formatted) {
            // Extract just the first value if x and y are the same
            let startVal = values.formatted.startValue;
            let endVal = values.formatted.endValue;

            // Check if it's a format like "100%, 100%" and extract first value
            if (typeof startVal === 'string' && startVal.includes(',')) {
              const startParts = startVal.split(',').map(s => s.trim());
              if (startParts[0] === startParts[1]) {
                startVal = startParts[0];
              }
            }
            if (typeof endVal === 'string' && endVal.includes(',')) {
              const endParts = endVal.split(',').map(s => s.trim());
              if (endParts[0] === endParts[1]) {
                endVal = endParts[0];
              }
            }

            // Format decimal values
            startVal = formatDecimalValue(startVal);
            endVal = formatDecimalValue(endVal);

            if (startVal === endVal) {
              description = `scale stays at ${endVal}`;
            } else {
              description = `scale animates from ${startVal} â€“ ${endVal}`;
            }
          } else {
            // No formatted values available
            if (changeValue === 0) {
              description = `scale stays at ${Math.round(values.startValue)}%`;
            } else {
              description = `scale animates from ${Math.round(values.startValue)}% â€“ ${Math.round(values.endValue)}%`;
            }
          }
        }
        else if (prop.includes('rotation') || prop.includes('rotate')) {
          // Check for zero change
          if (changeValue === 0) {
            description = `rotation stays at ${values.formatted?.startValue || Math.round(values.startValue)}Â°`;
          } else {
            const direction = changeValue < 0 ? 'counterclockwise' : 'clockwise';
            const degrees = Math.round(absChange);

            // Determine axis (if specified)
            const axis = prop.includes('x rotation') ? 'X ' :
                        prop.includes('y rotation') ? 'Y ' :
                        prop.includes('z rotation') ? 'Z ' : '';

            description = `rotates ${axis}${degrees}Â° ${direction}`;
          }
        }
        else if (prop.includes('opacity')) {
          const startValue = values.startValue;
          const endValue = values.endValue;

          // Format opacity values (remove % if present, show as percentage)
          const startPercent = `${Math.round(typeof startValue === 'string' ? parseFloat(startValue) : startValue)}%`;
          const endPercent = `${Math.round(typeof endValue === 'string' ? parseFloat(endValue) : endValue)}%`;

          // Special cases
          if (startValue === 0 && endValue === 100) {
            description = `alpha animates from 0% â€“ 100%`;
          } else if (startValue === 100 && endValue === 0) {
            description = `alpha animates from 100% â€“ 0%`;
          } else if (startValue === 0) {
            description = `fades in to ${endPercent}`;
          } else if (endValue === 0) {
            description = `fades out from ${startPercent}`;
          } else if (changeValue === 0) {
            description = `opacity stays at ${startPercent}`;
          } else {
            description = `alpha animates from ${startPercent} â€“ ${endPercent}`;
          }
        }
        // Handle corner radius properties (IndieCorners, Squircle, generic corner/radius)
        else if (prop === 'tl' || prop === 'tr' || prop === 'bl' || prop === 'br' ||
                 prop === 'unified radius' || prop === 'unified corners' ||
                 prop.includes('corner') || prop.includes('radius') ||
                 prop.includes('border radius')) {
          const startRounded = Math.round(typeof values.startValue === 'string' ? parseFloat(values.startValue) : values.startValue);
          const endRounded = Math.round(typeof values.endValue === 'string' ? parseFloat(values.endValue) : values.endValue);

          // Special case: Sharp to rounded
          if (startRounded === 0 && endRounded > 0) {
            description = `corner radius animates from sharp (0px) â€“ rounded (${endRounded}px)`;
          }
          // Special case: Rounded to sharp
          else if (startRounded > 0 && endRounded === 0) {
            description = `corner radius animates from rounded (${startRounded}px) â€“ sharp (0px)`;
          }
          // Zero change
          else if (startRounded === endRounded) {
            description = `corner radius stays at ${startRounded}px`;
          }
          // Default
          else {
            description = `corner radius animates from ${startRounded}px â€“ ${endRounded}px`;
          }
        }
        else {
          description = property;
        }
      }

      // Capitalize first letter
      return description.charAt(0).toUpperCase() + description.slice(1);
    }

    // Generate nice time divisions
    function getNiceTimeIntervals(duration) {
      const niceIntervals = [100, 200, 250, 500, 1000, 2000, 2500, 5000];
      const targetDivisions = 8;

      for (const interval of niceIntervals) {
        const divisions = Math.floor(duration / interval);
        if (divisions >= 6 && divisions <= 10) {
          return { interval, count: divisions };
        }
      }

      // Fallback: divide by 8
      return { interval: duration / 8, count: 8 };
    }

    // Helper function to refresh the active view
    function refreshActiveView() {
      console.log('[REFRESH] refreshActiveView called, viewMode:', viewMode);
      if (viewMode === 'table') {
        console.log('[REFRESH] Calling renderTableView');
        renderTableView();
      } else {
        console.log('[REFRESH] Calling renderTimeline');
        renderTimeline();
      }
      // If an animation is selected, refresh its detail panel
      if (selectedAnimation !== null) {
        showAnimationDetails(selectedAnimation);
      }
      console.log('[REFRESH] refreshActiveView complete');
    }

    // Auto-resize title input fields to fit content
    function autoResizeTitleInput(input) {
      // Create a temporary span to measure text width
      const temp = document.createElement('span');
      temp.style.font = window.getComputedStyle(input).font;
      temp.style.fontWeight = '700';
      temp.style.visibility = 'hidden';
      temp.style.position = 'absolute';
      temp.style.whiteSpace = 'pre';
      temp.textContent = input.value || input.placeholder || '';
      document.body.appendChild(temp);

      // Set width with some padding (12px for left/right padding in input)
      const width = Math.min(Math.max(temp.offsetWidth + 16, 40), 200);
      input.style.width = width + 'px';

      document.body.removeChild(temp);
    }

    // Validate numeric field (for delay and duration)
    function validateNumeric(value, previousValue) {
      // Try to parse as float
      const num = parseFloat(value);

      // If invalid or negative, return previous value
      if (isNaN(num) || num < 0) {
        return previousValue;
      }

      return num;
    }

    // Update a layer field and refresh views
    function updateLayerField(layerIndex, fieldName, newValue) {
      if (layerIndex >= 0 && layerIndex < specData.layers.length) {
        specData.layers[layerIndex][fieldName] = newValue;
        // Refresh the view - this will update:
        // 1. Left column layer header in timeline/table
        // 2. All info boxes for animations in this layer (they all reference layer.layerName)
        refreshActiveView();
      }
    }

    // Update an animation field and refresh views
    function updateAnimationField(animIndex, fieldName, newValue) {
      // Find the animation in specData
      let currentIndex = 0;
      for (let layerIndex = 0; layerIndex < specData.layers.length; layerIndex++) {
        const layer = specData.layers[layerIndex];
        for (let animIdx = 0; animIdx < layer.animations.length; animIdx++) {
          if (currentIndex === animIndex) {
            const anim = layer.animations[animIdx];

            // Update the field
            if (fieldName === 'customDescription') {
              anim.description = newValue;
            } else if (fieldName === 'delay') {
              // Validate and update delay (must be numeric)
              anim.timing.delay = validateNumeric(newValue, anim.timing.delay);
            } else if (fieldName === 'duration') {
              // Update duration - accept numbers or "-"
              const num = parseFloat(newValue);
              if (!isNaN(num) && num >= 0) {
                // Valid number - curve style
                anim.timing.duration = num;
                // Mark that duration has been explicitly set by user
                anim.durationUserSet = true;
              } else if (newValue === '-' || newValue.trim() === '') {
                // "-" or empty - spring style
                anim.timing.duration = '-';
                anim.durationUserSet = true;
              } else {
                // Invalid input, keep previous value
                anim.timing.duration = anim.timing.duration;
              }
            } else if (fieldName === 'easing') {
              // Update easing - allow any text value
              anim.customEasing = newValue;
            } else if (fieldName === 'startValue') {
              // Update start value - no validation
              anim.customStartValue = newValue;
            } else if (fieldName === 'endValue') {
              // Update end value - no validation
              anim.customEndValue = newValue;
            } else if (fieldName === 'property') {
              // Update property name - no validation
              anim.property = newValue;
            } else {
              anim[fieldName] = newValue;
            }

            // Refresh the view
            refreshActiveView();
            return;
          }
          currentIndex++;
        }
      }
    }

    // Render the timeline
    function renderTimeline() {
      console.log('[RENDER] renderTimeline called, specData:', specData);
      if (!specData) {
        console.log('[RENDER] No specData, returning');
        return;
      }

      const content = document.getElementById('timelineContent');
      console.log('[RENDER] timelineContent element:', content);

      // Update the main title with the spec name
      document.querySelector('h1').textContent = specData.compName;
      // Update the page title
      document.title = `Motion Inspector - ${specData.compName}`;

      let html = '';

      // Timeline container
      html += `<div class="timeline-container">`;

      // Left column - labels
      html += `<div class="timeline-labels-column">`;
      html += `<div class="playhead-time">
        <button id="playPauseBtn" onclick="togglePlayPause()"><span class="icon">â–¶</span></button>
        <button class="speed-btn selected" data-speed="1" onclick="setPlaybackSpeed(1)">1x</button>
        <button class="speed-btn" data-speed="0.5" onclick="setPlaybackSpeed(0.5)">0.5x</button>
        <button class="speed-btn" data-speed="0.1" onclick="setPlaybackSpeed(0.1)">0.1x</button>
      </div>`; // Play button and speed controls above labels

      let animIndex = 0;
      specData.layers.forEach((layer, layerIndex) => {
        // Layer header label (add divider class if not first layer)
        const dividerClass = layerIndex > 0 ? ' has-divider' : '';
        html += `<div class="timeline-label layer-header${dividerClass}"
                      draggable="${isEditMode}"
                      data-drag-type="layer"
                      data-layer-index="${layerIndex}"
                      data-is-section-divider="${layerIndex > 0 ? 'true' : 'false'}">
          <span class="timeline-label-text">${layer.layerName}</span>
          <button class="timeline-label-add-btn edit-only" draggable="false">+</button>
          ${layerIndex > 0 ? '<button class="section-divider-add-btn edit-only" draggable="false">+</button>' : ''}
        </div>`;

        // Animation labels for this layer
        layer.animations.forEach((anim, animIndexInLayer) => {
          html += `<div class="timeline-label indented"
                        draggable="${isEditMode}"
                        data-drag-type="animation"
                        data-anim-index="${animIndex}"
                        data-layer-index="${layerIndex}"
                        data-anim-in-layer="${animIndexInLayer}">
            <span class="timeline-label-text">${anim.property}</span>
            <button class="param-action-btn edit-only" draggable="false"></button>
            <button class="timeline-label-add-btn edit-only" draggable="false">+</button>
          </div>`;
          animIndex++;
        });
      });

      // Bottom section divider for adding new sections at the end
      html += `<div class="timeline-bottom-divider">
        <button class="section-divider-add-btn edit-only" draggable="false">+</button>
      </div>`;

      html += `</div>`; // timeline-labels-column

      // Right column - timeline content
      html += `<div class="timeline-content-column">`;

      // Zoom controls
      const specDuration = specData.workArea.duration;
      // Initialize viewDuration to rounded spec duration if not set
      if (!viewDuration) {
        viewDuration = Math.round(specDuration / 100) * 100;
      }
      const currentViewDuration = viewDuration;

      // Timeline ruler - use view duration for rendering
      const timeIntervals = getNiceTimeIntervals(currentViewDuration);
      const interval = timeIntervals.interval;
      const ticks = [];

      for (let time = 0; time <= currentViewDuration; time += interval) {
        ticks.push(time);
      }
      // Don't add final tick at exact duration - we'll stop before it

      html += `<div class="timeline-ruler">`;
      html += `<div class="zoom-controls edit-only">
        <span class="zoom-duration">Timeline duration: ${specDuration}ms</span>
        <button class="zoom-btn" onclick="zoomIn()">+</button>
        <button class="zoom-btn" onclick="zoomOut()">âˆ’</button>
      </div>`;
      html += `<div style="position: absolute; top: 0; left: 0; right: 0; height: 100%;">`;
      ticks.forEach((time, index) => {
        // Skip the last tick if it's at the end
        if (time >= currentViewDuration) return;

        // Position based on view time percentage, centered over grid line
        const position = (time / currentViewDuration) * 100;
        html += `<div class="timeline-tick" style="position: absolute; left: ${position}%; height: 100%; transform: translateX(-50%);">${Math.round(time)}ms</div>`;
      });
      html += `</div></div>`;

      // Timeline grid with bars
      html += `<div style="position: relative; padding-right: 80px;">`;
      html += `<div class="timeline-grid-lines" style="display: block; position: absolute; top: -8px; left: 0; right: 0; height: calc(100% + 8px); pointer-events: none; z-index: 5;">`;

      // Main grid lines (taller - extend into ruler, stop at bottom divider)
      ticks.forEach(time => {
        if (time >= currentViewDuration) return;
        const position = (time / currentViewDuration) * 100;
        html += `<div style="position: absolute; left: ${position}%; top: 0; bottom: 15px; width: 1px; background: rgba(255, 255, 255, 0.12);"></div>`;
      });

      // Subtle halfway markers between main grid lines (normal height - start below ruler, stop at bottom divider)
      for (let i = 0; i < ticks.length - 1; i++) {
        const midTime = (ticks[i] + ticks[i + 1]) / 2;
        const position = (midTime / currentViewDuration) * 100;
        html += `<div style="position: absolute; left: ${position}%; top: 8px; bottom: 15px; width: 1px; background: rgba(255, 255, 255, 0.06);"></div>`;
      }

      html += `</div>`;

      // Helper function to find parent layer timing and spring status
      function getParentLayerInfo(containerLayerName) {
        const parentLayer = specData.layers.find(l => l.layerName === containerLayerName);
        if (!parentLayer || !parentLayer.animations || parentLayer.animations.length === 0) {
          return { delay: 0, duration: specData.workArea.duration, hasSpring: false };
        }

        // Find the earliest start and latest end across all parent animations
        let minDelay = Infinity;
        let maxEnd = 0;
        let hasSpring = false;

        parentLayer.animations.forEach(anim => {
          const animStart = anim.timing.delay;
          const animEnd = anim.timing.delay + anim.timing.duration;
          minDelay = Math.min(minDelay, animStart);
          maxEnd = Math.max(maxEnd, animEnd);
          if (anim.easing.type === 'spring') {
            hasSpring = true;
          }
        });

        return {
          delay: minDelay === Infinity ? 0 : minDelay,
          duration: maxEnd - (minDelay === Infinity ? 0 : minDelay),
          hasSpring: hasSpring
        };
      }

      // Timeline tracks
      animIndex = 0;
      specData.layers.forEach((layer, layerIndex) => {
        // Empty track for layer header (add divider class if not first layer)
        const dividerClass = layerIndex > 0 ? ' has-divider' : '';
        html += `<div class="timeline-track layer-header${dividerClass}"></div>`;

        // Animation tracks for this layer
        layer.animations.forEach(anim => {
          let startPercent, widthPercent, description, springClass;

          // Handle Fit to Shape animations - use parent layer's timing
          if (anim.isFitToShape && anim.fitToShape) {
            const parentInfo = getParentLayerInfo(anim.fitToShape.containerLayerName);
            startPercent = (parentInfo.delay / currentViewDuration) * 100;
            widthPercent = (parentInfo.duration / currentViewDuration) * 100;
            description = getAnimationDescription(anim.property, anim.values, anim.fitToShape, anim.description, layer.layerName);
            springClass = parentInfo.hasSpring ? ' bar-spring' : '';
          } else {
            // Normal animation - use its own timing
            startPercent = (anim.timing.delay / currentViewDuration) * 100;

            // Determine styling based on duration value
            const durationIsNumeric = typeof anim.timing.duration === 'number' && !isNaN(anim.timing.duration);
            const durationIsString = typeof anim.timing.duration === 'string';

            // Check if user has explicitly set duration, or if it's an imported spring
            const userSetDuration = anim.durationUserSet === true;
            const isImportedSpring = !userSetDuration && anim.easing.type === 'spring' && durationIsNumeric;

            if (durationIsString) {
              // Duration is "-" - spring style
              widthPercent = 40;
              springClass = ' bar-spring';
            } else if (isImportedSpring) {
              // Imported spring (not yet edited) - spring style
              widthPercent = (anim.timing.duration / currentViewDuration) * 100;
              springClass = ' bar-spring';
            } else if (durationIsNumeric) {
              // Numeric duration (curve or user-edited) - curve style
              widthPercent = (anim.timing.duration / currentViewDuration) * 100;
              springClass = '';
            } else {
              // Fallback - spring style
              widthPercent = 40;
              springClass = ' bar-spring';
            }

            description = getAnimationDescription(anim.property, anim.values, null, anim.description, layer.layerName);
          }

          // Cap width so bars don't extend past the edge (shows rounded corners naturally)
          const maxWidth = 100 - startPercent;
          widthPercent = Math.min(widthPercent, maxWidth);

          const colorClass = getPropertyColorClass(anim.property);

          // Build inline style for custom colors
          let customStyle = `left: ${startPercent}%; width: ${widthPercent}%;`;
          if (anim.customColor) {
            if (anim.easing.type === 'spring') {
              // Spring gradient with custom color
              const rgb = anim.customColor.match(/\w\w/g).map(x => parseInt(x, 16));
              customStyle += ` background: linear-gradient(90deg, ${anim.customColor} 0%, ${anim.customColor} 50%, rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0) 100%);`;
            } else {
              // Solid custom color
              customStyle += ` background: ${anim.customColor};`;
            }
          }

          html += `<div class="timeline-track">`;

          // Determine if this is a spring
          const durationIsNumeric = typeof anim.timing.duration === 'number' && !isNaN(anim.timing.duration);
          const durationIsString = typeof anim.timing.duration === 'string';
          const userSetDuration = anim.durationUserSet === true;
          const isImportedSpring = !userSetDuration && anim.easing.type === 'spring' && durationIsNumeric;
          const isSpring = durationIsString || isImportedSpring;

          html += `
            <div class="timeline-bar ${colorClass}${springClass}"
                 style="${customStyle}"
                 data-anim-index="${animIndex}"
                 data-is-spring="${isSpring}">
              <span class="timeline-bar-text edit-only" contenteditable="true" data-anim-index="${animIndex}">${description}</span>
              <span class="timeline-bar-text export-only">${description}</span>
              <div class="timeline-bar-resize-handle left" data-handle="left"></div>
              ${!isSpring ? '<div class="timeline-bar-resize-handle right" data-handle="right"></div>' : ''}
            </div>
          `;
          html += `</div>`;

          animIndex++;
        });
      });

      // Bottom divider track to match left column
      html += `<div class="timeline-track timeline-bottom-track" style="border-top: 1px solid #4a4a4a; border-bottom: none; margin-top: 15px; height: 15px;"></div>`;

      html += `<div class="playhead" id="playhead"><div class="playhead-handle" id="playheadTimeDisplay">0ms</div></div>`;
      html += `</div>`; // position relative wrapper
      html += `</div>`; // timeline-content-column
      html += `</div>`; // timeline-container

      // Detail panel placeholder
      html += `<div id="detailPanel"></div>`;

      content.innerHTML = html;
      console.log('[RENDER] HTML set, length:', html.length);

      // Setup playhead dragging
      setupPlayheadDragging();

      // Setup animation bar clicks
      document.querySelectorAll('.timeline-bar').forEach(bar => {
        bar.addEventListener('click', (e) => {
          e.stopPropagation();
          const animIndex = parseInt(bar.dataset.animIndex);
          // Toggle: if clicking the same animation, close the info box
          if (selectedAnimation === animIndex) {
            document.getElementById('detailPanel').innerHTML = '';
            selectedAnimation = null;
            // Remove selected class from all bars and labels
            document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected'));
            requestAnimationFrame(() => {
              updatePlayhead();
            });
          } else {
            // Remove selected class from all bars and labels
            document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected'));
            // Add selected class to clicked bar
            bar.classList.add('selected');
            // Add selected class to corresponding label
            const label = document.querySelector(`.timeline-label.indented[data-anim-index="${animIndex}"]`);
            if (label) label.classList.add('selected');
            showAnimationDetails(animIndex);
          }
        });
      });

      // Setup resize handles
      setupResizeHandles();

      // Setup bar dragging (for moving timeline position or reordering)
      setupBarDragging();

      // Setup bar text editing
      setupBarTextEditing();

      updatePlayhead();

      // Detect text overflow and add fade class
      detectTextOverflow();

      // Setup drag and drop
      setupDragAndDrop();

      // Setup hover zones for add buttons
      setupAddButtonHoverZones();

      // Setup param action button hover handlers
      setupParamActionButtonHoverHandlers();

      // Setup label editing
      setupLabelEditing();
    }

    // Detect which bars have overflowing text and add fade class
    function detectTextOverflow() {
      const bars = document.querySelectorAll('.timeline-bar');
      bars.forEach(bar => {
        const textElement = bar.querySelector('.timeline-bar-text');
        if (textElement) {
          // Check if text is wider than the container
          const textWidth = textElement.scrollWidth;
          const containerWidth = bar.clientWidth - 16; // Subtract padding (8px * 2)

          if (textWidth > containerWidth) {
            bar.classList.add('has-text-overflow');
          } else {
            bar.classList.remove('has-text-overflow');
          }
        }
      });
    }

    // Setup drag and drop for timeline labels
    let draggedElement = null;
    let draggedType = null;
    let draggedLayerIndex = null;
    let draggedAnimIndex = null;

    function setupDragAndDrop() {
      const labels = document.querySelectorAll('.timeline-label');

      labels.forEach(label => {
        // Dragstart - record what's being dragged
        label.addEventListener('dragstart', (e) => {
          draggedElement = label;
          draggedType = label.dataset.dragType;
          draggedLayerIndex = parseInt(label.dataset.layerIndex);
          draggedAnimIndex = label.dataset.animInLayer ? parseInt(label.dataset.animInLayer) : null;

          label.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/html', label.innerHTML);

          // Hide all add buttons during drag
          document.querySelectorAll('.timeline-label-add-btn, .section-divider-add-btn').forEach(btn => {
            btn.classList.remove('visible');
          });
        });

        // Dragend - cleanup
        label.addEventListener('dragend', (e) => {
          label.classList.remove('dragging');
          // Remove all drop indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });
          const bottomDivider = document.querySelector('.timeline-bottom-divider');
          const bottomTrack = document.querySelector('.timeline-bottom-track');
          if (bottomDivider) bottomDivider.classList.remove('drag-over-top');
          if (bottomTrack) bottomTrack.classList.remove('drag-over-top');
          draggedElement = null;
          draggedType = null;
          draggedLayerIndex = null;
          draggedAnimIndex = null;
        });

        // Dragover - show drop indicator
        label.addEventListener('dragover', (e) => {
          if (!draggedElement || draggedElement === label) return;

          const targetType = label.dataset.dragType;
          const targetLayerIndex = parseInt(label.dataset.layerIndex);

          // Check if this drop is valid
          let isValidDrop = false;
          let isLastLayerParam = false;
          let isDropOnLayerHeader = false;

          if (draggedType === 'animation' && targetType === 'animation') {
            // Animation can be dropped in any layer
            isValidDrop = true;
          } else if (draggedType === 'animation' && targetType === 'layer') {
            // Allow dropping animations on layer headers (for empty sections or adding to top)
            isValidDrop = true;
            isDropOnLayerHeader = true;
          } else if (draggedType === 'layer' && targetType === 'layer') {
            isValidDrop = true;
          }
          // Note: We don't allow dropping layers on animation rows anymore
          // because the bottom divider provides a clearer drop target for that

          if (!isValidDrop) return;

          e.preventDefault();

          // Calculate if this drop would actually change the position
          const rect = label.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          let dropPosition = e.clientY < midpoint ? 'before' : 'after';
          let wouldChangePosition = false;

          if (isDropOnLayerHeader) {
            // Dropping animation on layer header - always valid unless it's already first in that layer
            if (draggedLayerIndex !== targetLayerIndex) {
              // Moving to a different layer - always valid
              wouldChangePosition = true;
            } else {
              // Same layer - only valid if not already first
              wouldChangePosition = draggedAnimIndex !== 0;
            }
          } else if (isLastLayerParam) {
            const targetAnimInLayer = parseInt(label.dataset.animInLayer);
            const lastAnimIndex = specData.layers[targetLayerIndex].animations.length - 1;
            // Check if dropping on last param row would change position
            if (targetAnimInLayer === lastAnimIndex) {
              let targetIndex = targetLayerIndex + 1;
              if (draggedLayerIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedLayerIndex !== targetIndex;
            }
          } else if (draggedType === 'layer' && targetType === 'layer') {
            // Only very close to the top divider line is valid for layer drops (within 10px)
            const distanceFromTop = e.clientY - rect.top;
            if (distanceFromTop <= 10) {
              let targetIndex = targetLayerIndex;
              if (draggedLayerIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedLayerIndex !== targetIndex;
            }
          } else if (draggedType === 'animation' && targetType === 'animation') {
            // Check if animation drop would change position
            if (draggedLayerIndex !== targetLayerIndex) {
              // Moving to a different layer - always a valid change
              wouldChangePosition = true;
            } else {
              // Moving within same layer - check if position changes
              const targetAnimIndex = parseInt(label.dataset.animInLayer);
              let targetIndex = targetAnimIndex;
              if (dropPosition === 'after') targetIndex++;
              if (draggedAnimIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedAnimIndex !== targetIndex;
            }
          }

          // Only show indicators if the drop would actually change the position
          if (!wouldChangePosition) return;

          // Clear previous indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });
          const bottomDivider = document.querySelector('.timeline-bottom-divider');
          const bottomTrack = document.querySelector('.timeline-bottom-track');
          if (bottomDivider) bottomDivider.classList.remove('drag-over-top');
          if (bottomTrack) bottomTrack.classList.remove('drag-over-top');

          // For animations dropping on layer headers: show bottom indicator
          if (isDropOnLayerHeader) {
            // Find corresponding track and add indicator to both
            const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
            const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
            const labelIndex = allLabels.indexOf(label);

            label.classList.add('drag-over-bottom');
            if (labelIndex >= 0 && allTracks[labelIndex]) {
              allTracks[labelIndex].classList.add('drag-over-bottom');
            }
          }
          // For layers dropping on last layer parameters: only show bottom indicator
          else if (isLastLayerParam) {
            const targetAnimInLayer = parseInt(label.dataset.animInLayer);
            const lastAnimIndex = specData.layers[targetLayerIndex].animations.length - 1;
            // Only show indicator on the last parameter row, and not on the dragged layer's own parameters
            if (targetAnimInLayer === lastAnimIndex && targetLayerIndex !== draggedLayerIndex) {
              // Find corresponding track and add indicator to both
              const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
              const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
              const labelIndex = allLabels.indexOf(label);

              label.classList.add('drag-over-bottom');
              if (labelIndex >= 0 && allTracks[labelIndex]) {
                allTracks[labelIndex].classList.add('drag-over-bottom');
              }
            }
          }
          // For layers: section headers only respond very close to the divider line at the top
          else if (draggedType === 'layer' && targetType === 'layer') {
            // Only show indicator when hovering very close to the divider line (within 10px of top)
            const rect = label.getBoundingClientRect();
            const distanceFromTop = e.clientY - rect.top;
            if (distanceFromTop <= 10) {
              // Find all labels and tracks
              const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
              const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
              const labelIndex = allLabels.indexOf(label);

              // Show indicator on both label and corresponding track
              label.classList.add('drag-over-top');
              if (labelIndex >= 0 && allTracks[labelIndex]) {
                allTracks[labelIndex].classList.add('drag-over-top');
              }
            }
          } else {
            // For animations, show both top and bottom indicators normally
            const dropPositionDisplay = e.clientY < midpoint ? 'top' : 'bottom';

            // Find corresponding track and add indicator to both
            const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
            const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
            const labelIndex = allLabels.indexOf(label);

            if (dropPositionDisplay === 'top') {
              label.classList.add('drag-over-top');
              if (labelIndex >= 0 && allTracks[labelIndex]) {
                allTracks[labelIndex].classList.add('drag-over-top');
              }
            } else {
              label.classList.add('drag-over-bottom');
              if (labelIndex >= 0 && allTracks[labelIndex]) {
                allTracks[labelIndex].classList.add('drag-over-bottom');
              }
            }
          }

          e.dataTransfer.dropEffect = 'move';
        });

        // Drop - perform the move
        label.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();

          if (!draggedElement || draggedElement === label) return;

          const targetType = label.dataset.dragType;
          const targetLayerIndex = parseInt(label.dataset.layerIndex);
          const targetAnimIndex = label.dataset.animInLayer ? parseInt(label.dataset.animInLayer) : null;

          // Calculate drop position
          const rect = label.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          let dropPosition = e.clientY < midpoint ? 'before' : 'after';

          // Check if dropping layer on last layer's parameter row (to drop at bottom)
          const isLastLayer = targetLayerIndex === specData.layers.length - 1;
          const isLastLayerParam = draggedType === 'layer' && targetType === 'animation' && isLastLayer;

          if (isLastLayerParam) {
            // Dropping on last layer's parameter row = insert after last layer
            const lastAnimInLayer = specData.layers[targetLayerIndex].animations.length - 1;
            if (targetAnimIndex === lastAnimInLayer) {
              performLayerMove(draggedLayerIndex, targetLayerIndex, 'after');
            }
          }
          // For layer drops: only allow drops in top half (before)
          else if (draggedType === 'layer' && targetType === 'layer') {
            if (dropPosition === 'after') {
              // Don't allow drops on bottom half of any section header
              return;
            }
            // Moving a layer
            performLayerMove(draggedLayerIndex, targetLayerIndex, dropPosition);
          }
          // For dropping animations on layer headers (empty sections or add to top)
          else if (draggedType === 'animation' && targetType === 'layer') {
            const sourceLayer = specData.layers[draggedLayerIndex];
            const targetLayer = specData.layers[targetLayerIndex];
            const anim = sourceLayer.animations.splice(draggedAnimIndex, 1)[0];

            // Insert at the beginning of the target layer
            targetLayer.animations.splice(0, 0, anim);
            renderTimeline();
          }
          else if (draggedType === 'animation' && targetType === 'animation') {
            // Moving an animation (within same layer or across layers)
            if (draggedLayerIndex === targetLayerIndex) {
              // Moving within the same layer
              performAnimationMove(draggedLayerIndex, draggedAnimIndex, targetAnimIndex, dropPosition);
            } else {
              // Moving to a different layer
              const sourceLayer = specData.layers[draggedLayerIndex];
              const targetLayer = specData.layers[targetLayerIndex];
              const anim = sourceLayer.animations.splice(draggedAnimIndex, 1)[0];

              let targetIndex = targetAnimIndex;
              if (dropPosition === 'after') targetIndex++;

              targetLayer.animations.splice(targetIndex, 0, anim);
              renderTimeline();
            }
          }

          // Clear indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });
          const bottomDivider = document.querySelector('.timeline-bottom-divider');
          const bottomTrack = document.querySelector('.timeline-bottom-track');
          if (bottomDivider) bottomDivider.classList.remove('drag-over-top');
          if (bottomTrack) bottomTrack.classList.remove('drag-over-top');
        });
      });

      // Set up drag handlers for bottom divider
      const bottomDivider = document.querySelector('.timeline-bottom-divider');
      const bottomTrack = document.querySelector('.timeline-bottom-track');
      if (bottomDivider && bottomTrack) {
        bottomDivider.addEventListener('dragover', (e) => {
          if (!draggedElement || draggedType !== 'layer') return;

          // Check if dragged layer is already the last layer
          const isLastLayer = draggedLayerIndex === specData.layers.length - 1;
          if (isLastLayer) {
            // Don't show indicator if already at the end
            return;
          }

          e.preventDefault();
          e.stopPropagation();

          // Clear previous indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });

          // Show indicator on both bottom elements
          bottomDivider.classList.add('drag-over-top');
          bottomTrack.classList.add('drag-over-top');
          e.dataTransfer.dropEffect = 'move';
        });

        bottomDivider.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();

          if (!draggedElement || draggedType !== 'layer') return;

          // Move layer to end
          performLayerMove(draggedLayerIndex, specData.layers.length - 1, 'after');

          // Clear indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });
          bottomDivider.classList.remove('drag-over-top');
          bottomTrack.classList.remove('drag-over-top');
        });

        bottomDivider.addEventListener('dragleave', (e) => {
          bottomDivider.classList.remove('drag-over-top');
          bottomTrack.classList.remove('drag-over-top');
        });
      }

      // Set up + button handlers
      const addButtons = document.querySelectorAll('.timeline-label-add-btn');
      addButtons.forEach(btn => {
        // Prevent drag when clicking the + button
        btn.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();

          // Get the parent label to find which layer and position
          const label = btn.closest('.timeline-label');
          if (!label) return;

          const layerIndex = parseInt(label.dataset.layerIndex);
          const layer = specData.layers[layerIndex];
          if (!layer) return;

          // Determine insert position
          let insertIndex;
          if (label.classList.contains('layer-header')) {
            // If clicking on header, add to end of layer
            insertIndex = layer.animations.length;
          } else {
            // If clicking on animation row, add after it
            const animInLayer = parseInt(label.dataset.animInLayer);
            insertIndex = animInLayer + 1;
          }

          // Create new animation with default values
          const newAnimation = {
            property: "Add parameter",
            description: "Add description",
            timing: {
              delay: 0,
              duration: 300
            },
            easing: {
              type: "-",
              cubicBezier: ""
            },
            values: {
              formatted: {
                startValue: "-",
                endValue: "-"
              }
            }
          };

          // Insert the new animation
          layer.animations.splice(insertIndex, 0, newAnimation);

          // Re-render timeline
          renderTimeline();

          // Calculate the global animation index for the newly added animation
          let globalAnimIndex = 0;
          for (let i = 0; i < layerIndex; i++) {
            globalAnimIndex += specData.layers[i].animations.length;
          }
          globalAnimIndex += insertIndex;

          // Show the info box for the newly added animation
          setTimeout(() => {
            showAnimationDetails(globalAnimIndex);

            // Add selected class to the new bar and label
            const newBar = document.querySelector(`.timeline-bar[data-anim-index="${globalAnimIndex}"]`);
            const newLabel = document.querySelector(`.timeline-label.indented[data-anim-index="${globalAnimIndex}"]`);
            if (newBar) newBar.classList.add('selected');
            if (newLabel) newLabel.classList.add('selected');
          }, 0);
        });
      });

      // Set up section divider button handlers
      const sectionDividerButtons = document.querySelectorAll('.section-divider-add-btn');
      sectionDividerButtons.forEach(btn => {
        btn.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();

          // Determine insert position
          let insertIndex;
          const parentLabel = btn.closest('.timeline-label');
          const isBottomDivider = btn.closest('.timeline-bottom-divider');

          if (isBottomDivider) {
            // Bottom divider - add to end
            insertIndex = specData.layers.length;
          } else if (parentLabel) {
            // Section header button - insert before this layer
            const layerIndex = parseInt(parentLabel.dataset.layerIndex);
            insertIndex = layerIndex;
          } else {
            return;
          }

          // Create new layer with one default animation
          const newLayer = {
            layerName: "New section",
            animations: [
              {
                property: "Add parameter",
                description: "Add description",
                timing: {
                  delay: 0,
                  duration: 300
                },
                easing: {
                  type: "-",
                  cubicBezier: ""
                },
                values: {
                  formatted: {
                    startValue: "-",
                    endValue: "-"
                  }
                }
              }
            ]
          };

          // Insert the new layer
          specData.layers.splice(insertIndex, 0, newLayer);

          // Re-render timeline
          renderTimeline();

          // Calculate the global animation index for the newly added parameter
          let globalAnimIndex = 0;
          for (let i = 0; i < insertIndex; i++) {
            globalAnimIndex += specData.layers[i].animations.length;
          }
          // The new parameter is at index 0 in the new layer

          // Show the info box for the newly added animation
          setTimeout(() => {
            showAnimationDetails(globalAnimIndex);

            // Add selected class to the new bar and label
            const newBar = document.querySelector(`.timeline-bar[data-anim-index="${globalAnimIndex}"]`);
            const newLabel = document.querySelector(`.timeline-label.indented[data-anim-index="${globalAnimIndex}"]`);
            if (newBar) newBar.classList.add('selected');
            if (newLabel) newLabel.classList.add('selected');
          }, 0);
        });
      });
    }

    // Setup hover zones for add buttons
    function setupAddButtonHoverZones() {
      const labelsColumn = document.querySelector('.timeline-labels-column');
      const labels = document.querySelectorAll('.timeline-label');
      const bottomDivider = document.querySelector('.timeline-bottom-divider');

      if (!labelsColumn) return;

      labelsColumn.addEventListener('mousemove', (e) => {
        const columnRect = labelsColumn.getBoundingClientRect();
        const mouseY = e.clientY;

        // Find all buttons and their distances
        let closestButton = null;
        let closestDistance = Infinity;

        // Check each label's divider line
        labels.forEach(label => {
          const btn = label.querySelector('.timeline-label-add-btn');
          const sectionBtn = label.querySelector('.section-divider-add-btn');
          const rect = label.getBoundingClientRect();
          const halfCellHeight = rect.height / 2;

          // Check regular divider line (at bottom of cell)
          if (btn) {
            const dividerY = rect.bottom;
            const distanceFromDivider = Math.abs(mouseY - dividerY);
            if (distanceFromDivider <= halfCellHeight) {
              if (distanceFromDivider < closestDistance) {
                closestDistance = distanceFromDivider;
                closestButton = btn;
              }
            }
          }

          // Check section divider line (at top of cell, for elements with has-divider)
          if (sectionBtn) {
            const sectionDividerY = rect.top; // Border-top is at element's top edge
            const distanceFromSectionDivider = Math.abs(mouseY - sectionDividerY);
            // Use a larger hover zone for section dividers (about 15px total margin-top / 2)
            if (distanceFromSectionDivider <= 15) {
              if (distanceFromSectionDivider < closestDistance) {
                closestDistance = distanceFromSectionDivider;
                closestButton = sectionBtn;
              }
            }
          }
        });

        // Check bottom divider
        if (bottomDivider) {
          const bottomBtn = bottomDivider.querySelector('.section-divider-add-btn');
          if (bottomBtn) {
            const rect = bottomDivider.getBoundingClientRect();
            const dividerY = rect.top; // Border-top is at element's top edge
            const distanceFromDivider = Math.abs(mouseY - dividerY);
            if (distanceFromDivider <= 15) {
              if (distanceFromDivider < closestDistance) {
                closestDistance = distanceFromDivider;
                closestButton = bottomBtn;
              }
            }
          }
        }

        // Hide all buttons first
        labels.forEach(label => {
          const btn = label.querySelector('.timeline-label-add-btn');
          const sectionBtn = label.querySelector('.section-divider-add-btn');
          if (btn) btn.classList.remove('visible');
          if (sectionBtn) sectionBtn.classList.remove('visible');
        });
        if (bottomDivider) {
          const bottomBtn = bottomDivider.querySelector('.section-divider-add-btn');
          if (bottomBtn) bottomBtn.classList.remove('visible');
        }

        // Show only the closest button
        if (closestButton) {
          closestButton.classList.add('visible');
        }
      });

      labelsColumn.addEventListener('mouseleave', () => {
        // Hide all buttons when mouse leaves the column
        labels.forEach(label => {
          const btn = label.querySelector('.timeline-label-add-btn');
          const sectionBtn = label.querySelector('.section-divider-add-btn');
          if (btn) btn.classList.remove('visible');
          if (sectionBtn) sectionBtn.classList.remove('visible');
        });

        // Hide bottom divider button
        if (bottomDivider) {
          const bottomBtn = bottomDivider.querySelector('.section-divider-add-btn');
          if (bottomBtn) bottomBtn.classList.remove('visible');
        }
      });
    }

    // Setup resize handles for timeline bars
    function setupResizeHandles() {
      const handles = document.querySelectorAll('.timeline-bar-resize-handle');

      handles.forEach(handle => {
        handle.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          e.preventDefault();

          const bar = handle.closest('.timeline-bar');
          const animIndex = parseInt(bar.dataset.animIndex);
          const handleType = handle.dataset.handle; // 'left' or 'right'
          const isSpring = bar.dataset.isSpring === 'true';

          // Find the animation in specData
          let currentAnimIndex = 0;
          let targetLayer = null;
          let targetAnim = null;
          let layerIndex = -1;
          let animInLayerIndex = -1;

          for (let i = 0; i < specData.layers.length; i++) {
            const layer = specData.layers[i];
            for (let j = 0; j < layer.animations.length; j++) {
              if (currentAnimIndex === animIndex) {
                targetLayer = layer;
                targetAnim = layer.animations[j];
                layerIndex = i;
                animInLayerIndex = j;
                break;
              }
              currentAnimIndex++;
            }
            if (targetAnim) break;
          }

          if (!targetAnim) return;

          const startDelay = targetAnim.timing.delay;
          const startDuration = targetAnim.timing.duration;
          const startX = e.clientX;
          const timelineGrid = document.querySelector('.timeline-grid-lines').parentElement;
          const gridRect = timelineGrid.getBoundingClientRect();
          const specDuration = specData.workArea.duration;
          const currentViewDuration = viewDuration || specDuration;

          // Add dragging class to maintain hover state
          bar.classList.add('dragging-resize');

          // Function to snap to 25ms increments
          function snapToIncrement(value) {
            return Math.round(value / 25) * 25;
          }

          function onMouseMove(moveEvent) {
            const deltaX = moveEvent.clientX - startX;
            const deltaTime = (deltaX / gridRect.width) * currentViewDuration;

            let newDelay, newDuration;

            if (handleType === 'left') {
              // Adjust delay (start time)
              newDelay = snapToIncrement(startDelay + deltaTime);
              newDelay = Math.max(0, newDelay); // Can't go below 0

              // Adjust duration to compensate (keep end time the same)
              newDuration = startDelay + startDuration - newDelay;
              newDuration = Math.max(25, newDuration); // Minimum 25ms duration

              // Update animation data
              targetAnim.timing.delay = newDelay;
              targetAnim.timing.duration = newDuration;
            } else {
              // Adjust duration (end time)
              newDelay = targetAnim.timing.delay;
              newDuration = snapToIncrement(startDuration + deltaTime);
              newDuration = Math.max(25, newDuration); // Minimum 25ms duration

              // Update animation data
              targetAnim.timing.duration = newDuration;
            }

            // Update bar position and width directly without full re-render
            const startPercent = (newDelay / currentViewDuration) * 100;
            const widthPercent = (newDuration / currentViewDuration) * 100;
            bar.style.left = `${startPercent}%`;
            bar.style.width = `${widthPercent}%`;

            // Update info box if this animation is selected
            if (selectedAnimation === animIndex) {
              showAnimationDetails(animIndex);
            }
          }

          function onMouseUp() {
            // Remove dragging class
            bar.classList.remove('dragging-resize');

            // Store whether this animation was selected before re-render
            const wasSelected = selectedAnimation === animIndex;

            // Do a full re-render to ensure everything is consistent
            renderTimeline();

            // Restore info box if it was showing (renderTimeline clears the detail panel)
            if (wasSelected) {
              showAnimationDetails(animIndex);
            }

            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          }

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
      });
    }

    // Setup bar dragging for moving timeline position or reordering
    function setupBarDragging() {
      const bars = document.querySelectorAll('.timeline-bar');

      bars.forEach(bar => {
        bar.addEventListener('mousedown', (e) => {
          // Don't allow dragging in read mode
          if (!isEditMode) return;

          // Don't interfere with resize handles
          if (e.target.classList.contains('timeline-bar-resize-handle')) return;

          // Don't interfere with text that's currently being edited (focused)
          const textEl = bar.querySelector('.timeline-bar-text.edit-only');
          if (textEl && document.activeElement === textEl) return;

          const animIndex = parseInt(bar.dataset.animIndex);
          const startX = e.clientX;
          const startY = e.clientY;
          const threshold = 5; // pixels to move before determining direction
          let dragDirection = null; // 'horizontal', 'vertical', or null
          let isDragging = false;

          // Find the animation in specData
          let currentAnimIndex = 0;
          let targetAnim = null;
          let layerIndex = -1;
          let animInLayerIndex = -1;

          for (let i = 0; i < specData.layers.length; i++) {
            const layer = specData.layers[i];
            for (let j = 0; j < layer.animations.length; j++) {
              if (currentAnimIndex === animIndex) {
                targetAnim = layer.animations[j];
                layerIndex = i;
                animInLayerIndex = j;
                break;
              }
              currentAnimIndex++;
            }
            if (targetAnim) break;
          }

          if (!targetAnim) return;

          const startDelay = targetAnim.timing.delay;
          const timelineGrid = document.querySelector('.timeline-grid-lines').parentElement;
          const gridRect = timelineGrid.getBoundingClientRect();
          const specDuration = specData.workArea.duration;
          const currentViewDuration = viewDuration || specDuration;

          function snapToIncrement(value) {
            return Math.round(value / 25) * 25;
          }

          function onMouseMove(moveEvent) {
            // Check if text is being edited - if so, abort dragging
            const textEl = bar.querySelector('.timeline-bar-text.edit-only');
            if (textEl && textEl.dataset.editing === 'true') {
              // Clean up and exit
              document.removeEventListener('mousemove', onMouseMove);
              document.removeEventListener('mouseup', onMouseUp);
              return;
            }

            const deltaX = moveEvent.clientX - startX;
            const deltaY = moveEvent.clientY - startY;

            // Determine drag direction if not yet determined
            if (!dragDirection && (Math.abs(deltaX) > threshold || Math.abs(deltaY) > threshold)) {
              moveEvent.preventDefault(); // Prevent default behavior once we start dragging

              if (Math.abs(deltaX) > Math.abs(deltaY)) {
                dragDirection = 'horizontal';
                bar.classList.add('dragging-resize');
              } else {
                dragDirection = 'vertical';
                // Start vertical drag - add visual feedback
                bar.classList.add('dragging-vertical');
                const label = document.querySelector(`.timeline-label.indented[data-anim-index="${animIndex}"]`);
                if (label) {
                  // Programmatically trigger dragstart on the label
                  label.classList.add('dragging');
                  document.querySelectorAll('.timeline-label-add-btn, .section-divider-add-btn').forEach(btn => {
                    btn.classList.remove('visible');
                  });
                }
              }
              isDragging = true;
            }

            if (!isDragging) return;

            if (dragDirection === 'horizontal') {
              // Horizontal drag - move the bar's position in time
              const deltaTime = (deltaX / gridRect.width) * currentViewDuration;
              let newDelay = snapToIncrement(startDelay + deltaTime);
              newDelay = Math.max(0, newDelay);

              // Update animation data
              targetAnim.timing.delay = newDelay;

              // Update bar position directly
              const startPercent = (newDelay / currentViewDuration) * 100;
              bar.style.left = `${startPercent}%`;

              // Update info box if selected
              if (selectedAnimation === animIndex) {
                showAnimationDetails(animIndex);
              }
            } else if (dragDirection === 'vertical') {
              // Vertical drag - show drop indicators
              const animLabels = document.querySelectorAll('.timeline-label.indented');
              const layerHeaders = document.querySelectorAll('.timeline-label.layer-header');
              let closestElement = null;
              let closestDistance = Infinity;
              let isLayerHeader = false;

              // Check animation labels
              animLabels.forEach(label => {
                const rect = label.getBoundingClientRect();
                const distance = Math.abs(rect.top + rect.height / 2 - moveEvent.clientY);
                if (distance < closestDistance) {
                  closestDistance = distance;
                  closestElement = label;
                  isLayerHeader = false;
                }
              });

              // Also check layer headers (for empty sections)
              layerHeaders.forEach(header => {
                const rect = header.getBoundingClientRect();
                const distance = Math.abs(rect.top + rect.height / 2 - moveEvent.clientY);
                if (distance < closestDistance) {
                  closestDistance = distance;
                  closestElement = header;
                  isLayerHeader = true;
                }
              });

              // Remove all drop indicators first
              document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
                l.classList.remove('drag-over-top', 'drag-over-bottom');
              });

              // Show drop indicator on closest element only (extends across full timeline)
              if (closestElement) {
                if (isLayerHeader) {
                  // For layer headers, always show bottom indicator (add to section)
                  const headerLayerIndex = parseInt(closestElement.dataset.layerIndex);
                  if (headerLayerIndex !== layerIndex) {
                    // Only show if dropping into a different section
                    closestElement.classList.add('drag-over-bottom');
                  }
                } else if (closestElement.dataset.animIndex !== String(animIndex)) {
                  // For animation labels, show top/bottom based on position
                  const rect = closestElement.getBoundingClientRect();
                  const midpoint = rect.top + rect.height / 2;

                  if (moveEvent.clientY < midpoint) {
                    closestElement.classList.add('drag-over-top');
                  } else {
                    closestElement.classList.add('drag-over-bottom');
                  }
                }
              }
            }
          }

          function onMouseUp(upEvent) {
            // If we dragged, prevent the click event from firing
            if (isDragging) {
              const preventClick = (e) => {
                e.stopPropagation();
                e.preventDefault();
                bar.removeEventListener('click', preventClick, true);
              };
              bar.addEventListener('click', preventClick, true);
            }

            if (dragDirection === 'horizontal') {
              bar.classList.remove('dragging-resize');

              // Store selection state
              const wasSelected = selectedAnimation === animIndex;

              // Re-render to finalize
              renderTimeline();

              // Restore info box if needed
              if (wasSelected) {
                showAnimationDetails(animIndex);
              }
            } else if (dragDirection === 'vertical') {
              // Complete the drop
              const animLabels = document.querySelectorAll('.timeline-label.indented');
              const layerHeaders = document.querySelectorAll('.timeline-label.layer-header');
              let targetElement = null;
              let dropPosition = null;
              let isLayerHeader = false;

              // Check animation labels
              animLabels.forEach(label => {
                if (label.classList.contains('drag-over-top') || label.classList.contains('drag-over-bottom')) {
                  targetElement = label;
                  dropPosition = label.classList.contains('drag-over-top') ? 'before' : 'after';
                  isLayerHeader = false;
                }
              });

              // Check layer headers
              layerHeaders.forEach(header => {
                if (header.classList.contains('drag-over-bottom')) {
                  targetElement = header;
                  isLayerHeader = true;
                }
              });

              if (targetElement) {
                if (isLayerHeader) {
                  // Dropping on a layer header - add to beginning of that section
                  const targetLayerIndex = parseInt(targetElement.dataset.layerIndex);
                  const sourceLayer = specData.layers[layerIndex];
                  const targetLayer = specData.layers[targetLayerIndex];
                  const anim = sourceLayer.animations.splice(animInLayerIndex, 1)[0];

                  // Insert at beginning of target layer
                  targetLayer.animations.splice(0, 0, anim);
                  renderTimeline();
                } else if (targetElement.dataset.animIndex !== String(animIndex)) {
                  // Dropping on an animation label
                  const targetAnimIndex = parseInt(targetElement.dataset.animIndex);
                  const targetLayerIndex = parseInt(targetElement.dataset.layerIndex);
                  const targetAnimInLayerIndex = parseInt(targetElement.dataset.animInLayer);

                  // Perform the move
                  if (layerIndex === targetLayerIndex) {
                    // Moving within the same layer
                    let targetIndex = targetAnimInLayerIndex;
                    if (dropPosition === 'after') targetIndex++;
                    if (animInLayerIndex < targetIndex) targetIndex--;

                    if (animInLayerIndex !== targetIndex) {
                      const layer = specData.layers[layerIndex];
                      const anim = layer.animations.splice(animInLayerIndex, 1)[0];
                      layer.animations.splice(targetIndex, 0, anim);
                      renderTimeline();
                    }
                  } else {
                    // Moving to a different layer
                    const sourceLayer = specData.layers[layerIndex];
                    const targetLayer = specData.layers[targetLayerIndex];
                    const anim = sourceLayer.animations.splice(animInLayerIndex, 1)[0];

                    let targetIndex = targetAnimInLayerIndex;
                    if (dropPosition === 'after') targetIndex++;

                    targetLayer.animations.splice(targetIndex, 0, anim);
                    renderTimeline();
                  }
                }
              }

              // Cleanup
              bar.classList.remove('dragging-vertical');
              const label = document.querySelector(`.timeline-label.indented[data-anim-index="${animIndex}"]`);
              if (label) label.classList.remove('dragging');

              document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
                l.classList.remove('drag-over-top', 'drag-over-bottom');
              });
            }

            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          }

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
      });
    }

    // Setup bar text editing
    function setupBarTextEditing() {
      const textElements = document.querySelectorAll('.timeline-bar-text.edit-only[contenteditable="true"]');

      textElements.forEach(textEl => {
        let mouseDownX = 0;
        let mouseDownY = 0;
        let isDragging = false;
        let mouseDownTime = 0;
        let isEditing = false;

        textEl.addEventListener('mousedown', (e) => {
          // If already editing, stop propagation to prevent bar dragging
          if (isEditing) {
            e.stopPropagation();
            return;
          }

          // Prevent default text selection behavior
          e.preventDefault();

          // Track mouse position for drag detection
          mouseDownX = e.clientX;
          mouseDownY = e.clientY;
          mouseDownTime = Date.now();
          isDragging = false;

          // Don't stop propagation - let the bar handle it for potential dragging
        });

        textEl.addEventListener('mousemove', (e) => {
          // If editing, block all mouse events
          if (isEditing) {
            e.stopPropagation();
            return;
          }

          if (mouseDownTime === 0) return;

          const deltaX = Math.abs(e.clientX - mouseDownX);
          const deltaY = Math.abs(e.clientY - mouseDownY);
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

          // If moved more than 5px, consider it a drag
          if (distance > 5) {
            isDragging = true;
          }
        });

        textEl.addEventListener('mouseup', (e) => {
          // If editing, block all mouse events
          if (isEditing) {
            e.stopPropagation();
            return;
          }

          const clickDuration = Date.now() - mouseDownTime;
          mouseDownTime = 0;

          // If not dragging and was a quick click, enter edit mode
          if (!isDragging && clickDuration < 300) {
            e.stopPropagation();
            e.preventDefault();
            enterEditMode(textEl);
          }

          isDragging = false;
        });

        // Enter edit mode function
        function enterEditMode(element) {
          isEditing = true;
          const originalText = element.textContent.trim();

          // Mark as editing with data attribute so bar dragging can detect it
          element.dataset.editing = 'true';

          // Focus the element
          element.focus();

          // Select all text
          const range = document.createRange();
          range.selectNodeContents(element);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);

          // Block mouse events while editing
          const blockMouseEvents = (e) => {
            e.stopPropagation();
          };
          element.addEventListener('mousedown', blockMouseEvents, true);
          element.addEventListener('mousemove', blockMouseEvents, true);
          element.addEventListener('mouseup', blockMouseEvents, true);

          // Handle Enter and Escape keys
          const handleKeyDown = (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              element.blur();
            } else if (e.key === 'Escape') {
              element.textContent = originalText;
              element.blur();
            }
          };

          // Prevent multi-line paste
          const handlePaste = (e) => {
            e.preventDefault();
            const text = (e.clipboardData || window.clipboardData).getData('text');
            // Replace any line breaks with spaces
            const singleLineText = text.replace(/[\r\n]+/g, ' ');
            document.execCommand('insertText', false, singleLineText);
          };

          // Save changes on blur
          const handleBlur = () => {
            const newText = element.textContent.trim();

            // Remove event listeners
            element.removeEventListener('keydown', handleKeyDown);
            element.removeEventListener('paste', handlePaste);
            element.removeEventListener('blur', handleBlur);
            element.removeEventListener('mousedown', blockMouseEvents, true);
            element.removeEventListener('mousemove', blockMouseEvents, true);
            element.removeEventListener('mouseup', blockMouseEvents, true);

            // Clear editing flag
            element.dataset.editing = 'false';
            isEditing = false;

            const animIndex = parseInt(element.dataset.animIndex);

            if (newText === '') {
              // Don't allow empty text, restore original
              let currentIndex = 0;
              for (const layer of getCurrentSpecData().layers) {
                for (const anim of layer.animations) {
                  if (currentIndex === animIndex) {
                    element.textContent = anim.description || anim.property;
                    return;
                  }
                  currentIndex++;
                }
              }
              return;
            }

            // Update the animation's customDescription using the helper function
            // This will refresh all views and update the info box
            updateAnimationField(animIndex, 'customDescription', newText);
          };

          element.addEventListener('keydown', handleKeyDown);
          element.addEventListener('paste', handlePaste);
          element.addEventListener('blur', handleBlur);
        }
      });
    }

    // Perform layer move
    function performLayerMove(fromIndex, toIndex, position) {
      // Calculate the actual target index
      let targetIndex = toIndex;
      if (position === 'after') targetIndex++;
      if (fromIndex < targetIndex) targetIndex--;

      if (fromIndex === targetIndex) return;

      // Remove from old position
      const layer = specData.layers.splice(fromIndex, 1)[0];

      // Insert at new position
      specData.layers.splice(targetIndex, 0, layer);

      // Re-render based on current view mode
      if (viewMode === 'table') {
        renderTableView();
      } else {
        renderTimeline();
      }

      // Maintain selection if needed
      if (selectedAnimation !== null) {
        // Recalculate selected animation index
        setTimeout(() => {
          updatePlayhead();
        }, 0);
      }
    }

    // Perform animation move within layer
    function performAnimationMove(layerIndex, fromAnimIndex, toAnimIndex, position) {
      // Calculate the actual target index
      let targetIndex = toAnimIndex;
      if (position === 'after') targetIndex++;
      if (fromAnimIndex < targetIndex) targetIndex--;

      if (fromAnimIndex === targetIndex) return;

      const layer = specData.layers[layerIndex];

      // Remove from old position
      const anim = layer.animations.splice(fromAnimIndex, 1)[0];

      // Insert at new position
      layer.animations.splice(targetIndex, 0, anim);

      // Re-render based on current view mode
      if (viewMode === 'table') {
        renderTableView();
      } else {
        renderTimeline();
      }

      // Maintain selection if needed
      if (selectedAnimation !== null) {
        setTimeout(() => {
          updatePlayhead();
        }, 0);
      }
    }

    // Setup playhead dragging
    let playheadListenersAdded = false;
    function setupPlayheadDragging() {
      const playhead = document.getElementById('playhead');
      if (!playhead) return;

      const timelineContainer = document.querySelector('.timeline-container');
      const timelineContent = document.querySelector('.timeline-content-column');

      function onMouseDown(e) {
        isDraggingPlayhead = true;
        video.pause();
        const playPauseBtn = document.getElementById('playPauseBtn');
        if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon">â–¶</span>';
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        onMouseMove(e);
      }

      function onMouseMove(e) {
        const containerRect = timelineContainer.getBoundingClientRect();
        const contentRect = timelineContent.getBoundingClientRect();
        let x = e.clientX - contentRect.left;

        // Calculate percentage of full width (not content width)
        let percentage = x / contentRect.width;

        // Clamp percentage between 0 and 1 (allow full range)
        percentage = Math.max(0, Math.min(percentage, 1.0));

        // Calculate pixel position relative to viewport
        const leftPosition = contentRect.left + (percentage * contentRect.width);
        playhead.style.left = `${leftPosition}px`;
        playhead.style.top = `${containerRect.top + 44}px`;
        playhead.style.bottom = `${window.innerHeight - containerRect.bottom}px`;

        if (video.duration && specData) {
          // Convert drag percentage to spec time (use current view duration for zoom)
          const currentViewDuration = viewDuration || specData.workArea.duration;
          const specTimeMs = (percentage * currentViewDuration);

          // Store this position for when we release
          lastDraggedSpecTimeMs = specTimeMs;

          // Calculate target video time - direct time mapping (ms to seconds)
          const targetVideoTime = specTimeMs / 1000;
          lastDraggedVideoTime = Math.min(targetVideoTime, video.duration);

          // Use throttled seek to prevent multiple competing seeks
          scheduleVideoSeek(lastDraggedVideoTime);

          // Display the exact spec time we're dragging to
          const playheadTimeDisplay = document.getElementById('playheadTimeDisplay');
          if (playheadTimeDisplay) {
            playheadTimeDisplay.textContent = `${specTimeMs.toFixed(0)}ms`;
          }
        }
      }

      function onMouseUp() {
        isDraggingPlayhead = false;
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);

        // Set flag IMMEDIATELY to freeze display updates (before RAF executes)
        justFinishedDragging = true;

        // Schedule final seek in its own RAF to ensure it executes AFTER any pending drag RAF
        requestAnimationFrame(() => {
          // Now set the final video time - this will be the last seek
          if (lastDraggedVideoTime !== null) {
            video.currentTime = lastDraggedVideoTime;
          }

          // Clear the flag after everything settles
          setTimeout(() => {
            justFinishedDragging = false;
            lastDraggedSpecTimeMs = null;
            lastDraggedVideoTime = null;
          }, 100);
        });
      }

      playhead.addEventListener('mousedown', onMouseDown);

      // Only add window/container listeners once to avoid duplicates
      if (!playheadListenersAdded) {
        playheadListenersAdded = true;

        // Update playhead position on window resize and scroll
        window.addEventListener('resize', () => {
          if (!isDraggingPlayhead) {
            updatePlayhead();
          }
        });

        // Update playhead position on scroll
        window.addEventListener('scroll', () => {
          if (!isDraggingPlayhead) {
            updatePlayhead();
          }
        });

        // Also update on timeline container scroll
        const timelineContainer = document.querySelector('.timeline-container');
        if (timelineContainer) {
          timelineContainer.addEventListener('scroll', () => {
            if (!isDraggingPlayhead) {
              updatePlayhead();
            }
          });
        }
      }
    }

    // Toggle color picker panel
    function toggleColorPicker(event, animIndex) {
      event.stopPropagation();
      const panel = document.getElementById('colorPickerPanel');
      const dot = document.getElementById('colorPickerDot');

      if (panel.classList.contains('visible')) {
        panel.classList.remove('visible');
      } else {
        panel.classList.add('visible');

        // Position panel above the dot
        const dotRect = dot.getBoundingClientRect();
        panel.style.left = '-60px';
        panel.style.bottom = 'calc(100% + 12px)';
      }
    }

    // Change animation color
    function changeAnimationColor(animIndex, color) {
      // Find the animation in specData
      let currentIndex = 0;
      let targetAnim = null;

      for (let i = 0; i < specData.layers.length; i++) {
        const layer = specData.layers[i];
        for (let j = 0; j < layer.animations.length; j++) {
          if (currentIndex === animIndex) {
            targetAnim = layer.animations[j];
            break;
          }
          currentIndex++;
        }
        if (targetAnim) break;
      }

      if (targetAnim) {
        targetAnim.customColor = color;
        renderTimeline();

        // Re-show the info box with updated color
        setTimeout(() => {
          showAnimationDetails(animIndex);
        }, 0);
      }
    }

    // Close color picker when clicking outside
    document.addEventListener('click', (e) => {
      const panel = document.getElementById('colorPickerPanel');
      const dot = document.getElementById('colorPickerDot');
      if (panel && !panel.contains(e.target) && e.target !== dot) {
        panel.classList.remove('visible');
      }
    });

    // Show animation details
    // PATTERN FOR EDITABLE FIELDS:
    // - In edit mode (isEditMode === true): Render <input> fields with onblur/onkeydown handlers
    // - In read mode (isEditMode === false): Render plain text (selectable but not editable)
    // - Use: if (isEditMode) { /* input */ } else { /* plain text */ }
    // - Call updateAnimationField(animIndex, fieldName, newValue) to save changes
    function showAnimationDetails(animIndex) {
      // Store the selected animation index
      selectedAnimation = animIndex;

      let currentIndex = 0;
      let anim = null;
      let layer = null;
      let layerIndex = -1;

      for (let lIdx = 0; lIdx < specData.layers.length; lIdx++) {
        const l = specData.layers[lIdx];
        for (const a of l.animations) {
          if (currentIndex === animIndex) {
            anim = a;
            layer = l;
            layerIndex = lIdx;
            break;
          }
          currentIndex++;
        }
        if (anim) break;
      }

      if (!anim) return;

      const detailPanel = document.getElementById('detailPanel');
      const description = getAnimationDescription(anim.property, anim.values, anim.fitToShape, anim.description, layer.layerName);

      // Get the color for this animation type (use custom color if set)
      const colorClass = getPropertyColorClass(anim.property);
      const defaultBarColor = getPropertyColor(colorClass);
      const barColor = anim.customColor || defaultBarColor;
      const brightColor = brightenColor(barColor);

      // Define available colors for picker (sorted cool to warm)
      const colorOptions = [
        '#045c7d', // blue (coolest)
        '#045c45', // teal
        '#4c7a4c', // green
        '#5a1778', // purple
        '#a82968', // pink
        '#a82929', // red
        '#ae4715', // orange
        '#4a4a4a'  // dark grey
      ];

      let html = `<div class="detail-panel" style="border-left-color: ${brightColor};">`;
      html += `<div class="detail-panel-header">`;
      html += `<div class="detail-panel-title">`;
      html += `<div class="color-picker-dot" id="colorPickerDot" style="background: ${brightColor};" onclick="toggleColorPicker(event, ${animIndex})"></div>`;
      if (isEditMode) {
        html += `<input
          type="text"
          class="detail-title-input detail-title-input-section"
          value="${layer.layerName.replace(/"/g, '&quot;')}"
          maxlength="21"
          onfocus="this.select()"
          onblur="updateLayerField(${layerIndex}, 'layerName', this.value)"
          oninput="autoResizeTitleInput(this)"
          onkeydown="if(event.key === 'Enter') { this.blur(); }"
        />`;
        html += `<span> â€º </span>`;
        html += `<input
          type="text"
          class="detail-title-input detail-title-input-property"
          value="${anim.property.replace(/"/g, '&quot;')}"
          maxlength="21"
          onfocus="this.select()"
          onblur="updateAnimationField(${animIndex}, 'property', this.value)"
          oninput="autoResizeTitleInput(this)"
          onkeydown="if(event.key === 'Enter') { this.blur(); }"
        />`;
      } else {
        html += `<span>${layer.layerName} â€º ${anim.property}</span>`;
      }

      // Color picker panel
      html += `<div class="color-picker-panel" id="colorPickerPanel">`;
      html += `<div class="color-picker-grid">`;
      colorOptions.forEach(color => {
        const selected = color === barColor ? 'selected' : '';
        html += `<div class="color-option ${selected}" style="background: ${color};" onclick="changeAnimationColor(${animIndex}, '${color}')"></div>`;
      });
      html += `</div></div>`;
      html += `</div>`;

      if (isEditMode) {
        html += `<div class="detail-panel-actions">`;
        html += `<button class="detail-panel-action-btn delete" onclick="deleteAnimation(${animIndex})"><span style="font-size: 11px; position: relative; top: -1px; margin-right: -2px;">ðŸ—‘ï¸</span>&nbsp; Delete</button>`;
        html += `<button class="detail-panel-close" onclick="document.getElementById('detailPanel').innerHTML=''; selectedAnimation = null; document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected')); document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected')); requestAnimationFrame(() => updatePlayhead());">&times;</button>`;
        html += `</div>`;
      } else {
        html += `<button class="detail-panel-close" onclick="document.getElementById('detailPanel').innerHTML=''; selectedAnimation = null; document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected')); document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected')); requestAnimationFrame(() => updatePlayhead());">&times;</button>`;
      }

      html += `</div>`;

      // Description - full width above other fields (no label, just as subheader)
      // Description - editable in edit mode, plain text in read mode
      if (isEditMode) {
        html += `
          <div class="detail-description">
            <input
              type="text"
              class="detail-description-input"
              value="${description.replace(/"/g, '&quot;')}"
              placeholder="Enter description..."
              onfocus="this.select()"
              onblur="updateAnimationField(${animIndex}, 'customDescription', this.value)"
              onkeydown="if(event.key === 'Enter') { this.blur(); }"
            />
          </div>
        `;
      } else {
        html += `
          <div class="detail-description">${description}</div>
        `;
      }

      html += `<div class="detail-grid">`;

      // Handle Fit to Shape animations differently
      if (anim.isFitToShape && anim.fitToShape) {
        html += `
          <div class="detail-item">
            <div class="detail-label">Parent Layer</div>
            <div class="detail-value">${anim.fitToShape.containerLayerName}</div>
          </div>
          <div class="detail-item">
            <div class="detail-label">Alignment</div>
            <div class="detail-value">${getAlignmentText(anim.fitToShape.alignment)}</div>
          </div>
          <div class="detail-item">
            <div class="detail-label">Scale To</div>
            <div class="detail-value">${getScaleToText(anim.fitToShape.scaleTo)}</div>
          </div>
        `;
      } else {
        // Normal animation details
        // Delay - editable in edit mode
        html += `<div class="detail-item">`;
        html += `<div class="detail-label">DELAY (ms)</div>`;
        if (isEditMode) {
          html += `
            <div class="detail-value">
              <input
                type="text"
                class="detail-value-input"
                value="${anim.timing.delay}"
                onfocus="this.select()"
                onblur="updateAnimationField(${animIndex}, 'delay', this.value)"
                onkeydown="if(event.key === 'Enter') { this.blur(); }"
              />
            </div>
          `;
        } else {
          html += `<div class="detail-value">${anim.timing.delay}ms</div>`;
        }
        html += `</div>`;

        // Duration - always editable in edit mode
        // For springs from import (not yet edited), show "-"
        const durationIsNumeric = typeof anim.timing.duration === 'number' && !isNaN(anim.timing.duration);
        const userSetDuration = anim.durationUserSet === true;
        const isImportedSpring = !userSetDuration && anim.easing.type === 'spring' && durationIsNumeric;

        const durationInputValue = isImportedSpring ? '-' : (durationIsNumeric ? anim.timing.duration : '-');
        const durationDisplayValue = isImportedSpring ? '-' : (durationIsNumeric ? `${anim.timing.duration}ms` : '-');

        html += `<div class="detail-item">`;
        html += `<div class="detail-label">DURATION (ms)</div>`;
        if (isEditMode) {
          html += `
            <div class="detail-value">
              <input
                type="text"
                class="detail-value-input"
                value="${durationInputValue}"
                onfocus="this.select()"
                onblur="updateAnimationField(${animIndex}, 'duration', this.value)"
                onkeydown="if(event.key === 'Enter') { this.blur(); }"
              />
            </div>
          `;
        } else {
          html += `<div class="detail-value">${durationDisplayValue}</div>`;
        }
        html += `</div>`;
      }

      // Easing (skip for Fit to Shape since it doesn't have meaningful easing)
      if (!anim.isFitToShape) {
        let easingText = '';
        let easingTextPlain = '';  // Plain text version for edit mode

        // Check for custom easing first
        if (anim.customEasing !== undefined && anim.customEasing !== null) {
          easingTextPlain = anim.customEasing;  // Plain text for textarea
          easingText = formatSpringPreset(anim.customEasing);  // HTML for read-only
        } else if (anim.easing.type === 'spring') {
          const spring = anim.easing.spring;
          const presetSprings = ['Standard Spring', 'Slow Spring', 'Fast Spring', 'Slow Bounce Spring', 'Medium Bounce Spring', 'Fast Bounce Spring'];
          const isPreset = presetSprings.includes(spring.preset);

          if (isPreset) {
            easingTextPlain = spring.preset;
            easingText = spring.preset;
          } else {
            // Custom spring values as text
            const springText = `Stiffness: ${spring.custom.stiffness}, Damping: ${spring.custom.damping}, Damping Ratio: ${spring.custom.dampingRatio}, Mass: ${spring.custom.mass}`;
            easingTextPlain = springText;
            easingText = springText;
          }
        } else if (anim.easing.type === 'cubic-bezier') {
          const bezierValue = anim.easing.cubicBezier;

          // Check if preset name is already provided in JSON
          let presetName = anim.easing.cubicBezierPreset;

          // If not provided, detect from the bezier values
          if (!presetName) {
            // Normalize the bezier string by removing spaces and parsing numbers
            const normalized = bezierValue.replace(/\s+/g, '').toLowerCase();
            const curvePresets = {
              'cubic-bezier(0.2,0,0.2,1)': 'Standard Curve',
              'cubic-bezier(0.20,0.00,0.20,1.00)': 'Standard Curve',
              'cubic-bezier(0.1,1,0.2,1)': 'Enter Curve',
              'cubic-bezier(0.10,1.00,0.20,1.00)': 'Enter Curve',
              'cubic-bezier(0.4,0,1,1)': 'Exit Curve',
              'cubic-bezier(0.40,0.00,1.00,1.00)': 'Exit Curve'
            };
            presetName = curvePresets[normalized];
          }

          easingTextPlain = presetName || bezierValue;
          easingText = presetName || bezierValue;
        } else {
          easingTextPlain = anim.easing.type;
          easingText = anim.easing.type;
        }

        html += `<div class="detail-item">`;
        html += `<div class="detail-label">Easing</div>`;
        if (isEditMode) {
          html += `
            <div class="detail-value">
              <textarea
                class="detail-value-input"
                rows="1"
                onfocus="this.select()"
                onblur="updateAnimationField(${animIndex}, 'easing', this.value)"
                oninput="this.style.height = 'auto'; this.style.height = (this.scrollHeight + 4) + 'px';"
                onkeydown="if(event.key === 'Enter' && !event.shiftKey) { this.blur(); }"
              >${easingTextPlain.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</textarea>
            </div>
          `;
        } else {
          html += `<div class="detail-value">${easingText}</div>`;
        }
        html += `</div>`;
      }

      // Values (skip for Fit to Shape)
      if (!anim.isFitToShape && anim.values && anim.values.formatted) {
        let startValue = anim.customStartValue !== undefined && anim.customStartValue !== null
          ? anim.customStartValue
          : formatDecimalValue(anim.values.formatted.startValue);
        let endValue = anim.customEndValue !== undefined && anim.customEndValue !== null
          ? anim.customEndValue
          : formatDecimalValue(anim.values.formatted.endValue);

        // Show "-" if empty
        if (startValue === '') startValue = '-';
        if (endValue === '') endValue = '-';

        html += `<div class="detail-item">`;
        html += `<div class="detail-label">Start Value</div>`;
        if (isEditMode) {
          const hasNewline = startValue.includes('\n');
          if (hasNewline) {
            html += `
              <div class="detail-value">
                <textarea
                  class="detail-value-input"
                  rows="2"
                  onfocus="this.select()"
                  onblur="updateAnimationField(${animIndex}, 'startValue', this.value)"
                  onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); this.blur(); }"
                >${startValue.replace(/"/g, '&quot;')}</textarea>
              </div>
            `;
          } else {
            html += `
              <div class="detail-value">
                <input
                  type="text"
                  class="detail-value-input"
                  value="${startValue.replace(/"/g, '&quot;')}"
                  onfocus="this.select()"
                  onblur="updateAnimationField(${animIndex}, 'startValue', this.value)"
                  onkeydown="if(event.key === 'Enter') { this.blur(); }"
                />
              </div>
            `;
          }
        } else {
          html += `<div class="detail-value">${startValue.replace(/\n/g, '<br>')}</div>`;
        }
        html += `</div>`;

        html += `<div class="detail-item">`;
        html += `<div class="detail-label">End Value</div>`;
        if (isEditMode) {
          const hasNewline = endValue.includes('\n');
          if (hasNewline) {
            html += `
              <div class="detail-value">
                <textarea
                  class="detail-value-input"
                  rows="2"
                  onfocus="this.select()"
                  onblur="updateAnimationField(${animIndex}, 'endValue', this.value)"
                  onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); this.blur(); }"
                >${endValue.replace(/"/g, '&quot;')}</textarea>
              </div>
            `;
          } else {
            html += `
              <div class="detail-value">
                <input
                  type="text"
                  class="detail-value-input"
                  value="${endValue.replace(/"/g, '&quot;')}"
                  onfocus="this.select()"
                  onblur="updateAnimationField(${animIndex}, 'endValue', this.value)"
                  onkeydown="if(event.key === 'Enter') { this.blur(); }"
                />
              </div>
            `;
          }
        } else {
          html += `<div class="detail-value">${endValue.replace(/\n/g, '<br>')}</div>`;
        }
        html += `</div>`;
      }

      html += `</div></div>`;
      detailPanel.innerHTML = html;

      // Function to resize all textareas to fit their content
      function resizeTextareas() {
        const textareas = detailPanel.querySelectorAll('textarea.detail-value-input');
        textareas.forEach(textarea => {
          textarea.style.height = 'auto';
          // Add 4px buffer to prevent scrollbar from appearing
          textarea.style.height = (textarea.scrollHeight + 4) + 'px';
        });
      }

      // Auto-resize all textareas to fit their content
      // Use requestAnimationFrame to ensure DOM is fully rendered
      requestAnimationFrame(() => {
        resizeTextareas();
      });

      // Auto-resize title input fields to fit their content
      const titleInputs = detailPanel.querySelectorAll('.detail-title-input');
      titleInputs.forEach(input => autoResizeTitleInput(input));

      // Setup autocomplete for easing textarea
      const easingTextarea = detailPanel.querySelector('textarea.detail-value-input');
      if (easingTextarea) {
        easingTextarea.addEventListener('focus', () => {
          showEasingAutocomplete(easingTextarea, easingTextarea.value.trim());
        });
        easingTextarea.addEventListener('input', () => {
          showEasingAutocomplete(easingTextarea, easingTextarea.value.trim());
        });
      }

      // Remove old resize listener if it exists
      if (window.textareaResizeListener) {
        window.removeEventListener('resize', window.textareaResizeListener);
      }

      // Add resize listener to handle window resizing
      window.textareaResizeListener = () => resizeTextareas();
      window.addEventListener('resize', window.textareaResizeListener);

      // Update playhead position after info box is shown
      requestAnimationFrame(() => {
        updatePlayhead();

        // Smart scroll: ensure the selected row isn't hidden by the detail panel
        const timelineContainer = document.querySelector('.timeline-container');
        const selectedBar = document.querySelector('.timeline-bar.selected');

        if (timelineContainer && selectedBar && detailPanel) {
          const containerRect = timelineContainer.getBoundingClientRect();
          const barRect = selectedBar.getBoundingClientRect();
          const panelRect = detailPanel.getBoundingClientRect();

          // Calculate the bottom edge of visible area (above the detail panel)
          const visibleBottom = panelRect.top - 20; // 20px margin

          // If the selected bar is below the visible area or will be covered by the panel
          if (barRect.bottom > visibleBottom) {
            // Calculate how much to scroll
            const scrollAmount = barRect.bottom - visibleBottom;
            timelineContainer.scrollTop += scrollAmount;
          }
        }
      });
    }

    // Move entire layer up in the timeline
    function moveLayerUp(layerIndex) {
      if (layerIndex === 0) return; // Already at top

      // Swap layers
      const temp = specData.layers[layerIndex];
      specData.layers[layerIndex] = specData.layers[layerIndex - 1];
      specData.layers[layerIndex - 1] = temp;

      // Re-render timeline
      renderTimeline();

      // If an animation was selected, update the selection
      if (selectedAnimation !== null) {
        // Calculate new animation index after the swap
        let animsBefore = 0;
        for (let i = 0; i < layerIndex - 1; i++) {
          animsBefore += specData.layers[i].animations.length;
        }

        // Find which animation in the layer was selected
        let currentIndex = 0;
        let animIndexInLayer = -1;
        for (let lIdx = 0; lIdx < specData.layers.length; lIdx++) {
          const layer = specData.layers[lIdx];
          for (let aIdx = 0; aIdx < layer.animations.length; aIdx++) {
            if (currentIndex === selectedAnimation) {
              if (lIdx === layerIndex) {
                animIndexInLayer = aIdx;
              }
            }
            currentIndex++;
          }
        }

        if (animIndexInLayer !== -1) {
          const newAnimIndex = animsBefore + animIndexInLayer;
          setTimeout(() => {
            showAnimationDetails(newAnimIndex);
            const bar = document.querySelector(`.timeline-bar[data-anim-index="${newAnimIndex}"]`);
            const label = document.querySelector(`.timeline-label.indented[data-anim-index="${newAnimIndex}"]`);
            if (bar) bar.classList.add('selected');
            if (label) label.classList.add('selected');
          }, 0);
        }
      }
    }

    // Move entire layer down in the timeline
    function moveLayerDown(layerIndex) {
      if (layerIndex === specData.layers.length - 1) return; // Already at bottom

      // Swap layers
      const temp = specData.layers[layerIndex];
      specData.layers[layerIndex] = specData.layers[layerIndex + 1];
      specData.layers[layerIndex + 1] = temp;

      // Re-render timeline
      renderTimeline();

      // If an animation was selected, update the selection
      if (selectedAnimation !== null) {
        // Calculate new animation index after the swap
        let animsBefore = 0;
        for (let i = 0; i < layerIndex; i++) {
          animsBefore += specData.layers[i].animations.length;
        }

        // Find which animation in the layer was selected
        let currentIndex = 0;
        let animIndexInLayer = -1;
        for (let lIdx = 0; lIdx < specData.layers.length; lIdx++) {
          const layer = specData.layers[lIdx];
          for (let aIdx = 0; aIdx < layer.animations.length; aIdx++) {
            if (currentIndex === selectedAnimation) {
              if (lIdx === layerIndex) {
                animIndexInLayer = aIdx;
              }
            }
            currentIndex++;
          }
        }

        if (animIndexInLayer !== -1) {
          const newAnimIndex = animsBefore + specData.layers[layerIndex + 1].animations.length + animIndexInLayer;
          setTimeout(() => {
            showAnimationDetails(newAnimIndex);
            const bar = document.querySelector(`.timeline-bar[data-anim-index="${newAnimIndex}"]`);
            const label = document.querySelector(`.timeline-label.indented[data-anim-index="${newAnimIndex}"]`);
            if (bar) bar.classList.add('selected');
            if (label) label.classList.add('selected');
          }, 0);
        }
      }
    }

    // Move individual animation up within its layer
    function moveAnimationUp(layerIndex, animIndexInLayer) {
      if (animIndexInLayer === 0) return; // Already at top of layer

      const layer = specData.layers[layerIndex];

      // Swap animations within the layer
      const temp = layer.animations[animIndexInLayer];
      layer.animations[animIndexInLayer] = layer.animations[animIndexInLayer - 1];
      layer.animations[animIndexInLayer - 1] = temp;

      // Re-render timeline
      renderTimeline();

      // Update selection if this animation was selected
      if (selectedAnimation !== null) {
        // Calculate the new global animation index
        let animsBefore = 0;
        for (let i = 0; i < layerIndex; i++) {
          animsBefore += specData.layers[i].animations.length;
        }
        const newAnimIndex = animsBefore + (animIndexInLayer - 1);

        setTimeout(() => {
          showAnimationDetails(newAnimIndex);
          const bar = document.querySelector(`.timeline-bar[data-anim-index="${newAnimIndex}"]`);
          const label = document.querySelector(`.timeline-label.indented[data-anim-index="${newAnimIndex}"]`);
          if (bar) bar.classList.add('selected');
          if (label) label.classList.add('selected');
        }, 0);
      }
    }

    // Move individual animation down within its layer
    function moveAnimationDown(layerIndex, animIndexInLayer) {
      const layer = specData.layers[layerIndex];
      if (animIndexInLayer === layer.animations.length - 1) return; // Already at bottom of layer

      // Swap animations within the layer
      const temp = layer.animations[animIndexInLayer];
      layer.animations[animIndexInLayer] = layer.animations[animIndexInLayer + 1];
      layer.animations[animIndexInLayer + 1] = temp;

      // Re-render timeline
      renderTimeline();

      // Update selection if this animation was selected
      if (selectedAnimation !== null) {
        // Calculate the new global animation index
        let animsBefore = 0;
        for (let i = 0; i < layerIndex; i++) {
          animsBefore += specData.layers[i].animations.length;
        }
        const newAnimIndex = animsBefore + (animIndexInLayer + 1);

        setTimeout(() => {
          showAnimationDetails(newAnimIndex);
          const bar = document.querySelector(`.timeline-bar[data-anim-index="${newAnimIndex}"]`);
          const label = document.querySelector(`.timeline-label.indented[data-anim-index="${newAnimIndex}"]`);
          if (bar) bar.classList.add('selected');
          if (label) label.classList.add('selected');
        }, 0);
      }
    }

    // Delete parameter row from timeline
    function deleteAnimation(animIndex) {
      if (!specData) return;

      // Find which layer and animation this belongs to
      let currentIndex = 0;
      let layerIndex = -1;
      let animInLayerIndex = -1;

      for (let lIdx = 0; lIdx < specData.layers.length; lIdx++) {
        const layer = specData.layers[lIdx];
        for (let aIdx = 0; aIdx < layer.animations.length; aIdx++) {
          if (currentIndex === animIndex) {
            layerIndex = lIdx;
            animInLayerIndex = aIdx;
            break;
          }
          currentIndex++;
        }
        if (layerIndex !== -1) break;
      }

      if (layerIndex === -1) return;

      const layer = specData.layers[layerIndex];
      const animation = layer.animations[animInLayerIndex];
      const propertyName = animation.property;
      const layerName = layer.layerName;

      // Check if this is the last parameter in the section
      const isLastParam = layer.animations.length === 1;

      if (isLastParam) {
        if (!confirm(`This is the last parameter in "${layerName}". Delete this parameter and the entire section?`)) {
          return;
        }
        // Remove the entire layer
        specData.layers.splice(layerIndex, 1);
      } else {
        if (!confirm(`Delete "${propertyName}" parameter from "${layerName}"?`)) {
          return;
        }
        // Remove just this animation
        layer.animations.splice(animInLayerIndex, 1);
      }

      // Update the tab's specData to reflect the changes
      setCurrentSpecData(specData);

      // Close detail panel if it exists
      const detailPanel = document.getElementById('detailPanel');
      if (detailPanel) {
        detailPanel.innerHTML = '';
      }
      selectedAnimation = null;
      document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
      document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected'));

      // Sync the changes back to legacy specData variable
      syncLegacyVariables();

      // Re-render based on current view mode
      refreshActiveView();
    }

    // Initialize with default spec
    specData = {
      compName: "Motion Inspector",
      workArea: {
        duration: 2000
      },
      layers: [
        {
          layerName: "Section 1",
          animations: [
            {
              property: "Add parameter",
              description: "Add description",
              timing: {
                delay: 0,
                duration: 300
              },
              easing: {
                type: "-",
                cubicBezier: ""
              },
              values: {
                formatted: {
                  startValue: "-",
                  endValue: "-"
                }
              }
            }
          ]
        }
      ]
    };

    // Render the default timeline
    renderTimeline();
  </script>
</body>
</html>
