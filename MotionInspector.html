<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Motion Inspector</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Generator:%20Adobe%20Illustrator%2027.9.0,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%206.00%20Build%200)%20--%3e%3csvg%20version='1.1'%20id='Layer_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%20150%20150'%20style='enable-background:new%200%200%20150%20150;'%20xml:space='preserve'%3e%3cstyle%20type='text/css'%3e%20.st0{fill-rule:evenodd;clip-rule:evenodd;}%20@media%20(prefers-color-scheme:%20dark)%20{%20.st0%20{%20fill:%23FFFFFF;%20}%20}%20%3c/style%3e%3cg%20id='Layer_1_00000076594398665045771890000013973700932976003724_'%3e%3cg%3e%3cpath%20class='st0'%20d='M131.3,118c-1.1,7.2-5.9,13.5-12.9,16.2c-3.4,1.3-7.1,1.9-10.7,1.3c-3.6-0.4-7.1-1.6-10.7-3.6%20c-5.1-2.8-10.2-7.2-16-13.5c9.3-11.3,15-21.7,17-31c0.9-4.3,1.2-8.3,0.7-11.9c-0.5-3.5-1.7-6.7-3.8-9.5%20c-4.3-6.3-11.7-9.9-19.8-9.9c-8.2,0-15.6,3.8-19.8,9.9c-1.9,2.8-3.2,6-3.8,9.5c-0.5,3.6-0.4,7.6,0.7,11.9c2.1,9.3,7.9,19.7,17,31%20c-5.8,6.4-10.9,10.7-16,13.5c-3.6,2-7.2,3.2-10.7,3.6c-3.8,0.4-7.4,0-10.7-1.3c-6.8-2.8-11.8-9-12.9-16.2c-0.5-3.6-0.1-7,1.2-10.9%20c0.5-1.3,1.1-2.8,1.9-4.4c1.1-2.3,2.1-4.7,3.2-7l0.1-0.3c9.7-20.9,20.1-42,30.8-62.9l0.4-0.8c1.1-2.1,2.3-4.3,3.4-6.4%20c1.2-2.1,2.4-4.3,4-6.2c3-3.5,6.8-5.2,11.3-5.2c4.4,0,8.3,1.9,11.3,5.2c1.6,1.9,2.8,4,4,6.2c1.1,2.1,2.3,4.3,3.4,6.4l0.4,0.9%20c10.9,20.8,21.2,42,30.8,62.9l0.1,0.1c1.1,2.3,2.1,4.7,3.2,7.1c0.7,1.6,1.3,3.1,1.9,4.4C131.4,111.1,131.8,114.6,131.3,118z%20M74.9,111.6c-7.6-9.7-12.5-18.5-14.2-26c-0.7-3.1-0.9-6-0.5-8.6c0.4-2.1,1.1-4.2,2.3-5.9c2.7-3.8,7.2-6,12.5-6%20c5.1,0,9.8,2.3,12.5,6c1.2,1.7,1.9,3.6,2.3,5.9c0.4,2.5,0.3,5.5-0.5,8.6C87.4,93.1,82.6,102,74.9,111.6z%20M138.5,104.2%20c-0.7-1.7-1.3-3.5-2-5.1c-1.1-2.4-2.1-4.8-3.4-7.2l-0.1-0.1c-9.8-20.9-20.2-42.2-31.1-63.2l-0.4-0.9c-1.1-2.1-2.3-4.3-3.5-6.6%20c-1.3-2.5-3-5.2-5.1-7.8C88.2,8,81.9,5,74.8,5c-7,0-13.4,3-18.1,8.3c-2.1,2.5-3.6,5.2-5.1,7.8c-1.2,2.1-2.3,4.4-3.5,6.6l-0.4,0.8%20C37.1,49.7,26.7,70.8,16.9,91.9l-0.1,0.3c-1.1,2.3-2.1,4.7-3.2,7.1c-0.7,1.6-1.5,3.2-2,5.1c-1.9,5.1-2.4,10.1-1.6,15%20c1.5,10.5,8.6,19.3,18.4,23.3c3.6,1.5,7.5,2.3,11.5,2.3c1.2,0,2.4-0.1,3.8-0.3c4.7-0.5,9.5-2.1,14.1-4.7%20c5.8-3.2,11.4-7.9,17.4-14.5c6.2,6.7,11.8,11.4,17.4,14.5c4.7,2.5,9.4,4.2,14.1,4.7c1.2,0.1,2.4,0.3,3.8,0.3c4,0,7.9-0.8,11.5-2.3%20c9.8-3.9,16.9-12.9,18.4-23.3C140.8,114.4,140.3,109.5,138.5,104.2z'/%3e%3c/g%3e%3c/g%3e%3cg%20id='Dimensions'%3e%3c/g%3e%3c/svg%3e">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    @font-face {
      font-family: 'Airbnb Cereal VF';
      src: url('https://a0.muscache.com/airbnb/static/fonts/CircularAirPro-Book.woff2') format('woff2');
      font-weight: 400;
      font-style: normal;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      padding: 20px;
      overflow: auto;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .container {
      max-width: 100%;
    }

    .header-section {
      padding: 0 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }

    h1 {
      font-family: 'Airbnb Cereal VF', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 28px;
      font-weight: 300;
      margin: 0;
      letter-spacing: 0;
      color: #ffffff;
    }

    .controls {
      display: flex;
      gap: 12px;
    }

    .btn {
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }

    .btn-primary {
      background: #4a90e2;
      color: white;
    }

    .btn-primary:hover {
      background: #357abd;
    }

    .btn-secondary {
      background: #333;
      color: #e0e0e0;
      border: 1px solid #555;
    }

    .btn-secondary:hover {
      background: #444;
    }

    #videoInput {
      display: none;
    }

    .main-content {
      display: grid;
      grid-template-columns: 400px 1fr;
      gap: 20px;
      grid-auto-rows: max-content;
    }

    .video-section {
      background: #242424;
      border-radius: 8px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 15px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }

    .video-section:not(:has(video[src])) {
      min-height: calc(100vh - 160px);
    }

    video {
      width: 100%;
      height: auto;
      border-radius: 6px;
      background: transparent;
      display: none;
    }

    video[src] {
      display: block;
    }


    .playback-controls {
      display: none;
    }

    .timeline-section {
      background: #242424;
      border-radius: 8px;
      padding: 20px;
      overflow: visible;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      position: relative;
      display: flex;
      flex-direction: column;
      height: calc(100vh - 110px);
    }

    .timeline-section:has(#timelineContent:empty) {
      min-height: calc(100vh - 110px);
    }

    #timelineContent {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    .playhead-time {
      font-size: 13px;
      color: #7db3ea;
      font-weight: 500;
      height: 44px;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 0 12px;
      border-bottom: 1px solid #333;
      box-sizing: border-box;
      background: #0a0a0a;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .playhead-time #playPauseBtn {
      padding: 0;
      background: #4a90e2;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      color: white;
      cursor: pointer;
      font-size: 11px;
      width: 50px;
      height: 29px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
    }

    .playhead-time #playPauseBtn:hover {
      background: #357abd;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
    }

    .playhead-time #playPauseBtn .icon {
      font-size: 12px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: translate(1px, 1px) scale(0.95);
    }

    .playhead-time #playPauseBtn .icon.pause {
      font-size: 14px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: none;
    }

    .speed-btn {
      padding: 0;
      background: transparent;
      border: none;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 11px;
      font-weight: 400;
      opacity: 0.5;
      transition: all 0.2s;
    }

    .speed-btn:hover {
      opacity: 0.7;
    }

    .speed-btn.selected {
      opacity: 1;
      font-weight: 500;
    }

    /* DevTools-style timeline */
    .timeline-container {
      display: grid;
      grid-template-columns: 180px 1fr;
      gap: 0;
      border-radius: 8px;
      overflow-y: auto;
      overflow-x: hidden;
      border: 1px solid rgba(255, 255, 255, 0.12);
      flex: 1;
      min-height: 0;
      position: relative;
    }

    .timeline-content-column {
      position: relative;
      box-shadow: inset -6px -6px 14px -4px rgba(0, 0, 0, 0.5);
      background: #1a1a1a;
    }

    /* Dark theme scrollbar styling */
    .timeline-container::-webkit-scrollbar {
      width: 12px;
    }

    .timeline-container::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 0 8px 8px 0;
    }

    .timeline-container::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 6px;
      border: 2px solid #1a1a1a;
    }

    .timeline-container::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    .timeline-labels-column {
      background: #0a0a0a;
    }

    .timeline-ruler {
      position: sticky;
      top: 0;
      height: 44px;
      background: #0a0a0a;
      border-bottom: 1px solid #333;
      margin-bottom: 0;
      box-sizing: border-box;
      padding-right: 80px;
      z-index: 100;
    }

    .timeline-tick {
      font-size: 11px;
      color: #e0e0e0;
      padding-left: 6px;
      display: flex;
      align-items: center;
      height: 100%;
      white-space: nowrap;
    }

    .timeline-rows {
      position: relative;
    }

    .timeline-row {
      min-height: 32px;
      border-bottom: 1px solid #2a2a2a;
      position: relative;
    }

    .timeline-row:hover .timeline-label,
    .timeline-row:hover .timeline-track {
      background: #282828;
    }

    .timeline-label.layer-header {
      background: transparent;
      font-weight: 600;
      border-bottom: 1px solid #1a1a1a;
      min-height: 32px;
      max-height: 32px;
    }

    .timeline-track.layer-header {
      background: transparent;
      font-weight: 600;
      border-bottom: 1px solid #2a2a2a;
      min-height: 32px;
      max-height: 32px;
    }

    .timeline-label.layer-header.has-divider,
    .timeline-track.layer-header.has-divider {
      border-top: 1px solid #4a4a4a;
      padding-top: 8px;
      margin-top: 15px;
    }

    .timeline-label.layer-header:hover {
      background: transparent;
    }

    .timeline-track.layer-header:hover {
      background: transparent;
    }

    .timeline-label {
      padding: 8px 12px;
      font-size: 12px;
      color: #e0e0e0;
      display: flex;
      align-items: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-height: 32px;
      border-bottom: 1px solid #1a1a1a;
    }

    .timeline-label.indented {
      padding-left: 32px;
      color: #b0b0b0;
    }

    .timeline-track {
      position: relative;
      min-height: 32px;
      border-bottom: 1px solid #2a2a2a;
      display: flex;
      align-items: center;
      padding-right: 80px;
      margin-right: -80px;
      overflow: hidden;
    }

    .timeline-bar {
      position: absolute;
      height: 24px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      padding: 0 8px;
      font-size: 11px;
      color: white;
      cursor: pointer;
      transition: all 0.1s;
      z-index: 1;
      white-space: nowrap;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.12);
    }

    .timeline-bar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 6px;
      pointer-events: none;
      z-index: 10;
    }

    .timeline-bar:hover {
      filter: brightness(1.2);
      z-index: 1;
    }

    .timeline-bar.selected {
      filter: brightness(1.2);
      z-index: 2;
      box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.4);
    }

    .timeline-bar.selected.bar-spring {
      box-shadow: none;
    }

    .timeline-bar.selected.bar-spring::before {
      background: rgba(255, 255, 255, 0.4);
      padding: 2px;
    }

    .timeline-bar-text {
      position: relative;
      z-index: 5;
    }

    /* Text fade overlays - match each bar's background color */
    .timeline-bar.has-text-overflow::after {
      content: '';
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 40px;
      pointer-events: none;
      z-index: 10;
      border-radius: 0 6px 6px 0;
    }

    .timeline-bar.has-text-overflow.bar-opacity::after {
      background: linear-gradient(to right, rgba(4, 92, 69, 0) 0%, rgba(4, 92, 69, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-scale::after {
      background: linear-gradient(to right, rgba(168, 41, 104, 0) 0%, rgba(168, 41, 104, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-rotation::after {
      background: linear-gradient(to right, rgba(104, 34, 133, 0) 0%, rgba(104, 34, 133, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-position-x::after,
    .timeline-bar.has-text-overflow.bar-position-y::after {
      background: linear-gradient(to right, rgba(4, 92, 125, 0) 0%, rgba(4, 92, 125, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-width::after,
    .timeline-bar.has-text-overflow.bar-height::after {
      background: linear-gradient(to right, rgba(174, 71, 21, 0) 0%, rgba(174, 71, 21, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-transform::after {
      background: linear-gradient(to right, rgba(90, 23, 120, 0) 0%, rgba(90, 23, 120, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-default::after {
      background: linear-gradient(to right, rgba(4, 76, 125, 0) 0%, rgba(4, 76, 125, 1) 100%);
    }

    /* Property-specific colors */
    .bar-opacity { background: #045c45; }
    .bar-scale { background: #a82968; }
    .bar-rotation { background: #682285; }
    .bar-position-x { background: #045c7d; }
    .bar-position-y { background: #045c7d; }
    .bar-width { background: #ae4715; }
    .bar-height { background: #ae4715; }
    .bar-transform { background: #5a1778; }
    .bar-default { background: #044c7d; }

    /* Spring gradient fade-out */
    .bar-spring.bar-opacity { background: linear-gradient(90deg, #045c45 0%, #045c45 50%, rgba(4, 92, 69, 0) 100%); }
    .bar-spring.bar-scale { background: linear-gradient(90deg, #a82968 0%, #a82968 50%, rgba(168, 41, 104, 0) 100%); }
    .bar-spring.bar-rotation { background: linear-gradient(90deg, #682285 0%, #682285 50%, rgba(104, 34, 133, 0) 100%); }
    .bar-spring.bar-position-x { background: linear-gradient(90deg, #045c7d 0%, #045c7d 50%, rgba(4, 92, 125, 0) 100%); }
    .bar-spring.bar-position-y { background: linear-gradient(90deg, #045c7d 0%, #045c7d 50%, rgba(4, 92, 125, 0) 100%); }
    .bar-spring.bar-width { background: linear-gradient(90deg, #ae4715 0%, #ae4715 50%, rgba(174, 71, 21, 0) 100%); }
    .bar-spring.bar-height { background: linear-gradient(90deg, #ae4715 0%, #ae4715 50%, rgba(174, 71, 21, 0) 100%); }
    .bar-spring.bar-transform { background: linear-gradient(90deg, #5a1778 0%, #5a1778 50%, rgba(90, 23, 120, 0) 100%); }
    .bar-spring.bar-default { background: linear-gradient(90deg, #044c7d 0%, #044c7d 50%, rgba(4, 76, 125, 0) 100%); }

    /* Spring bars - remove base box-shadow, use gradient border instead */
    .bar-spring { box-shadow: none; }

    /* Spring gradient borders that fade out with the fill */
    .bar-spring::before {
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0);
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.12) 50%, rgba(255, 255, 255, 0) 100%);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      padding: 1px;
    }

    .playhead {
      position: fixed;
      width: 2px;
      background: #4a90e2;
      z-index: 200;
      cursor: ew-resize;
      box-shadow: -2px 0 0 0 #242424, 2px 0 0 0 #242424;
      pointer-events: none;
    }

    .playhead::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: -10px;
      right: -10px;
      cursor: ew-resize;
      pointer-events: auto;
    }


    .playhead-handle {
      position: absolute;
      top: -11.5px; /* Vertically center at bottom of 44px row */
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 8px;
      background: #4a90e2;
      color: #ffffff;
      font-size: 11px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      cursor: ew-resize;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      pointer-events: auto;
      transition: all 0.2s;
      white-space: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }

    .playhead-handle:hover {
      background: #357abd;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.5);
    }

    .detail-panel {
      margin-top: 20px;
      padding: 14px 20px 20px 20px;
      background: #2a2a2a;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-left-width: 3px;
      font-size: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      flex-shrink: 0;
      position: relative;
      z-index: 400;
    }

    .detail-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .detail-panel-title {
      font-weight: 700;
      color: #ffffff;
      font-size: 14px;
    }

    .detail-panel-close {
      background: none;
      border: none;
      color: #999;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .detail-panel-close:hover {
      background: #333;
      color: #ffffff;
    }

    .detail-description {
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid #333;
      font-size: 13px;
      color: #ffffff;
    }

    .detail-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 20px;
      align-items: start;
    }

    .detail-item {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .detail-label {
      color: #999;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      font-weight: 600;
    }

    .detail-value {
      color: #e0e0e0;
      font-weight: 400;
      font-size: 13px;
      line-height: 1.4;
    }

    .spring-params, .bezier-curve {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 13px;
      line-height: 1.4;
      color: #e0e0e0;
    }

    .bezier-curve {
      color: #e0e0e0;
    }

    .spring-link {
      color: #7db3ea;
      text-decoration: underline;
      cursor: pointer;
      transition: color 0.2s;
    }

    .spring-link:hover {
      color: #a8d0f5;
    }

    .empty-state {
      padding: 40px 20px;
      color: #666;
      opacity: 0.4;
    }

    .empty-timeline-ruler {
      height: 32px;
      background: #1f1f1f;
      border-bottom: 1px solid #333;
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 60px;
      font-size: 11px;
      color: #555;
    }

    .empty-timeline-tracks {
      padding: 20px;
    }

    .empty-timeline-row {
      display: flex;
      align-items: center;
      height: 32px;
      margin-bottom: 8px;
    }

    .empty-timeline-label {
      width: 150px;
      height: 24px;
      background: #222;
      border-radius: 4px;
      margin-right: 20px;
    }

    .empty-timeline-bar {
      height: 24px;
      background: #252525;
      border-radius: 4px;
      flex: 1;
      max-width: 70%;
    }

  </style>
</head>
<body>
  <div class="container">
    <div class="header-section">
      <h1>Motion Inspector</h1>
      <div class="controls">
        <input type="file" id="videoInput" accept="video/*">
        <button class="btn btn-secondary" onclick="document.getElementById('videoInput').click()">
          üìÅ Add Video
        </button>
        <button class="btn btn-secondary" onclick="pasteSpec()">
          üìã Paste Spec
        </button>
        <button class="btn btn-secondary" onclick="exportZip()">
          üì¶ Export Zip
        </button>
      </div>
    </div>

    <div class="main-content">
      <div class="video-section">
        <video id="videoPlayer"></video>
      </div>

      <div class="timeline-section">
        <div id="timelineContent"></div>
      </div>
    </div>
  </div>

  <script>
    let specData = null;
    let uploadedVideoFile = null;
    let videoDuration = 0;
    let isDraggingPlayhead = false;
    let selectedAnimation = null;
    let animationFrameId = null;
    let lastDraggedSpecTimeMs = null;
    let lastDraggedVideoTime = null;
    let justFinishedDragging = false;
    let pendingVideoSeek = null;
    let videoSeekScheduled = false;

    // Video timing offset in milliseconds (adjust this to sync video with timeline)
    // Positive values shift timeline markers earlier (if video content appears late)
    const VIDEO_OFFSET_MS = 30;

    const video = document.getElementById('videoPlayer');

    // Throttled video seek using RAF to prevent multiple competing seeks
    function scheduleVideoSeek(targetTime) {
      pendingVideoSeek = targetTime;

      if (!videoSeekScheduled) {
        videoSeekScheduled = true;
        requestAnimationFrame(() => {
          if (pendingVideoSeek !== null) {
            video.currentTime = pendingVideoSeek;
            pendingVideoSeek = null;
          }
          videoSeekScheduled = false;
        });
      }
    }

    // Video upload handler
    document.getElementById('videoInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        uploadedVideoFile = file; // Store for export
        const url = URL.createObjectURL(file);
        video.src = url;
        video.addEventListener('loadedmetadata', () => {
          videoDuration = video.duration * 1000; // Convert to ms
          // Ensure video starts at exactly 0
          video.currentTime = 0;
          if (specData) {
            renderTimeline();
          }
        });
      }
    });

    // Play/pause toggle
    function togglePlayPause() {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (video.paused) {
        video.play();
        if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon pause">‚è∏</span>';
        startPlayheadAnimation();
      } else {
        video.pause();
        if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon">‚ñ∂</span>';
        stopPlayheadAnimation();
      }
    }

    // Set playback speed
    function setPlaybackSpeed(speed) {
      video.playbackRate = speed;

      // Update button states
      document.querySelectorAll('.speed-btn').forEach(btn => {
        btn.classList.remove('selected');
      });

      const selectedBtn = document.querySelector(`.speed-btn[data-speed="${speed}"]`);
      if (selectedBtn) {
        selectedBtn.classList.add('selected');
      }
    }

    // Smooth playhead animation using RAF
    function animatePlayhead() {
      if (!isDraggingPlayhead && !video.paused) {
        updatePlayhead();
        updateTimeDisplays();
        animationFrameId = requestAnimationFrame(animatePlayhead);
      }
    }

    function startPlayheadAnimation() {
      if (animationFrameId === null) {
        animationFrameId = requestAnimationFrame(animatePlayhead);
      }
    }

    function stopPlayheadAnimation() {
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    }

    // Video events
    video.addEventListener('play', () => {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon pause">‚è∏</span>';
      startPlayheadAnimation();
    });

    video.addEventListener('pause', () => {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon">‚ñ∂</span>';
      stopPlayheadAnimation();
    });

    video.addEventListener('ended', () => {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon">‚ñ∂</span>';
      stopPlayheadAnimation();
    });

    // Update time displays
    function updateTimeDisplays() {
      // If we just finished dragging, use the stored position instead of recalculating
      let specTimeMs;
      if (justFinishedDragging && lastDraggedSpecTimeMs !== null) {
        specTimeMs = lastDraggedSpecTimeMs;
      } else {
        // Calculate spec time based on video progress with offset adjustment
        specTimeMs = video.currentTime * 1000;
        if (video.duration && specData) {
          // Apply offset: subtract VIDEO_OFFSET_MS from video time before calculating progress
          const adjustedVideoTime = Math.max(0, video.currentTime - (VIDEO_OFFSET_MS / 1000));
          const videoProgress = adjustedVideoTime / video.duration;
          specTimeMs = videoProgress * specData.workArea.duration;
        }
      }

      const playheadTimeDisplay = document.getElementById('playheadTimeDisplay');
      if (playheadTimeDisplay) {
        playheadTimeDisplay.textContent = `${specTimeMs.toFixed(0)}ms`;
      }
    }

    // Update playhead position
    function updatePlayhead() {
      // Don't update position during or right after dragging - user has direct control
      if (isDraggingPlayhead || justFinishedDragging) return;

      const playhead = document.querySelector('.playhead');
      const timelineContainer = document.querySelector('.timeline-container');
      const timelineContent = document.querySelector('.timeline-content-column');

      if (playhead && timelineContainer && timelineContent) {
        const positionPercent = getTimelinePosition(video.currentTime);
        const containerRect = timelineContainer.getBoundingClientRect();
        const contentRect = timelineContent.getBoundingClientRect();

        // Calculate pixel position relative to viewport
        const leftPosition = contentRect.left + (positionPercent / 100 * contentRect.width);
        playhead.style.left = `${leftPosition}px`;
        playhead.style.top = `${containerRect.top + 44}px`;
        playhead.style.bottom = `${window.innerHeight - containerRect.bottom}px`;
      }
    }

    // Paste spec from clipboard
    async function pasteSpec() {
      try {
        const text = await navigator.clipboard.readText();
        console.log('Clipboard text:', text);
        const data = JSON.parse(text);
        specData = data;
        renderTimeline();
      } catch (err) {
        alert('Failed to paste or parse JSON.\n\nError: ' + err.message + '\n\nCheck the browser console for more details.');
        console.error('Parse error:', err);
        console.error('Clipboard content:', await navigator.clipboard.readText());
      }
    }

    // Get the base HTML template for export (without the export button and JSZip)
    function getExportTemplate(videoFileName, specDataJson) {
      // Get all the styles from this page
      const styleElement = document.querySelector('style');
      const styles = styleElement ? styleElement.textContent : '';

      // Get all the script content (we'll extract just the functions we need)
      const scriptElement = document.querySelector('script:not([src])');
      const scriptContent = scriptElement ? scriptElement.textContent : '';

      // Remove the exportZip and getExportTemplate functions from the script
      const cleanedScript = scriptContent
        .replace(/\/\/ Get the base HTML template for export[\s\S]*?^    }\s*\n/m, '')
        .replace(/\/\/ Export everything as a zip file[\s\S]*?^    }\s*\n/m, '')
        .replace(/let uploadedVideoFile = null;\s*\n/g, '');

      return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Motion Inspector</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Generator:%20Adobe%20Illustrator%2027.9.0,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%206.00%20Build%200)%20--%3e%3csvg%20version='1.1'%20id='Layer_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%20150%20150'%20style='enable-background:new%200%200%20150%20150;'%20xml:space='preserve'%3e%3cstyle%20type='text/css'%3e%20.st0{fill-rule:evenodd;clip-rule:evenodd;}%20@media%20(prefers-color-scheme:%20dark)%20{%20.st0%20{%20fill:%23FFFFFF;%20}%20}%20%3c/style%3e%3cg%20id='Layer_1_00000076594398665045771890000013973700932976003724_'%3e%3cg%3e%3cpath%20class='st0'%20d='M131.3,118c-1.1,7.2-5.9,13.5-12.9,16.2c-3.4,1.3-7.1,1.9-10.7,1.3c-3.6-0.4-7.1-1.6-10.7-3.6%20c-5.1-2.8-10.2-7.2-16-13.5c9.3-11.3,15-21.7,17-31c0.9-4.3,1.2-8.3,0.7-11.9c-0.5-3.5-1.7-6.7-3.8-9.5%20c-4.3-6.3-11.7-9.9-19.8-9.9c-8.2,0-15.6,3.8-19.8,9.9c-1.9,2.8-3.2,6-3.8,9.5c-0.5,3.6-0.4,7.6,0.7,11.9c2.1,9.3,7.9,19.7,17,31%20c-5.8,6.4-10.9,10.7-16,13.5c-3.6,2-7.2,3.2-10.7,3.6c-3.8,0.4-7.4,0-10.7-1.3c-6.8-2.8-11.8-9-12.9-16.2c-0.5-3.6-0.1-7,1.2-10.9%20c0.5-1.3,1.1-2.8,1.9-4.4c1.1-2.3,2.1-4.7,3.2-7l0.1-0.3c9.7-20.9,20.1-42,30.8-62.9l0.4-0.8c1.1-2.1,2.3-4.3,3.4-6.4%20c1.2-2.1,2.4-4.3,4-6.2c3-3.5,6.8-5.2,11.3-5.2c4.4,0,8.3,1.9,11.3,5.2c1.6,1.9,2.8,4,4,6.2c1.1,2.1,2.3,4.3,3.4,6.4l0.4,0.9%20c10.9,20.8,21.2,42,30.8,62.9l0.1,0.1c1.1,2.3,2.1,4.7,3.2,7.1c0.7,1.6,1.3,3.1,1.9,4.4C131.4,111.1,131.8,114.6,131.3,118z%20M74.9,111.6c-7.6-9.7-12.5-18.5-14.2-26c-0.7-3.1-0.9-6-0.5-8.6c0.4-2.1,1.1-4.2,2.3-5.9c2.7-3.8,7.2-6,12.5-6%20c5.1,0,9.8,2.3,12.5,6c1.2,1.7,1.9,3.6,2.3,5.9c0.4,2.5,0.3,5.5-0.5,8.6C87.4,93.1,82.6,102,74.9,111.6z%20M138.5,104.2%20c-0.7-1.7-1.3-3.5-2-5.1c-1.1-2.4-2.1-4.8-3.4-7.2l-0.1-0.1c-9.8-20.9-20.2-42.2-31.1-63.2l-0.4-0.9c-1.1-2.1-2.3-4.3-3.5-6.6%20c-1.3-2.5-3-5.2-5.1-7.8C88.2,8,81.9,5,74.8,5c-7,0-13.4,3-18.1,8.3c-2.1,2.5-3.6,5.2-5.1,7.8c-1.2,2.1-2.3,4.4-3.5,6.6l-0.4,0.8%20C37.1,49.7,26.7,70.8,16.9,91.9l-0.1,0.3c-1.1,2.3-2.1,4.7-3.2,7.1c-0.7,1.6-1.5,3.2-2,5.1c-1.9,5.1-2.4,10.1-1.6,15%20c1.5,10.5,8.6,19.3,18.4,23.3c3.6,1.5,7.5,2.3,11.5,2.3c1.2,0,2.4-0.1,3.8-0.3c4.7-0.5,9.5-2.1,14.1-4.7%20c5.8-3.2,11.4-7.9,17.4-14.5c6.2,6.7,11.8,11.4,17.4,14.5c4.7,2.5,9.4,4.2,14.1,4.7c1.2,0.1,2.4,0.3,3.8,0.3c4,0,7.9-0.8,11.5-2.3%20c9.8-3.9,16.9-12.9,18.4-23.3C140.8,114.4,140.3,109.5,138.5,104.2z'/%3e%3c/g%3e%3c/g%3e%3cg%20id='Dimensions'%3e%3c/g%3e%3c/svg%3e">
  <style>${styles}</style>
</head>
<body>
  <div class="container">
    <div class="header-section">
      <h1>Motion Inspector</h1>
      <div class="controls" style="display: none;">
        <input type="file" id="videoInput" accept="video/*">
        <button class="btn btn-secondary" onclick="document.getElementById('videoInput').click()">
          üìÅ Add Video
        </button>
        <button class="btn btn-secondary" onclick="pasteSpec()">
          üìã Paste Spec
        </button>
      </div>
    </div>

    <div class="main-content">
      <div class="video-section">
        <video id="videoPlayer"></video>
        <div class="playback-controls" style="display: none;"></div>
      </div>

      <div class="timeline-section">
        <div id="timelineContent"></div>
      </div>
    </div>
  </div>

  <script>
${cleanedScript}
    // Auto-load embedded data
    const EMBEDDED_SPEC_DATA = ${specDataJson};
    const EMBEDDED_VIDEO_PATH = './${videoFileName}';

    window.addEventListener('DOMContentLoaded', () => {
      specData = EMBEDDED_SPEC_DATA;
      video.src = EMBEDDED_VIDEO_PATH;
      video.addEventListener('loadedmetadata', () => {
        videoDuration = video.duration * 1000;
        video.currentTime = 0;
        renderTimeline();
      });
    });
  <\/script>
</body>
</html>`;
    }

    // Export everything as a zip file
    async function exportZip() {
      if (!specData) {
        alert('Please paste a spec first (üìã Paste Spec button)');
        return;
      }
      if (!uploadedVideoFile) {
        alert('Please upload a video first (Upload Video button)');
        return;
      }

      try {
        // Get video file extension
        const videoFileName = uploadedVideoFile.name;
        const videoExt = videoFileName.substring(videoFileName.lastIndexOf('.'));
        const videoFileNameInZip = `video${videoExt}`;

        // Generate clean HTML template
        const exportHtml = getExportTemplate(videoFileNameInZip, JSON.stringify(specData));

        // Create download link with spec name
        const specName = specData.compName.replace(/[^a-z0-9]/gi, '_').toLowerCase();

        // Create zip file
        const zip = new JSZip();
        zip.file(`${specName}.html`, exportHtml);
        zip.file(videoFileNameInZip, uploadedVideoFile);

        // Generate zip and download
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        const zipUrl = URL.createObjectURL(zipBlob);
        const link = document.createElement('a');
        link.href = zipUrl;
        link.download = `${specName}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(zipUrl);
      } catch (err) {
        alert('Failed to create zip file: ' + err.message);
        console.error(err);
      }
    }

    // Get color class for property
    function getPropertyColorClass(property) {
      const prop = property.toLowerCase();
      if (prop.includes('opacity')) return 'bar-opacity';
      if (prop.includes('scale')) return 'bar-scale';
      if (prop.includes('rotation') || prop.includes('rotate')) return 'bar-rotation';
      if (prop.includes('x position')) return 'bar-position-x';
      if (prop.includes('y position')) return 'bar-position-y';
      if (prop.includes('width')) return 'bar-width';
      if (prop.includes('height')) return 'bar-height';
      if (prop.includes('transform')) return 'bar-transform';
      return 'bar-default';
    }

    // Get hex color for property color class
    function getPropertyColor(colorClass) {
      const colorMap = {
        'bar-opacity': '#045c45',
        'bar-scale': '#a82968',
        'bar-rotation': '#682285',
        'bar-position-x': '#045c7d',
        'bar-position-y': '#045c7d',
        'bar-width': '#ae4715',
        'bar-height': '#ae4715',
        'bar-transform': '#5a1778',
        'bar-default': '#044c7d'
      };
      return colorMap[colorClass] || '#4a90e2';
    }

    // Brighten a hex color to match the selected state (1.2x brightness)
    function brightenColor(hex) {
      // Remove # if present
      hex = hex.replace('#', '');

      // Parse RGB
      let r = parseInt(hex.substring(0, 2), 16);
      let g = parseInt(hex.substring(2, 4), 16);
      let b = parseInt(hex.substring(4, 6), 16);

      // Apply same brightness filter as selected bars (1.2x)
      r = Math.min(255, Math.round(r * 1.2));
      g = Math.min(255, Math.round(g * 1.2));
      b = Math.min(255, Math.round(b * 1.2));

      // Add more brightness to make it pop like the stroke
      r = Math.min(255, Math.round(r * 1.3));
      g = Math.min(255, Math.round(g * 1.3));
      b = Math.min(255, Math.round(b * 1.3));

      // Convert back to hex
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    // Convert video time to timeline position percentage
    function getTimelinePosition(videoTimeSeconds) {
      if (!video.duration || !specData) return 0;
      // Apply offset: subtract VIDEO_OFFSET_MS from video time
      const adjustedVideoTime = Math.max(0, videoTimeSeconds - (VIDEO_OFFSET_MS / 1000));
      const videoProgress = adjustedVideoTime / video.duration;
      const specTimeMs = videoProgress * specData.workArea.duration;
      // Position based on spec time percentage (same as bars)
      return (specTimeMs / specData.workArea.duration) * 100;
    }

    // Convert alignment number to text
    function getAlignmentText(alignment) {
      const alignments = {
        1: 'center',
        2: 'center left',
        3: 'center right',
        5: 'top center',
        6: 'top left',
        7: 'top right',
        9: 'bottom center',
        10: 'bottom left',
        11: 'bottom right'
      };
      return alignments[alignment] || 'unknown';
    }

    // Format numeric values to max 2 decimal places
    function formatDecimalValue(value) {
      if (value === null || value === undefined) return value;

      // Convert to string if it's a number
      const strValue = String(value);

      // Replace all numbers in the string, preserving units and formatting
      return strValue.replace(/(\d+\.?\d*)/g, (match) => {
        const num = parseFloat(match);
        if (isNaN(num)) return match;

        // If it's a whole number, return as is
        if (num % 1 === 0) return String(num);

        // Otherwise round to 2 decimal places and remove trailing zeros
        return parseFloat(num.toFixed(2)).toString();
      });
    }

    // Convert scaleTo number to text
    function getScaleToText(scaleTo) {
      const scaleOptions = {
        1: 'width',
        2: 'height',
        3: 'stretch',
        4: 'none'
      };
      return scaleOptions[scaleTo] || 'unknown';
    }

    // Get natural language description of animation
    function getAnimationDescription(property, values, fitToShape) {
      const prop = property.toLowerCase();
      let description;

      // Handle Fit to Shape animations
      if (fitToShape) {
        const alignment = getAlignmentText(fitToShape.alignment);
        const scaleTo = getScaleToText(fitToShape.scaleTo);
        description = `Parented to ${fitToShape.containerLayerName}, fit to ${scaleTo} and aligned to ${alignment}`;
      }
      // Handle cases where values is null
      else if (!values || values.change === undefined || values.change === null) {
        description = property;
      }
      else {
        const change = values.change;
        const changeValue = Array.isArray(change) ? change[0] : change;
        const absChange = Math.abs(changeValue);

        if (prop.includes('x position')) {
          const direction = changeValue < 0 ? 'left' : 'right';
          description = `slides ${direction} ${Math.round(absChange)}px`;
        }
        else if (prop.includes('y position')) {
          const direction = changeValue < 0 ? 'up' : 'down';
          description = `slides ${direction} ${Math.round(absChange)}px`;
        }
        else if (prop.includes('width')) {
          const action = changeValue > 0 ? 'expands' : 'shrinks';
          description = `width ${action}`;
        }
        else if (prop.includes('height')) {
          const action = changeValue > 0 ? 'expands' : 'shrinks';
          description = `height ${action}`;
        }
        else if (prop.includes('blur radius')) {
          const action = changeValue > 0 ? 'blurs' : 'unblurs';
          description = action;
        }
        else if (prop.includes('amount to tint')) {
          const action = changeValue > 0 ? 'tints' : 'untints';
          description = action;
        }
        else if (prop.includes('scale')) {
          if (values.formatted) {
            // Extract just the first value if x and y are the same
            let startVal = values.formatted.startValue;
            let endVal = values.formatted.endValue;

            // Check if it's a format like "100%, 100%" and extract first value
            if (typeof startVal === 'string' && startVal.includes(',')) {
              const startParts = startVal.split(',').map(s => s.trim());
              if (startParts[0] === startParts[1]) {
                startVal = startParts[0];
              }
            }
            if (typeof endVal === 'string' && endVal.includes(',')) {
              const endParts = endVal.split(',').map(s => s.trim());
              if (endParts[0] === endParts[1]) {
                endVal = endParts[0];
              }
            }

            // Format decimal values
            startVal = formatDecimalValue(startVal);
            endVal = formatDecimalValue(endVal);

            if (startVal === endVal) {
              description = `scales to ${endVal}`;
            } else {
              description = `scales ${changeValue > 0 ? 'up' : 'down'} from ${startVal} to ${endVal}`;
            }
          } else {
            description = changeValue > 0 ? 'scales up' : 'scales down';
          }
        }
        else if (prop.includes('rotation') || prop.includes('rotate')) {
          const direction = changeValue < 0 ? 'counter-clockwise' : 'clockwise';
          description = `rotates ${direction} ${Math.round(absChange)}¬∞`;
        }
        else if (prop.includes('opacity')) {
          if (values.formatted) {
            description = `fades ${changeValue > 0 ? 'in' : 'out'} from ${formatDecimalValue(values.formatted.startValue)} to ${formatDecimalValue(values.formatted.endValue)}`;
          } else {
            description = changeValue > 0 ? 'fades in' : 'fades out';
          }
        }
        else {
          description = property;
        }
      }

      // Capitalize first letter
      return description.charAt(0).toUpperCase() + description.slice(1);
    }

    // Generate nice time divisions
    function getNiceTimeIntervals(duration) {
      const niceIntervals = [100, 200, 250, 500, 1000, 2000, 2500, 5000];
      const targetDivisions = 8;

      for (const interval of niceIntervals) {
        const divisions = Math.floor(duration / interval);
        if (divisions >= 6 && divisions <= 10) {
          return { interval, count: divisions };
        }
      }

      // Fallback: divide by 8
      return { interval: duration / 8, count: 8 };
    }

    // Render the timeline
    function renderTimeline() {
      if (!specData) return;

      const content = document.getElementById('timelineContent');

      // Update the main title with the spec name
      document.querySelector('h1').textContent = specData.compName;
      // Update the page title
      document.title = `Motion Inspector - ${specData.compName}`;

      let html = '';

      // Timeline container
      html += `<div class="timeline-container">`;

      // Left column - labels
      html += `<div class="timeline-labels-column">`;
      html += `<div class="playhead-time">
        <button id="playPauseBtn" onclick="togglePlayPause()"><span class="icon">‚ñ∂</span></button>
        <button class="speed-btn selected" data-speed="1" onclick="setPlaybackSpeed(1)">1x</button>
        <button class="speed-btn" data-speed="0.5" onclick="setPlaybackSpeed(0.5)">0.5x</button>
        <button class="speed-btn" data-speed="0.1" onclick="setPlaybackSpeed(0.1)">0.1x</button>
      </div>`; // Play button and speed controls above labels

      let animIndex = 0;
      specData.layers.forEach((layer, layerIndex) => {
        // Layer header label (add divider class if not first layer)
        const dividerClass = layerIndex > 0 ? ' has-divider' : '';
        html += `<div class="timeline-label layer-header${dividerClass}">${layer.layerName}</div>`;

        // Animation labels for this layer
        layer.animations.forEach(anim => {
          html += `<div class="timeline-label indented">${anim.property}</div>`;
          animIndex++;
        });
      });

      html += `</div>`; // timeline-labels-column

      // Right column - timeline content
      html += `<div class="timeline-content-column">`;

      // Timeline ruler - use spec time for labels and positioning
      const specDuration = specData.workArea.duration;
      const timeIntervals = getNiceTimeIntervals(specDuration);
      const interval = timeIntervals.interval;
      const ticks = [];

      for (let time = 0; time <= specDuration; time += interval) {
        ticks.push(time);
      }
      // Don't add final tick at exact duration - we'll stop before it

      html += `<div class="timeline-ruler">`;
      html += `<div style="position: absolute; top: 0; left: 0; right: 0; height: 100%;">`;
      ticks.forEach((time, index) => {
        // Skip the last tick if it's at the end
        if (time >= specDuration) return;

        // Position based on spec time percentage, centered over grid line
        const position = (time / specDuration) * 100;
        html += `<div class="timeline-tick" style="position: absolute; left: ${position}%; height: 100%; transform: translateX(-50%);">${Math.round(time)}ms</div>`;
      });
      html += `</div></div>`;

      // Timeline grid with bars
      html += `<div style="position: relative; padding-right: 80px;">`;
      html += `<div class="timeline-grid-lines" style="display: block; position: absolute; top: -8px; left: 0; right: 0; height: calc(100% + 8px); pointer-events: none; z-index: 5;">`;

      // Main grid lines (taller - extend into ruler)
      ticks.forEach(time => {
        if (time >= specDuration) return;
        const position = (time / specDuration) * 100;
        html += `<div style="position: absolute; left: ${position}%; top: 0; bottom: 0; width: 1px; background: rgba(255, 255, 255, 0.12);"></div>`;
      });

      // Subtle halfway markers between main grid lines (normal height - start below ruler)
      for (let i = 0; i < ticks.length - 1; i++) {
        const midTime = (ticks[i] + ticks[i + 1]) / 2;
        const position = (midTime / specDuration) * 100;
        html += `<div style="position: absolute; left: ${position}%; top: 8px; bottom: 0; width: 1px; background: rgba(255, 255, 255, 0.06);"></div>`;
      }

      html += `</div>`;

      // Helper function to find parent layer timing and spring status
      function getParentLayerInfo(containerLayerName) {
        const parentLayer = specData.layers.find(l => l.layerName === containerLayerName);
        if (!parentLayer || !parentLayer.animations || parentLayer.animations.length === 0) {
          return { delay: 0, duration: specData.workArea.duration, hasSpring: false };
        }

        // Find the earliest start and latest end across all parent animations
        let minDelay = Infinity;
        let maxEnd = 0;
        let hasSpring = false;

        parentLayer.animations.forEach(anim => {
          const animStart = anim.timing.delay;
          const animEnd = anim.timing.delay + anim.timing.duration;
          minDelay = Math.min(minDelay, animStart);
          maxEnd = Math.max(maxEnd, animEnd);
          if (anim.easing.type === 'spring') {
            hasSpring = true;
          }
        });

        return {
          delay: minDelay === Infinity ? 0 : minDelay,
          duration: maxEnd - (minDelay === Infinity ? 0 : minDelay),
          hasSpring: hasSpring
        };
      }

      // Timeline tracks
      animIndex = 0;
      specData.layers.forEach((layer, layerIndex) => {
        // Empty track for layer header (add divider class if not first layer)
        const dividerClass = layerIndex > 0 ? ' has-divider' : '';
        html += `<div class="timeline-track layer-header${dividerClass}"></div>`;

        // Animation tracks for this layer
        layer.animations.forEach(anim => {
          let startPercent, widthPercent, description, springClass;

          // Handle Fit to Shape animations - use parent layer's timing
          if (anim.isFitToShape && anim.fitToShape) {
            const parentInfo = getParentLayerInfo(anim.fitToShape.containerLayerName);
            startPercent = (parentInfo.delay / specData.workArea.duration) * 100;
            widthPercent = (parentInfo.duration / specData.workArea.duration) * 100;
            description = getAnimationDescription(anim.property, anim.values, anim.fitToShape);
            springClass = parentInfo.hasSpring ? ' bar-spring' : '';
          } else {
            // Normal animation - use its own timing
            startPercent = (anim.timing.delay / specData.workArea.duration) * 100;
            widthPercent = (anim.timing.duration / specData.workArea.duration) * 100;
            description = getAnimationDescription(anim.property, anim.values);
            springClass = anim.easing.type === 'spring' ? ' bar-spring' : '';
          }

          // Cap width so bars don't extend past the edge (shows rounded corners naturally)
          const maxWidth = 100 - startPercent;
          widthPercent = Math.min(widthPercent, maxWidth);

          const colorClass = getPropertyColorClass(anim.property);

          html += `<div class="timeline-track">`;
          html += `
            <div class="timeline-bar ${colorClass}${springClass}"
                 style="left: ${startPercent}%; width: ${widthPercent}%;"
                 data-anim-index="${animIndex}">
              <span class="timeline-bar-text">${description}</span>
            </div>
          `;
          html += `</div>`;

          animIndex++;
        });
      });

      html += `<div class="playhead" id="playhead"><div class="playhead-handle" id="playheadTimeDisplay">0ms</div></div>`;
      html += `</div>`; // position relative wrapper
      html += `</div>`; // timeline-content-column
      html += `</div>`; // timeline-container

      // Detail panel placeholder
      html += `<div id="detailPanel"></div>`;

      content.innerHTML = html;

      // Setup playhead dragging
      setupPlayheadDragging();

      // Setup animation bar clicks
      document.querySelectorAll('.timeline-bar').forEach(bar => {
        bar.addEventListener('click', (e) => {
          e.stopPropagation();
          const animIndex = parseInt(bar.dataset.animIndex);
          // Toggle: if clicking the same animation, close the info box
          if (selectedAnimation === animIndex) {
            document.getElementById('detailPanel').innerHTML = '';
            selectedAnimation = null;
            // Remove selected class from all bars
            document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
            requestAnimationFrame(() => {
              updatePlayhead();
            });
          } else {
            // Remove selected class from all bars
            document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
            // Add selected class to clicked bar
            bar.classList.add('selected');
            showAnimationDetails(animIndex);
          }
        });
      });

      updatePlayhead();

      // Detect text overflow and add fade class
      detectTextOverflow();
    }

    // Detect which bars have overflowing text and add fade class
    function detectTextOverflow() {
      const bars = document.querySelectorAll('.timeline-bar');
      bars.forEach(bar => {
        const textElement = bar.querySelector('.timeline-bar-text');
        if (textElement) {
          // Check if text is wider than the container
          const textWidth = textElement.scrollWidth;
          const containerWidth = bar.clientWidth - 16; // Subtract padding (8px * 2)

          if (textWidth > containerWidth) {
            bar.classList.add('has-text-overflow');
          } else {
            bar.classList.remove('has-text-overflow');
          }
        }
      });
    }

    // Setup playhead dragging
    function setupPlayheadDragging() {
      const playhead = document.getElementById('playhead');
      if (!playhead) return;

      const timelineContainer = document.querySelector('.timeline-container');
      const timelineContent = document.querySelector('.timeline-content-column');

      function onMouseDown(e) {
        isDraggingPlayhead = true;
        video.pause();
        const playPauseBtn = document.getElementById('playPauseBtn');
        if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon">‚ñ∂</span>';
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        onMouseMove(e);
      }

      function onMouseMove(e) {
        const containerRect = timelineContainer.getBoundingClientRect();
        const contentRect = timelineContent.getBoundingClientRect();
        let x = e.clientX - contentRect.left;

        // Calculate percentage of full width (not content width)
        let percentage = x / contentRect.width;

        // Clamp percentage between 0 and 1 (allow full range)
        percentage = Math.max(0, Math.min(percentage, 1.0));

        // Calculate pixel position relative to viewport
        const leftPosition = contentRect.left + (percentage * contentRect.width);
        playhead.style.left = `${leftPosition}px`;
        playhead.style.top = `${containerRect.top + 44}px`;
        playhead.style.bottom = `${window.innerHeight - containerRect.bottom}px`;

        if (video.duration && specData) {
          // Convert drag percentage to spec time
          const specTimeMs = (percentage * specData.workArea.duration);

          // Store this position for when we release
          lastDraggedSpecTimeMs = specTimeMs;

          // Calculate target video time - direct mapping without offset
          // (offset is only for display during playback, not for seeking)
          const videoProgress = specTimeMs / specData.workArea.duration;
          const targetVideoTime = videoProgress * video.duration;
          lastDraggedVideoTime = Math.min(targetVideoTime, video.duration);

          // Use throttled seek to prevent multiple competing seeks
          scheduleVideoSeek(lastDraggedVideoTime);

          // Display the exact spec time we're dragging to
          const playheadTimeDisplay = document.getElementById('playheadTimeDisplay');
          if (playheadTimeDisplay) {
            playheadTimeDisplay.textContent = `${specTimeMs.toFixed(0)}ms`;
          }
        }
      }

      function onMouseUp() {
        isDraggingPlayhead = false;
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);

        // Set flag IMMEDIATELY to freeze display updates (before RAF executes)
        justFinishedDragging = true;

        // Schedule final seek in its own RAF to ensure it executes AFTER any pending drag RAF
        requestAnimationFrame(() => {
          // Now set the final video time - this will be the last seek
          if (lastDraggedVideoTime !== null) {
            video.currentTime = lastDraggedVideoTime;
          }

          // Clear the flag after everything settles
          setTimeout(() => {
            justFinishedDragging = false;
            lastDraggedSpecTimeMs = null;
            lastDraggedVideoTime = null;
          }, 100);
        });
      }

      playhead.addEventListener('mousedown', onMouseDown);

      // Update playhead position on window resize and scroll
      window.addEventListener('resize', () => {
        if (!isDraggingPlayhead) {
          updatePlayhead();
        }
      });

      timelineContainer?.addEventListener('scroll', () => {
        if (!isDraggingPlayhead) {
          updatePlayhead();
        }
      });
    }

    // Show animation details
    function showAnimationDetails(animIndex) {
      // Store the selected animation index
      selectedAnimation = animIndex;

      let currentIndex = 0;
      let anim = null;
      let layer = null;

      for (const l of specData.layers) {
        for (const a of l.animations) {
          if (currentIndex === animIndex) {
            anim = a;
            layer = l;
            break;
          }
          currentIndex++;
        }
        if (anim) break;
      }

      if (!anim) return;

      const detailPanel = document.getElementById('detailPanel');
      const description = getAnimationDescription(anim.property, anim.values, anim.fitToShape);

      // Get the color for this animation type
      const colorClass = getPropertyColorClass(anim.property);
      const barColor = getPropertyColor(colorClass);
      const brightColor = brightenColor(barColor);

      let html = `<div class="detail-panel" style="border-left-color: ${brightColor};">`;
      html += `<div class="detail-panel-header">`;
      html += `<div class="detail-panel-title">${layer.layerName} ‚Ä∫ ${anim.property}</div>`;
      html += `<button class="detail-panel-close" onclick="document.getElementById('detailPanel').innerHTML=''; selectedAnimation = null; document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected')); requestAnimationFrame(() => updatePlayhead());">&times;</button>`;
      html += `</div>`;

      // Description - full width above other fields (no label, just as subheader)
      html += `
        <div class="detail-description">${description}</div>
      `;

      html += `<div class="detail-grid">`;

      // Handle Fit to Shape animations differently
      if (anim.isFitToShape && anim.fitToShape) {
        html += `
          <div class="detail-item">
            <div class="detail-label">Parent Layer</div>
            <div class="detail-value">${anim.fitToShape.containerLayerName}</div>
          </div>
          <div class="detail-item">
            <div class="detail-label">Alignment</div>
            <div class="detail-value">${getAlignmentText(anim.fitToShape.alignment)}</div>
          </div>
          <div class="detail-item">
            <div class="detail-label">Scale To</div>
            <div class="detail-value">${getScaleToText(anim.fitToShape.scaleTo)}</div>
          </div>
        `;
      } else {
        // Normal animation details
        // Delay
        html += `
          <div class="detail-item">
            <div class="detail-label">Delay</div>
            <div class="detail-value">${anim.timing.delay}ms</div>
          </div>
        `;

        // Duration
        const durationValue = anim.easing.type === 'spring' ? '-' : `${anim.timing.duration}ms`;
        html += `
          <div class="detail-item">
            <div class="detail-label">Duration</div>
            <div class="detail-value">${durationValue}</div>
          </div>
        `;
      }

      // Easing (skip for Fit to Shape since it doesn't have meaningful easing)
      if (!anim.isFitToShape && anim.easing.type === 'spring') {
        const spring = anim.easing.spring;
        const presetSprings = ['Standard Spring', 'Slow Spring', 'Fast Spring', 'Slow Bounce Spring', 'Medium Bounce Spring', 'Fast Bounce Spring'];
        const springLinks = {
          'Standard Spring': 'https://air.bb/standard-spring',
          'Slow Spring': 'https://air.bb/slow-spring',
          'Fast Spring': 'https://air.bb/fast-spring',
          'Slow Bounce Spring': 'https://air.bb/slow-bounce-spring',
          'Medium Bounce Spring': 'https://air.bb/medium-bounce-spring',
          'Fast Bounce Spring': 'https://air.bb/fast-bounce-spring'
        };
        const isPreset = presetSprings.includes(spring.preset);

        if (isPreset) {
          // Just show the preset name for standard presets with link
          const link = springLinks[spring.preset];
          html += `
            <div class="detail-item">
              <div class="detail-label">Easing</div>
              <div class="detail-value"><a href="${link}" target="_blank" rel="noopener noreferrer" class="spring-link">${spring.preset}</a></div>
            </div>
          `;
        } else {
          // Show custom spring values
          html += `
            <div class="detail-item">
              <div class="detail-label">Easing</div>
              <div class="spring-params"><strong>Stiffness:</strong> ${spring.custom.stiffness}
<strong>Damping:</strong> ${spring.custom.damping}
<strong>Damping Ratio:</strong> ${spring.custom.dampingRatio}
<strong>Mass:</strong> ${spring.custom.mass}</div>
            </div>
          `;
        }
      } else if (!anim.isFitToShape && anim.easing.type === 'cubic-bezier') {
        html += `
          <div class="detail-item">
            <div class="detail-label">Easing</div>
            <div class="bezier-curve">${anim.easing.cubicBezier}</div>
          </div>
        `;
      } else if (!anim.isFitToShape) {
        html += `
          <div class="detail-item">
            <div class="detail-label">Easing</div>
            <div class="detail-value">${anim.easing.type}</div>
          </div>
        `;
      }

      // Values (skip for Fit to Shape)
      if (!anim.isFitToShape && anim.values && anim.values.formatted) {
        html += `
          <div class="detail-item">
            <div class="detail-label">Start Value</div>
            <div class="detail-value">${formatDecimalValue(anim.values.formatted.startValue)}</div>
          </div>
          <div class="detail-item">
            <div class="detail-label">End Value</div>
            <div class="detail-value">${formatDecimalValue(anim.values.formatted.endValue)}</div>
          </div>
        `;
      }

      html += `</div></div>`;
      detailPanel.innerHTML = html;

      // Update playhead position after info box is shown
      requestAnimationFrame(() => {
        updatePlayhead();

        // Smart scroll: ensure the selected row isn't hidden by the detail panel
        const timelineContainer = document.querySelector('.timeline-container');
        const selectedBar = document.querySelector('.timeline-bar.selected');

        if (timelineContainer && selectedBar && detailPanel) {
          const containerRect = timelineContainer.getBoundingClientRect();
          const barRect = selectedBar.getBoundingClientRect();
          const panelRect = detailPanel.getBoundingClientRect();

          // Calculate the bottom edge of visible area (above the detail panel)
          const visibleBottom = panelRect.top - 20; // 20px margin

          // If the selected bar is below the visible area or will be covered by the panel
          if (barRect.bottom > visibleBottom) {
            // Calculate how much to scroll
            const scrollAmount = barRect.bottom - visibleBottom;
            timelineContainer.scrollTop += scrollAmount;
          }
        }
      });
    }
  </script>
</body>
</html>
