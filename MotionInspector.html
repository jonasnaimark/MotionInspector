<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Motion Inspector</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Generator:%20Adobe%20Illustrator%2027.9.0,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%206.00%20Build%200)%20--%3e%3csvg%20version='1.1'%20id='Layer_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%20150%20150'%20style='enable-background:new%200%200%20150%20150;'%20xml:space='preserve'%3e%3cstyle%20type='text/css'%3e%20.st0{fill-rule:evenodd;clip-rule:evenodd;}%20@media%20(prefers-color-scheme:%20dark)%20{%20.st0%20{%20fill:%23FFFFFF;%20}%20}%20%3c/style%3e%3cg%20id='Layer_1_00000076594398665045771890000013973700932976003724_'%3e%3cg%3e%3cpath%20class='st0'%20d='M131.3,118c-1.1,7.2-5.9,13.5-12.9,16.2c-3.4,1.3-7.1,1.9-10.7,1.3c-3.6-0.4-7.1-1.6-10.7-3.6%20c-5.1-2.8-10.2-7.2-16-13.5c9.3-11.3,15-21.7,17-31c0.9-4.3,1.2-8.3,0.7-11.9c-0.5-3.5-1.7-6.7-3.8-9.5%20c-4.3-6.3-11.7-9.9-19.8-9.9c-8.2,0-15.6,3.8-19.8,9.9c-1.9,2.8-3.2,6-3.8,9.5c-0.5,3.6-0.4,7.6,0.7,11.9c2.1,9.3,7.9,19.7,17,31%20c-5.8,6.4-10.9,10.7-16,13.5c-3.6,2-7.2,3.2-10.7,3.6c-3.8,0.4-7.4,0-10.7-1.3c-6.8-2.8-11.8-9-12.9-16.2c-0.5-3.6-0.1-7,1.2-10.9%20c0.5-1.3,1.1-2.8,1.9-4.4c1.1-2.3,2.1-4.7,3.2-7l0.1-0.3c9.7-20.9,20.1-42,30.8-62.9l0.4-0.8c1.1-2.1,2.3-4.3,3.4-6.4%20c1.2-2.1,2.4-4.3,4-6.2c3-3.5,6.8-5.2,11.3-5.2c4.4,0,8.3,1.9,11.3,5.2c1.6,1.9,2.8,4,4,6.2c1.1,2.1,2.3,4.3,3.4,6.4l0.4,0.9%20c10.9,20.8,21.2,42,30.8,62.9l0.1,0.1c1.1,2.3,2.1,4.7,3.2,7.1c0.7,1.6,1.3,3.1,1.9,4.4C131.4,111.1,131.8,114.6,131.3,118z%20M74.9,111.6c-7.6-9.7-12.5-18.5-14.2-26c-0.7-3.1-0.9-6-0.5-8.6c0.4-2.1,1.1-4.2,2.3-5.9c2.7-3.8,7.2-6,12.5-6%20c5.1,0,9.8,2.3,12.5,6c1.2,1.7,1.9,3.6,2.3,5.9c0.4,2.5,0.3,5.5-0.5,8.6C87.4,93.1,82.6,102,74.9,111.6z%20M138.5,104.2%20c-0.7-1.7-1.3-3.5-2-5.1c-1.1-2.4-2.1-4.8-3.4-7.2l-0.1-0.1c-9.8-20.9-20.2-42.2-31.1-63.2l-0.4-0.9c-1.1-2.1-2.3-4.3-3.5-6.6%20c-1.3-2.5-3-5.2-5.1-7.8C88.2,8,81.9,5,74.8,5c-7,0-13.4,3-18.1,8.3c-2.1,2.5-3.6,5.2-5.1,7.8c-1.2,2.1-2.3,4.4-3.5,6.6l-0.4,0.8%20C37.1,49.7,26.7,70.8,16.9,91.9l-0.1,0.3c-1.1,2.3-2.1,4.7-3.2,7.1c-0.7,1.6-1.5,3.2-2,5.1c-1.9,5.1-2.4,10.1-1.6,15%20c1.5,10.5,8.6,19.3,18.4,23.3c3.6,1.5,7.5,2.3,11.5,2.3c1.2,0,2.4-0.1,3.8-0.3c4.7-0.5,9.5-2.1,14.1-4.7%20c5.8-3.2,11.4-7.9,17.4-14.5c6.2,6.7,11.8,11.4,17.4,14.5c4.7,2.5,9.4,4.2,14.1,4.7c1.2,0.1,2.4,0.3,3.8,0.3c4,0,7.9-0.8,11.5-2.3%20c9.8-3.9,16.9-12.9,18.4-23.3C140.8,114.4,140.3,109.5,138.5,104.2z'/%3e%3c/g%3e%3c/g%3e%3cg%20id='Dimensions'%3e%3c/g%3e%3c/svg%3e">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    @font-face {
      font-family: 'Airbnb Cereal VF';
      src: url('https://a0.muscache.com/airbnb/static/fonts/CircularAirPro-Book.woff2') format('woff2');
      font-weight: 400;
      font-style: normal;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      padding: 20px 20px 6px 20px;
      overflow: auto;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .container {
      max-width: 100%;
    }

    .header-section {
      padding: 0 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }

    h1 {
      font-family: 'Airbnb Cereal VF', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 28px;
      font-weight: 300;
      margin: 0;
      letter-spacing: 0;
      color: #ffffff;
    }

    .controls {
      display: flex;
      gap: 12px;
    }

    .btn {
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }

    .btn-primary {
      background: #4a90e2;
      color: white;
    }

    .btn-primary:hover {
      background: #357abd;
    }

    .btn-secondary {
      background: #333;
      color: #e0e0e0;
      border: 1px solid #555;
    }

    .btn-secondary:hover {
      background: #444;
    }

    /* Make emojis in buttons 2px larger */
    .btn-emoji {
      font-size: 15px;
    }

    #videoInput {
      display: none;
    }

    .main-content {
      display: grid;
      grid-template-columns: 400px 20px 1fr;
      gap: 0;
      grid-auto-rows: max-content;
      position: relative;
    }

    .main-content.split-layout {
      grid-template-columns: 1fr 20px 1fr;
    }

    .resize-handle {
      cursor: col-resize;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      user-select: none;
    }

    .resize-handle::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 4px;
      height: 40px;
      background: #4a4a4a;
      border-radius: 2px;
      transition: background 0.2s;
    }

    .resize-handle:hover::before,
    .resize-handle.dragging::before {
      background: #4a90e2;
    }

    .video-section {
      background: #242424;
      border-radius: 8px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 15px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      height: calc(100vh - 96px);
      max-height: calc(100vh - 96px);
    }

    .video-section:not(:has(video[src])) {
      min-height: calc(100vh - 96px);
    }

    .video-container {
      display: none;
      flex: 1;
      min-height: 0;
    }

    .video-container.has-video {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .video-container.has-video.width-constrained {
      align-items: flex-start;
    }

    .video-wrapper {
      position: relative;
      display: inline-block;
      max-width: 100%;
      border-radius: 6px;
      overflow: hidden;
      line-height: 0;
    }

    video {
      max-width: 100%;
      max-height: calc(100vh - 140px);
      width: auto;
      height: auto;
      border-radius: 6px;
      background: transparent;
      display: block;
      object-fit: contain;
    }

    .video-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all 0.1s ease;
      pointer-events: none;
      cursor: pointer;
    }

    .video-wrapper:hover .video-overlay {
      background: rgba(0, 0, 0, 0.8);
      opacity: 1;
      pointer-events: auto;
    }

    .video-replace-btn {
      padding: 8px 16px;
      border-radius: 8px;
      background: #333;
      color: #e0e0e0;
      border: 1px solid #555;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      line-height: 1.5;
      min-height: 38px;
      box-sizing: border-box;
    }

    .video-overlay:hover .video-replace-btn {
      background: #444;
      border-color: #666;
    }

    .video-empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1;
      border: 2px dashed rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .video-empty-state:hover {
      border-color: rgba(255, 255, 255, 0.35);
      background: rgba(255, 255, 255, 0.02);
    }

    .video-empty-state.hidden {
      display: none;
    }

    .video-empty-state-btn {
      padding: 8px 16px;
      border-radius: 8px;
      background: #333;
      color: #e0e0e0;
      border: 1px solid #555;
      font-size: 13px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.2s ease;
    }

    .video-empty-state:hover .video-empty-state-btn {
      background: #444;
    }

    .playback-controls {
      display: none;
    }

    .timeline-section {
      background: #242424;
      border-radius: 8px;
      padding: 20px;
      overflow: visible;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      position: relative;
      display: flex;
      flex-direction: column;
      height: calc(100vh - 96px);
    }

    .timeline-section:has(#timelineContent:empty) {
      min-height: calc(100vh - 96px);
    }

    #timelineContent {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    .playhead-time {
      font-size: 13px;
      color: #7db3ea;
      font-weight: 500;
      height: 44px;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 0 12px;
      border-bottom: 1px solid #333;
      box-sizing: border-box;
      background: #0a0a0a;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .playhead-time #playPauseBtn {
      padding: 0;
      background: #4a90e2;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      color: white;
      cursor: pointer;
      font-size: 11px;
      width: 50px;
      height: 29px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
    }

    .playhead-time #playPauseBtn:hover {
      background: #357abd;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
    }

    .playhead-time #playPauseBtn .icon {
      font-size: 12px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: translate(1px, 1px) scale(0.95);
    }

    .playhead-time #playPauseBtn .icon.pause {
      font-size: 14px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: none;
    }

    .speed-btn {
      padding: 0;
      background: transparent;
      border: none;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 11px;
      font-weight: 400;
      opacity: 0.5;
      transition: all 0.2s;
    }

    .speed-btn:hover {
      opacity: 0.7;
    }

    .speed-btn.selected {
      opacity: 1;
      font-weight: 500;
    }

    /* Zoom controls */
    .zoom-controls {
      position: absolute;
      top: 8px;
      right: 16px;
      display: flex;
      align-items: center;
      background: #2a2a2a;
      border-radius: 6px;
      border: 1px solid #444;
      z-index: 101;
      overflow: hidden;
    }

    .zoom-btn {
      width: 28px;
      height: 24px;
      background: transparent;
      border: none;
      color: #fff;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .zoom-btn:hover:not(:disabled) {
      background: #3a3a3a;
    }

    .zoom-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .zoom-btn:first-child {
      border-right: 1px solid #444;
    }

    .zoom-duration {
      font-size: 11px;
      color: #fff;
      white-space: nowrap;
      font-variant-numeric: tabular-nums;
      max-width: 0;
      opacity: 0;
      overflow: hidden;
      padding: 0;
      margin: 0;
      border-right: none;
    }

    .zoom-controls:hover .zoom-duration {
      max-width: 160px;
      opacity: 1;
      padding: 0 8px;
      margin-right: 4px;
      border-right: 1px solid #444;
    }

    /* Color picker */
    .color-picker-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      cursor: pointer;
      margin-right: 8px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      transition: border-color 0.15s ease;
      flex-shrink: 0;
    }

    .color-picker-dot:hover {
      border-color: rgba(255, 255, 255, 0.6);
    }

    .color-picker-panel {
      position: absolute;
      background: #1a1a1a;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      display: none;
    }

    .color-picker-panel.visible {
      display: block;
    }

    .color-picker-panel::before {
      content: '';
      position: absolute;
      bottom: -6px;
      left: 62px;
      width: 12px;
      height: 12px;
      background: #1a1a1a;
      border-right: 1px solid #444;
      border-bottom: 1px solid #444;
      transform: rotate(45deg);
    }

    .color-picker-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 12px;
    }

    .color-option {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.15s ease;
      border: 2px solid transparent;
    }

    .color-option:hover {
      transform: scale(1.1);
    }

    .color-option.selected {
      border-color: rgba(255, 255, 255, 0.8);
      box-shadow: 0 0 0 2px #2a2a2a, 0 0 0 4px rgba(255, 255, 255, 0.3);
    }

    /* DevTools-style timeline */
    .timeline-container {
      display: grid;
      grid-template-columns: 180px 1fr;
      gap: 0;
      border-radius: 8px;
      overflow-y: auto;
      overflow-x: hidden;
      border: 1px solid rgba(255, 255, 255, 0.12);
      flex: 1;
      min-height: 0;
      position: relative;
    }

    .timeline-content-column {
      position: relative;
      box-shadow: inset -6px -6px 14px -4px rgba(0, 0, 0, 0.5);
      background: #1a1a1a;
    }

    /* Dark theme scrollbar styling */
    .timeline-container::-webkit-scrollbar {
      width: 12px;
    }

    .timeline-container::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 0 8px 8px 0;
    }

    .timeline-container::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 6px;
      border: 2px solid #1a1a1a;
    }

    .timeline-container::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    .timeline-labels-column {
      background: #0a0a0a;
    }

    .timeline-bottom-divider {
      border-top: 1px solid #4a4a4a;
      margin-top: 15px;
      height: 15px;
      position: relative;
    }

    .timeline-ruler {
      position: sticky;
      top: 0;
      height: 44px;
      background: #0a0a0a;
      border-bottom: 1px solid #333;
      margin-bottom: 0;
      box-sizing: border-box;
      padding-right: 80px;
      z-index: 100;
    }

    .timeline-tick {
      font-size: 11px;
      color: #e0e0e0;
      padding-left: 6px;
      display: flex;
      align-items: center;
      height: 100%;
      white-space: nowrap;
    }

    .timeline-rows {
      position: relative;
    }

    .timeline-row {
      min-height: 32px;
      border-bottom: 1px solid #2a2a2a;
      position: relative;
    }

    .timeline-row:hover .timeline-label,
    .timeline-row:hover .timeline-track {
      background: #282828;
    }

    .timeline-label.layer-header {
      background: transparent;
      font-weight: 600;
      border-bottom: 1px solid #1a1a1a;
      height: 32px;
    }

    .timeline-track.layer-header {
      background: transparent;
      font-weight: 600;
      border-bottom: 1px solid #2a2a2a;
      height: 32px;
    }

    .timeline-label.layer-header.has-divider,
    .timeline-track.layer-header.has-divider {
      border-top: 1px solid #4a4a4a;
      padding-top: 8px;
      margin-top: 15px;
    }

    .timeline-label.layer-header:hover {
      background: transparent;
    }

    .timeline-track.layer-header:hover {
      background: transparent;
    }

    .timeline-label {
      padding: 8px 12px;
      font-size: 12px;
      color: #e0e0e0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      white-space: nowrap;
      overflow: visible;
      text-overflow: ellipsis;
      height: 32px;
      border-bottom: 1px solid #1a1a1a;
      position: relative;
      box-sizing: border-box;
      cursor: grab;
    }

    .timeline-label:active {
      cursor: grabbing;
    }

    .timeline-label-text {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: #e0e0e0;
    }

    .timeline-label:hover .timeline-label-text {
      color: #ffffff;
    }

    .timeline-label-add-btn {
      position: absolute;
      right: 8px;
      bottom: 0;
      transform: translateY(50%);
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #2a2a2a;
      border: 1px solid #555;
      color: #ccc;
      font-size: 16px;
      font-weight: bold;
      line-height: 23px;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      transition: all 0.15s ease;
      pointer-events: auto;
    }

    .timeline-label-add-btn.visible {
      display: flex;
    }

    .timeline-label-add-btn:hover {
      background: #4a4a4a;
      border-color: #666;
      color: #fff;
    }

    /* Section divider add button */
    .section-divider-add-btn {
      position: absolute;
      left: 50%;
      top: 0;
      transform: translate(-50%, -50%);
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #2a2a2a;
      border: 1px solid #555;
      color: #ccc;
      font-size: 16px;
      font-weight: bold;
      line-height: 23px;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      transition: all 0.15s ease;
      pointer-events: auto;
    }

    .section-divider-add-btn.visible {
      display: flex;
    }

    .section-divider-add-btn:hover {
      background: #4a4a4a;
      border-color: #666;
      color: #fff;
    }

    .timeline-label.dragging {
      opacity: 0.5;
    }

    .timeline-bar.dragging-vertical {
      opacity: 0.5;
      cursor: grabbing !important;
    }

    /* Drop indicators - only on labels, extended to span full timeline width */
    .timeline-label.drag-over-top::before,
    .timeline-label.drag-over-bottom::after {
      content: '';
      position: absolute;
      left: 0;
      right: -3000px; /* Extend across entire timeline width */
      height: 2px;
      background: #4a90e2;
      z-index: 1000;
      pointer-events: none;
    }

    /* Track indicators for label-based dragging */
    .timeline-track.drag-over-top::before,
    .timeline-track.drag-over-bottom::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: #4a90e2;
      z-index: 1000;
      pointer-events: none;
    }

    .timeline-label.drag-over-top::before,
    .timeline-track.drag-over-top::before {
      top: -1px;
    }

    .timeline-label.drag-over-bottom::after,
    .timeline-track.drag-over-bottom::after {
      bottom: -1px;
    }

    .timeline-bottom-divider.drag-over-top,
    .timeline-bottom-track.drag-over-top {
      border-top-color: #4a90e2;
      border-top-width: 2px;
    }

    .timeline-label.indented {
      padding-left: 32px;
      color: #b0b0b0;
    }

    .timeline-label.indented.selected {
      color: #ffffff;
      font-weight: 600;
    }

    .timeline-track {
      position: relative;
      height: 32px;
      border-bottom: 1px solid #2a2a2a;
      display: flex;
      align-items: center;
      padding-right: 80px;
      margin-right: -80px;
      overflow: visible; /* Changed from hidden to allow drop indicators to extend */
      box-sizing: border-box;
    }

    .timeline-bar {
      position: absolute;
      height: 24px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      padding: 0 8px;
      font-size: 11px;
      color: white;
      cursor: grab;
      transition: all 0.1s;
      z-index: 1;
      white-space: nowrap;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.12);
    }

    .timeline-bar:active {
      cursor: grabbing;
    }

    .timeline-bar::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 6px;
      pointer-events: none;
      z-index: 10;
    }

    .timeline-bar:hover,
    .timeline-bar.dragging-resize {
      filter: brightness(1.2);
      z-index: 1;
    }

    .timeline-bar.selected {
      filter: brightness(1.2);
      z-index: 2;
      box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.4);
    }

    .timeline-bar.selected.bar-spring {
      box-shadow: none;
    }

    .timeline-bar.selected.bar-spring::before {
      background: rgba(255, 255, 255, 0.4);
      padding: 2px;
    }

    .timeline-bar-text {
      position: relative;
      z-index: 5;
    }

    /* Resize handles */
    .timeline-bar-resize-handle {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 8px;
      cursor: ew-resize !important;
      z-index: 15;
    }

    .timeline-bar-resize-handle.left {
      left: 0;
    }

    .timeline-bar-resize-handle.right {
      right: 0;
    }

    /* Text fade overlays - match each bar's background color */
    .timeline-bar.has-text-overflow::after {
      content: '';
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 40px;
      pointer-events: none;
      z-index: 10;
      border-radius: 0 6px 6px 0;
    }

    .timeline-bar.has-text-overflow.bar-opacity::after {
      background: linear-gradient(to right, rgba(4, 92, 69, 0) 0%, rgba(4, 92, 69, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-scale::after {
      background: linear-gradient(to right, rgba(168, 41, 104, 0) 0%, rgba(168, 41, 104, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-rotation::after {
      background: linear-gradient(to right, rgba(104, 34, 133, 0) 0%, rgba(104, 34, 133, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-position-x::after,
    .timeline-bar.has-text-overflow.bar-position-y::after {
      background: linear-gradient(to right, rgba(4, 92, 125, 0) 0%, rgba(4, 92, 125, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-width::after,
    .timeline-bar.has-text-overflow.bar-height::after {
      background: linear-gradient(to right, rgba(4, 92, 69, 0) 0%, rgba(4, 92, 69, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-blur::after {
      background: linear-gradient(to right, rgba(74, 74, 74, 0) 0%, rgba(74, 74, 74, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-transform::after {
      background: linear-gradient(to right, rgba(90, 23, 120, 0) 0%, rgba(90, 23, 120, 1) 100%);
    }

    .timeline-bar.has-text-overflow.bar-default::after {
      background: linear-gradient(to right, rgba(4, 76, 125, 0) 0%, rgba(4, 76, 125, 1) 100%);
    }

    /* Property-specific colors */
    .bar-opacity { background: #045c45; }
    .bar-scale { background: #a82968; }
    .bar-rotation { background: #682285; }
    .bar-position-x { background: #045c7d; }
    .bar-position-y { background: #045c7d; }
    .bar-width { background: #045c45; }
    .bar-height { background: #045c45; }
    .bar-blur { background: #4a4a4a; }
    .bar-transform { background: #5a1778; }
    .bar-default { background: #044c7d; }

    /* Spring gradient fade-out */
    .bar-spring.bar-opacity { background: linear-gradient(90deg, #045c45 0%, #045c45 50%, rgba(4, 92, 69, 0) 100%); }
    .bar-spring.bar-scale { background: linear-gradient(90deg, #a82968 0%, #a82968 50%, rgba(168, 41, 104, 0) 100%); }
    .bar-spring.bar-rotation { background: linear-gradient(90deg, #682285 0%, #682285 50%, rgba(104, 34, 133, 0) 100%); }
    .bar-spring.bar-position-x { background: linear-gradient(90deg, #045c7d 0%, #045c7d 50%, rgba(4, 92, 125, 0) 100%); }
    .bar-spring.bar-position-y { background: linear-gradient(90deg, #045c7d 0%, #045c7d 50%, rgba(4, 92, 125, 0) 100%); }
    .bar-spring.bar-width { background: linear-gradient(90deg, #045c45 0%, #045c45 50%, rgba(4, 92, 69, 0) 100%); }
    .bar-spring.bar-height { background: linear-gradient(90deg, #045c45 0%, #045c45 50%, rgba(4, 92, 69, 0) 100%); }
    .bar-spring.bar-blur { background: linear-gradient(90deg, #4a4a4a 0%, #4a4a4a 50%, rgba(74, 74, 74, 0) 100%); }
    .bar-spring.bar-transform { background: linear-gradient(90deg, #5a1778 0%, #5a1778 50%, rgba(90, 23, 120, 0) 100%); }
    .bar-spring.bar-default { background: linear-gradient(90deg, #044c7d 0%, #044c7d 50%, rgba(4, 76, 125, 0) 100%); }

    /* Spring bars - remove base box-shadow, use gradient border instead */
    .bar-spring { box-shadow: none; }

    /* Spring gradient borders that fade out with the fill */
    .bar-spring::before {
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0);
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.12) 50%, rgba(255, 255, 255, 0) 100%);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      padding: 1px;
    }

    .playhead {
      position: fixed;
      width: 2px;
      background: #4a90e2;
      z-index: 200;
      cursor: ew-resize;
      box-shadow: -2px 0 0 0 #242424, 2px 0 0 0 #242424;
      pointer-events: none;
    }

    .playhead::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: -10px;
      right: -10px;
      cursor: ew-resize;
      pointer-events: auto;
    }


    .playhead-handle {
      position: absolute;
      top: -11.5px; /* Vertically center at bottom of 44px row */
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 8px;
      background: #4a90e2;
      color: #ffffff;
      font-size: 11px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      cursor: ew-resize;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      pointer-events: auto;
      transition: all 0.2s;
      white-space: nowrap;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }

    .playhead-handle:hover {
      background: #357abd;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.5);
    }

    .detail-panel {
      margin-top: 20px;
      padding: 14px 20px 20px 20px;
      background: #2a2a2a;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-left-width: 3px;
      font-size: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      flex-shrink: 0;
      position: relative;
      z-index: 400;
    }

    .detail-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .detail-panel-title {
      font-weight: 700;
      color: #ffffff;
      font-size: 14px;
      display: flex;
      align-items: center;
      position: relative;
    }

    .detail-panel-close {
      background: #333;
      border: none;
      color: #e0e0e0;
      font-size: 16px;
      cursor: pointer;
      padding: 0;
      padding-top: 2px;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s;
    }

    .detail-panel-close:hover {
      background: #444;
    }

    .detail-panel-actions {
      display: flex;
      gap: 14px;
      align-items: center;
    }

    .detail-panel-action-btn {
      background: #333;
      border: 1px solid #555;
      color: #e0e0e0;
      font-size: 12px;
      cursor: pointer;
      padding: 6px 12px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      transition: all 0.2s;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      gap: 4px;
    }

    .detail-panel-action-btn:hover {
      background: #444;
      border-color: #666;
    }

    .detail-panel-action-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .detail-panel-action-btn:disabled:hover {
      background: #333;
      border-color: #555;
    }

    .detail-panel-action-btn .arrow {
      font-size: 10px;
    }

    .detail-panel-action-btn.delete {
      background: #333;
      border-color: #664444;
      font-size: 12px;
      font-weight: 500;
      padding: 6px 10px;
      color: #e0e0e0;
    }

    .detail-panel-action-btn.delete:hover {
      background: #444;
      border-color: #775555;
      color: #ffffff;
    }

    .detail-panel-action-btn.delete:disabled:hover {
      background: #333;
      border-color: #664444;
      color: #e0e0e0;
    }

    .detail-panel-separator {
      color: #666;
      font-size: 12px;
      margin: 0 4px;
    }

    .detail-description {
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid #333;
      font-size: 13px;
      color: #ffffff;
    }

    .detail-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 20px;
      align-items: start;
    }

    .detail-item {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .detail-label {
      color: #999;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      font-weight: 600;
    }

    .detail-value {
      color: #e0e0e0;
      font-weight: 400;
      font-size: 13px;
      line-height: 1.4;
    }

    .spring-params, .bezier-curve {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 13px;
      line-height: 1.4;
      color: #e0e0e0;
    }

    .bezier-curve {
      color: #e0e0e0;
    }

    .spring-link {
      color: #7db3ea;
      text-decoration: underline;
      cursor: pointer;
      transition: color 0.2s;
    }

    .spring-link:hover {
      color: #a8d0f5;
    }

    .empty-state {
      padding: 40px 20px;
      color: #666;
      opacity: 0.4;
    }

    .empty-timeline-ruler {
      height: 32px;
      background: #1f1f1f;
      border-bottom: 1px solid #333;
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 60px;
      font-size: 11px;
      color: #555;
    }

    .empty-timeline-tracks {
      padding: 20px;
    }

    .empty-timeline-row {
      display: flex;
      align-items: center;
      height: 32px;
      margin-bottom: 8px;
    }

    .empty-timeline-label {
      width: 150px;
      height: 24px;
      background: #222;
      border-radius: 4px;
      margin-right: 20px;
    }

    .empty-timeline-bar {
      height: 24px;
      background: #252525;
      border-radius: 4px;
      flex: 1;
      max-width: 70%;
    }

    /* Edit/Read Mode System */
    body[data-mode="read"] .edit-only {
      display: none !important;
    }

    body[data-mode="edit"] .read-only {
      display: none !important;
    }

    /* Adjust grid layout in read mode when resize handle is hidden */
    body[data-mode="read"] .main-content {
      grid-template-columns: 400px 1fr;
      gap: 20px;
    }

  </style>
</head>
<body>
  <div class="container">
    <div class="header-section">
      <h1>Motion Inspector</h1>
      <div class="controls">
        <input type="file" id="videoInput" accept="video/*" class="edit-only">
        <button class="btn btn-secondary edit-only" onclick="pasteSpec()">
          <span class="btn-emoji">üìã</span>&nbsp;&nbsp;Paste Spec
        </button>
        <button class="btn btn-secondary edit-only" onclick="exportZip()">
          <span class="btn-emoji">üì¶</span>&nbsp;&nbsp;Export Zip
        </button>
        <button class="btn btn-secondary read-only" onclick="toggleEditMode()">
          <span class="btn-emoji">‚úèÔ∏è</span>&nbsp;&nbsp;Edit
        </button>
      </div>
    </div>

    <div class="main-content">
      <div class="video-section">
        <div id="videoEmptyState" class="video-empty-state edit-only" onclick="document.getElementById('videoInput').click()">
          <div class="video-empty-state-btn">
            <span>üìÅ</span>
            <span>Add Video</span>
          </div>
        </div>
        <div id="videoContainer" class="video-container">
          <div class="video-wrapper">
            <video id="videoPlayer"></video>
            <div class="video-overlay edit-only" onclick="document.getElementById('videoInput').click()">
              <div class="video-replace-btn">
                <span>üìÅ</span>
                <span>Replace Video</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="resize-handle edit-only" id="resizeHandle"></div>

      <div class="timeline-section">
        <div id="timelineContent"></div>
      </div>
    </div>
  </div>

  <script>
    let specData = null;
    let uploadedVideoFile = null;
    let videoDuration = 0;
    let isDraggingPlayhead = false;
    let selectedAnimation = null;
    const isExportMode = false;
    let isEditMode = true; // Can be toggled in exported files
    let animationFrameId = null;
    let lastDraggedSpecTimeMs = null;
    let viewDuration = null; // Current zoom level (visible duration in ms)
    let lastDraggedVideoTime = null;
    let justFinishedDragging = false;
    let pendingVideoSeek = null;
    let videoSeekScheduled = false;

    // Video timing offset in milliseconds (adjust this to sync video with timeline)
    // Positive values shift timeline markers earlier (if video content appears late)
    const VIDEO_OFFSET_MS = 30;

    const video = document.getElementById('videoPlayer');

    // Update the UI mode (edit vs read)
    function updateMode() {
      const mode = isEditMode ? 'edit' : 'read';
      document.body.setAttribute('data-mode', mode);
    }

    // Toggle between edit and read modes
    function toggleEditMode() {
      isEditMode = !isEditMode;
      updateMode();
      // Re-render timeline to update draggable attributes and buttons
      if (specData) {
        renderTimeline();
      }
    }

    // Initialize mode on page load
    updateMode();

    // Throttled video seek using RAF to prevent multiple competing seeks
    function scheduleVideoSeek(targetTime) {
      pendingVideoSeek = targetTime;

      if (!videoSeekScheduled) {
        videoSeekScheduled = true;
        requestAnimationFrame(() => {
          if (pendingVideoSeek !== null) {
            video.currentTime = pendingVideoSeek;
            pendingVideoSeek = null;
          }
          videoSeekScheduled = false;
        });
      }
    }

    // Video upload handler
    // Check if video is width-constrained and update alignment
    function updateVideoAlignment() {
      const videoContainer = document.getElementById('videoContainer');
      const videoWrapper = document.querySelector('.video-wrapper');
      if (!videoContainer || !video || !video.videoWidth) return;

      const containerWidth = videoContainer.offsetWidth;
      const videoDisplayWidth = video.offsetWidth;

      // If video is using full container width (within 5px threshold), it's width-constrained
      if (Math.abs(containerWidth - videoDisplayWidth) < 5) {
        videoContainer.classList.add('width-constrained');
      } else {
        videoContainer.classList.remove('width-constrained');
      }
    }

    document.getElementById('videoInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        uploadedVideoFile = file; // Store for export
        const url = URL.createObjectURL(file);
        video.src = url;

        // Hide empty state and show video container when video is loaded
        const emptyState = document.getElementById('videoEmptyState');
        if (emptyState) {
          emptyState.classList.add('hidden');
        }
        const videoContainer = document.getElementById('videoContainer');
        if (videoContainer) {
          videoContainer.classList.add('has-video');
        }

        video.addEventListener('loadedmetadata', () => {
          videoDuration = video.duration * 1000; // Convert to ms
          // Ensure video starts at exactly 0
          video.currentTime = 0;
          if (specData) {
            renderTimeline();
          }
          // Check alignment after video loads
          setTimeout(updateVideoAlignment, 100);
        });
      }
    });

    // Update alignment on window resize
    window.addEventListener('resize', updateVideoAlignment);

    // Resize handle functionality
    const resizeHandle = document.getElementById('resizeHandle');
    const mainContent = document.querySelector('.main-content');
    let isResizing = false;
    let startX = 0;
    let startWidth = 400;

    resizeHandle.addEventListener('mousedown', (e) => {
      isResizing = true;
      startX = e.clientX;
      startWidth = document.querySelector('.video-section').offsetWidth;
      resizeHandle.classList.add('dragging');
      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';
    });

    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;

      const deltaX = e.clientX - startX;
      const newWidth = startWidth + deltaX;
      const containerWidth = mainContent.offsetWidth;
      const minWidth = 400;
      const maxWidth = containerWidth / 2;

      // Clamp width between min and max
      const clampedWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));

      // Update grid column
      mainContent.style.gridTemplateColumns = `${clampedWidth}px 20px 1fr`;

      // Update playhead position during resize
      requestAnimationFrame(() => updatePlayhead());
    });

    document.addEventListener('mouseup', () => {
      if (isResizing) {
        isResizing = false;
        resizeHandle.classList.remove('dragging');
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        updateVideoAlignment();
      }
    });

    // Play/pause toggle
    function togglePlayPause() {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (video.paused) {
        video.play();
        if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon pause">‚è∏</span>';
        startPlayheadAnimation();
      } else {
        video.pause();
        if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon">‚ñ∂</span>';
        stopPlayheadAnimation();
      }
    }

    // Set playback speed
    function setPlaybackSpeed(speed) {
      video.playbackRate = speed;

      // Update button states
      document.querySelectorAll('.speed-btn').forEach(btn => {
        btn.classList.remove('selected');
      });

      const selectedBtn = document.querySelector(`.speed-btn[data-speed="${speed}"]`);
      if (selectedBtn) {
        selectedBtn.classList.add('selected');
      }
    }

    // Duration controls - extend/shorten timeline
    function zoomIn() {
      if (!specData) return;

      // Extend timeline duration by 100ms
      specData.workArea.duration += 100;

      // Reset view duration to show full timeline
      viewDuration = null;

      renderTimeline();
    }

    function zoomOut() {
      if (!specData) return;

      // Shorten timeline duration by 100ms (minimum 100ms)
      const newDuration = Math.max(100, specData.workArea.duration - 100);
      specData.workArea.duration = newDuration;

      // Reset view duration to show full timeline
      viewDuration = null;

      renderTimeline();
    }

    // Toggle layout between vertical (400px | 1fr) and 50/50 split
    function toggleLayout() {
      const mainContent = document.querySelector('.main-content');
      mainContent.classList.toggle('split-layout');

      // Update button emoji based on current state
      const toggleBtn = event.currentTarget;
      if (mainContent.classList.contains('split-layout')) {
        // Now in 50/50 split, show desktop emoji
        toggleBtn.innerHTML = '<span class="btn-emoji">üñ•Ô∏è</span>&nbsp;&nbsp;Toggle Layout';
      } else {
        // Now in narrow layout, show smartphone emoji
        toggleBtn.innerHTML = '<span class="btn-emoji">üì±</span>&nbsp;&nbsp;Toggle Layout';
      }

      // Update playhead position after layout change
      requestAnimationFrame(() => updatePlayhead());
    }

    // Smooth playhead animation using RAF
    function animatePlayhead() {
      if (!isDraggingPlayhead && !video.paused) {
        updatePlayhead();
        updateTimeDisplays();
        animationFrameId = requestAnimationFrame(animatePlayhead);
      }
    }

    function startPlayheadAnimation() {
      if (animationFrameId === null) {
        animationFrameId = requestAnimationFrame(animatePlayhead);
      }
    }

    function stopPlayheadAnimation() {
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
    }

    // Video events
    video.addEventListener('play', () => {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon pause">‚è∏</span>';
      startPlayheadAnimation();
    });

    video.addEventListener('pause', () => {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon">‚ñ∂</span>';
      stopPlayheadAnimation();
    });

    video.addEventListener('ended', () => {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon">‚ñ∂</span>';
      stopPlayheadAnimation();
    });

    // Update time displays
    function updateTimeDisplays() {
      // If we just finished dragging, use the stored position instead of recalculating
      let specTimeMs;
      if (justFinishedDragging && lastDraggedSpecTimeMs !== null) {
        specTimeMs = lastDraggedSpecTimeMs;
      } else {
        // Calculate spec time based on video progress with offset adjustment
        specTimeMs = video.currentTime * 1000;
        if (video.duration && specData) {
          // Apply offset: subtract VIDEO_OFFSET_MS from video time before calculating progress
          const adjustedVideoTime = Math.max(0, video.currentTime - (VIDEO_OFFSET_MS / 1000));
          const videoProgress = adjustedVideoTime / video.duration;
          specTimeMs = videoProgress * specData.workArea.duration;
        }
      }

      const playheadTimeDisplay = document.getElementById('playheadTimeDisplay');
      if (playheadTimeDisplay) {
        playheadTimeDisplay.textContent = `${specTimeMs.toFixed(0)}ms`;
      }
    }

    // Update playhead position
    function updatePlayhead() {
      // Don't update position during or right after dragging - user has direct control
      if (isDraggingPlayhead || justFinishedDragging) return;

      const playhead = document.querySelector('.playhead');
      const timelineContainer = document.querySelector('.timeline-container');
      const timelineContent = document.querySelector('.timeline-content-column');

      if (playhead && timelineContainer && timelineContent) {
        const positionPercent = getTimelinePosition(video.currentTime);
        const containerRect = timelineContainer.getBoundingClientRect();
        const contentRect = timelineContent.getBoundingClientRect();

        // Calculate pixel position relative to viewport
        const leftPosition = contentRect.left + (positionPercent / 100 * contentRect.width);
        playhead.style.left = `${leftPosition}px`;
        playhead.style.top = `${containerRect.top + 44}px`;
        playhead.style.bottom = `${window.innerHeight - containerRect.bottom}px`;
      }
    }

    // Paste spec from clipboard
    async function pasteSpec() {
      try {
        const text = await navigator.clipboard.readText();
        console.log('Clipboard text:', text);
        const data = JSON.parse(text);
        specData = data;
        viewDuration = null; // Reset zoom level for new spec
        renderTimeline();
      } catch (err) {
        alert('Failed to paste or parse JSON.\n\nError: ' + err.message + '\n\nCheck the browser console for more details.');
        console.error('Parse error:', err);
        console.error('Clipboard content:', await navigator.clipboard.readText());
      }
    }

    // Get the base HTML template for export (without the export button and JSZip)
    function getExportTemplate(videoFileName, specDataJson, videoSectionWidth = 400) {
      console.log('[GET_EXPORT_TEMPLATE] videoSectionWidth:', videoSectionWidth);

      // Get all the styles from this page
      const styleElement = document.querySelector('style');
      const styles = styleElement ? styleElement.textContent : '';
      console.log('[GET_EXPORT_TEMPLATE] Styles length:', styles.length);

      // Build custom CSS for the exported file with the video section width
      const customCSS = `
    /* Preserve exported video section width */
    body[data-mode='read'] .main-content {
      grid-template-columns: ${videoSectionWidth}px 1fr;
    }
    body[data-mode='edit'] .main-content {
      grid-template-columns: ${videoSectionWidth}px 20px 1fr;
    }`;
      console.log('[GET_EXPORT_TEMPLATE] customCSS:', customCSS);

      // Get all the script content (we'll extract just the functions we need)
      const scriptElement = document.querySelector('script:not([src])');
      const scriptContent = scriptElement ? scriptElement.textContent : '';
      console.log('[GET_EXPORT_TEMPLATE] Script content length:', scriptContent.length);

      // Remove the exportZip and getExportTemplate functions from the script
      const cleanedScript = scriptContent
        .replace(/\/\/ Get the base HTML template for export[\s\S]*?return result;\s*\n\s*}\s*\n/m, '')
        .replace(/\/\/ Export everything as a zip file[\s\S]*?}\s*catch[\s\S]*?}\s*\n\s*}\s*\n/m, '')
        .replace(/let uploadedVideoFile = null;\s*\n/g, '')
        .replace(/const isExportMode = false;/g, 'const isExportMode = true;')
        .replace(/let isEditMode = true;/g, 'let isEditMode = false;')
        .replace(/\/\/ Initialize with default spec[\s\S]*?\/\/ Render the default timeline\s*\n\s*renderTimeline\(\);\s*\n/m, '');

      console.log('[GET_EXPORT_TEMPLATE] Cleaned script length after replacements:', cleanedScript.length);

      console.log('[GET_EXPORT_TEMPLATE] Cleaned script length:', cleanedScript.length);
      console.log('[GET_EXPORT_TEMPLATE] First 500 chars of cleaned script:', cleanedScript.substring(0, 500));

      const result = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Motion Inspector</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='utf-8'?%3e%3c!--%20Generator:%20Adobe%20Illustrator%2027.9.0,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%206.00%20Build%200)%20--%3e%3csvg%20version='1.1'%20id='Layer_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%20150%20150'%20style='enable-background:new%200%200%20150%20150;'%20xml:space='preserve'%3e%3cstyle%20type='text/css'%3e%20.st0{fill-rule:evenodd;clip-rule:evenodd;}%20@media%20(prefers-color-scheme:%20dark)%20{%20.st0%20{%20fill:%23FFFFFF;%20}%20}%20%3c/style%3e%3cg%20id='Layer_1_00000076594398665045771890000013973700932976003724_'%3e%3cg%3e%3cpath%20class='st0'%20d='M131.3,118c-1.1,7.2-5.9,13.5-12.9,16.2c-3.4,1.3-7.1,1.9-10.7,1.3c-3.6-0.4-7.1-1.6-10.7-3.6%20c-5.1-2.8-10.2-7.2-16-13.5c9.3-11.3,15-21.7,17-31c0.9-4.3,1.2-8.3,0.7-11.9c-0.5-3.5-1.7-6.7-3.8-9.5%20c-4.3-6.3-11.7-9.9-19.8-9.9c-8.2,0-15.6,3.8-19.8,9.9c-1.9,2.8-3.2,6-3.8,9.5c-0.5,3.6-0.4,7.6,0.7,11.9c2.1,9.3,7.9,19.7,17,31%20c-5.8,6.4-10.9,10.7-16,13.5c-3.6,2-7.2,3.2-10.7,3.6c-3.8,0.4-7.4,0-10.7-1.3c-6.8-2.8-11.8-9-12.9-16.2c-0.5-3.6-0.1-7,1.2-10.9%20c0.5-1.3,1.1-2.8,1.9-4.4c1.1-2.3,2.1-4.7,3.2-7l0.1-0.3c9.7-20.9,20.1-42,30.8-62.9l0.4-0.8c1.1-2.1,2.3-4.3,3.4-6.4%20c1.2-2.1,2.4-4.3,4-6.2c3-3.5,6.8-5.2,11.3-5.2c4.4,0,8.3,1.9,11.3,5.2c1.6,1.9,2.8,4,4,6.2c1.1,2.1,2.3,4.3,3.4,6.4l0.4,0.9%20c10.9,20.8,21.2,42,30.8,62.9l0.1,0.1c1.1,2.3,2.1,4.7,3.2,7.1c0.7,1.6,1.3,3.1,1.9,4.4C131.4,111.1,131.8,114.6,131.3,118z%20M74.9,111.6c-7.6-9.7-12.5-18.5-14.2-26c-0.7-3.1-0.9-6-0.5-8.6c0.4-2.1,1.1-4.2,2.3-5.9c2.7-3.8,7.2-6,12.5-6%20c5.1,0,9.8,2.3,12.5,6c1.2,1.7,1.9,3.6,2.3,5.9c0.4,2.5,0.3,5.5-0.5,8.6C87.4,93.1,82.6,102,74.9,111.6z%20M138.5,104.2%20c-0.7-1.7-1.3-3.5-2-5.1c-1.1-2.4-2.1-4.8-3.4-7.2l-0.1-0.1c-9.8-20.9-20.2-42.2-31.1-63.2l-0.4-0.9c-1.1-2.1-2.3-4.3-3.5-6.6%20c-1.3-2.5-3-5.2-5.1-7.8C88.2,8,81.9,5,74.8,5c-7,0-13.4,3-18.1,8.3c-2.1,2.5-3.6,5.2-5.1,7.8c-1.2,2.1-2.3,4.4-3.5,6.6l-0.4,0.8%20C37.1,49.7,26.7,70.8,16.9,91.9l-0.1,0.3c-1.1,2.3-2.1,4.7-3.2,7.1c-0.7,1.6-1.5,3.2-2,5.1c-1.9,5.1-2.4,10.1-1.6,15%20c1.5,10.5,8.6,19.3,18.4,23.3c3.6,1.5,7.5,2.3,11.5,2.3c1.2,0,2.4-0.1,3.8-0.3c4.7-0.5,9.5-2.1,14.1-4.7%20c5.8-3.2,11.4-7.9,17.4-14.5c6.2,6.7,11.8,11.4,17.4,14.5c4.7,2.5,9.4,4.2,14.1,4.7c1.2,0.1,2.4,0.3,3.8,0.3c4,0,7.9-0.8,11.5-2.3%20c9.8-3.9,16.9-12.9,18.4-23.3C140.8,114.4,140.3,109.5,138.5,104.2z'/%3e%3c/g%3e%3c/g%3e%3cg%20id='Dimensions'%3e%3c/g%3e%3c/svg%3e">
  <style>${styles}${customCSS}</style>
</head>
<body>
  <div class="container">
    <div class="header-section">
      <h1>Motion Inspector</h1>
      <div class="controls">
        <input type="file" id="videoInput" accept="video/*" class="edit-only">
        <button class="btn btn-secondary edit-only" onclick="pasteSpec()">
          <span class="btn-emoji">üìã</span>&nbsp;&nbsp;Paste Spec
        </button>
        <button class="btn btn-secondary edit-only" onclick="exportZip()">
          <span class="btn-emoji">üì¶</span>&nbsp;&nbsp;Export Zip
        </button>
        <button class="btn btn-secondary read-only" onclick="toggleEditMode()">
          <span class="btn-emoji">‚úèÔ∏è</span>&nbsp;&nbsp;Edit
        </button>
      </div>
    </div>

    <div class="main-content">
      <div class="video-section">
        <div id="videoEmptyState" class="video-empty-state edit-only" style="display: none;">
          <div class="video-empty-state-btn">
            <span>üìÅ</span>
            <span>Add Video</span>
          </div>
        </div>
        <div id="videoContainer" class="video-container">
          <div class="video-wrapper">
            <video id="videoPlayer"></video>
            <div class="video-overlay edit-only" onclick="document.getElementById('videoInput').click()">
              <div class="video-replace-btn">
                <span>üìÅ</span>
                <span>Replace Video</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="resize-handle edit-only" id="resizeHandle"></div>

      <div class="timeline-section">
        <div id="timelineContent"></div>
      </div>
    </div>
  </div>

  <script>
${cleanedScript}
    // Auto-load embedded data
    const EMBEDDED_SPEC_DATA = ${specDataJson};
    const EMBEDDED_VIDEO_PATH = './${videoFileName}';

    window.addEventListener('DOMContentLoaded', () => {
      console.log('[EXPORT] DOMContentLoaded fired');
      console.log('[EXPORT] isEditMode:', isEditMode);
      console.log('[EXPORT] body data-mode:', document.body.getAttribute('data-mode'));

      specData = EMBEDDED_SPEC_DATA;
      console.log('[EXPORT] specData loaded:', specData);

      video.src = EMBEDDED_VIDEO_PATH;
      const videoContainer = document.getElementById('videoContainer');
      if (videoContainer) {
        videoContainer.classList.add('has-video');
      }

      // Render timeline immediately
      console.log('[EXPORT] About to render timeline');
      renderTimeline();
      console.log('[EXPORT] Timeline rendered');

      video.addEventListener('loadedmetadata', () => {
        videoDuration = video.duration * 1000;
        video.currentTime = 0;
        setTimeout(updateVideoAlignment, 100);
      });
    });
  <\/script>
</body>
</html>`;

      console.log('[GET_EXPORT_TEMPLATE] Result length:', result.length);
      return result;
    }

    // Export everything as a zip file
    async function exportZip() {
      if (!specData) {
        alert('Please paste a spec first (üìã Paste Spec button)');
        return;
      }
      if (!uploadedVideoFile) {
        alert('Please upload a video first (Upload Video button)');
        return;
      }

      try {
        // Get video file extension
        const videoFileName = uploadedVideoFile.name;
        const videoExt = videoFileName.substring(videoFileName.lastIndexOf('.'));
        const videoFileNameInZip = `video${videoExt}`;

        // Get current video section width
        const videoSection = document.querySelector('.video-section');
        const videoSectionWidth = videoSection ? videoSection.offsetWidth : 400;
        console.log('[EXPORT] Video section width:', videoSectionWidth);

        // Generate clean HTML template
        const exportHtml = getExportTemplate(videoFileNameInZip, JSON.stringify(specData), videoSectionWidth);
        console.log('[EXPORT] Generated HTML length:', exportHtml.length);

        // Create download link with spec name
        const specName = specData.compName.replace(/[^a-z0-9]/gi, '_').toLowerCase();

        // Create zip file
        const zip = new JSZip();
        zip.file(`${specName}.html`, exportHtml);
        zip.file(videoFileNameInZip, uploadedVideoFile);

        // Generate zip and download
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        const zipUrl = URL.createObjectURL(zipBlob);
        const link = document.createElement('a');
        link.href = zipUrl;
        link.download = `${specName}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(zipUrl);
      } catch (err) {
        alert('Failed to create zip file: ' + err.message);
        console.error(err);
      }
    }

    // Get color class for property
    function getPropertyColorClass(property) {
      const prop = property.toLowerCase();
      if (prop.includes('add parameter')) return 'bar-scale'; // Pink color for new parameters
      if (prop.includes('opacity')) return 'bar-opacity';
      if (prop.includes('scale')) return 'bar-scale';
      if (prop.includes('rotation') || prop.includes('rotate')) return 'bar-rotation';
      if (prop.includes('x position')) return 'bar-position-x';
      if (prop.includes('y position')) return 'bar-position-y';
      if (prop.includes('width')) return 'bar-width';
      if (prop.includes('height')) return 'bar-height';
      if (prop.includes('blur')) return 'bar-blur';
      if (prop.includes('transform')) return 'bar-transform';
      return 'bar-default';
    }

    // Get hex color for property color class
    function getPropertyColor(colorClass) {
      const colorMap = {
        'bar-opacity': '#045c45',
        'bar-scale': '#a82968',
        'bar-rotation': '#5a1778',
        'bar-position-x': '#045c7d',
        'bar-position-y': '#045c7d',
        'bar-width': '#045c45',
        'bar-height': '#045c45',
        'bar-blur': '#4a4a4a',
        'bar-transform': '#5a1778',
        'bar-default': '#045c7d'
      };
      return colorMap[colorClass] || '#045c7d';
    }

    // Brighten a hex color to match the selected state (1.2x brightness)
    function brightenColor(hex) {
      // Remove # if present
      hex = hex.replace('#', '');

      // Parse RGB
      let r = parseInt(hex.substring(0, 2), 16);
      let g = parseInt(hex.substring(2, 4), 16);
      let b = parseInt(hex.substring(4, 6), 16);

      // Apply same brightness filter as selected bars (1.2x)
      r = Math.min(255, Math.round(r * 1.2));
      g = Math.min(255, Math.round(g * 1.2));
      b = Math.min(255, Math.round(b * 1.2));

      // Add more brightness to make it pop like the stroke
      r = Math.min(255, Math.round(r * 1.3));
      g = Math.min(255, Math.round(g * 1.3));
      b = Math.min(255, Math.round(b * 1.3));

      // Convert back to hex
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    // Convert video time to timeline position percentage
    function getTimelinePosition(videoTimeSeconds) {
      if (!video.duration || !specData) return 0;
      // Apply offset: subtract VIDEO_OFFSET_MS from video time
      const adjustedVideoTime = Math.max(0, videoTimeSeconds - (VIDEO_OFFSET_MS / 1000));
      const videoProgress = adjustedVideoTime / video.duration;
      const specTimeMs = videoProgress * specData.workArea.duration;
      // Position based on current view duration (accounts for zoom)
      const currentViewDuration = viewDuration || specData.workArea.duration;
      return (specTimeMs / currentViewDuration) * 100;
    }

    // Convert alignment number to text
    function getAlignmentText(alignment) {
      const alignments = {
        1: 'center',
        2: 'center left',
        3: 'center right',
        5: 'top center',
        6: 'top left',
        7: 'top right',
        9: 'bottom center',
        10: 'bottom left',
        11: 'bottom right'
      };
      return alignments[alignment] || 'unknown';
    }

    // Format numeric values to max 2 decimal places
    function formatDecimalValue(value) {
      if (value === null || value === undefined) return value;

      // Convert to string if it's a number
      const strValue = String(value);

      // Replace all numbers in the string, preserving units and formatting
      return strValue.replace(/(\d+\.?\d*)/g, (match) => {
        const num = parseFloat(match);
        if (isNaN(num)) return match;

        // If it's a whole number, return as is
        if (num % 1 === 0) return String(num);

        // Otherwise round to 2 decimal places and remove trailing zeros
        return parseFloat(num.toFixed(2)).toString();
      });
    }

    // Convert scaleTo number to text
    function getScaleToText(scaleTo) {
      const scaleOptions = {
        1: 'width',
        2: 'height',
        3: 'stretch',
        4: 'none'
      };
      return scaleOptions[scaleTo] || 'unknown';
    }

    // Get natural language description of animation
    function getAnimationDescription(property, values, fitToShape, customDescription) {
      const prop = property.toLowerCase();
      let description;

      // Check for custom description first
      if (customDescription) {
        return customDescription;
      }

      // Handle Fit to Shape animations
      if (fitToShape) {
        const alignment = getAlignmentText(fitToShape.alignment);
        const scaleTo = getScaleToText(fitToShape.scaleTo);
        description = `Parented to ${fitToShape.containerLayerName}, fit to ${scaleTo} and aligned to ${alignment}`;
      }
      // Handle cases where values is null
      else if (!values || values.change === undefined || values.change === null) {
        description = property;
      }
      else {
        const change = values.change;
        const changeValue = Array.isArray(change) ? change[0] : change;
        const absChange = Math.abs(changeValue);

        // Handle generic "Position" property (not X/Y Position)
        if (prop === 'position' && Array.isArray(change) && values.animatingAxes) {
          const xChange = change[0];
          const yChange = change[1];

          if (values.animatingAxes.both) {
            const xDir = xChange < 0 ? 'left' : 'right';
            const yDir = yChange < 0 ? 'up' : 'down';
            description = `slides ${xDir} ${Math.round(Math.abs(xChange))}px and ${yDir} ${Math.round(Math.abs(yChange))}px`;
          } else if (values.animatingAxes.x) {
            const direction = xChange < 0 ? 'left' : 'right';
            description = `slides ${direction} ${Math.round(Math.abs(xChange))}px`;
          } else if (values.animatingAxes.y) {
            const direction = yChange < 0 ? 'up' : 'down';
            description = `slides ${direction} ${Math.round(Math.abs(yChange))}px`;
          } else {
            description = property;
          }
        }
        else if (prop.includes('x position')) {
          const direction = changeValue < 0 ? 'left' : 'right';
          description = `slides ${direction} ${Math.round(absChange)}px`;
        }
        else if (prop.includes('y position')) {
          const direction = changeValue < 0 ? 'up' : 'down';
          description = `slides ${direction} ${Math.round(absChange)}px`;
        }
        // Handle generic "Size" property
        else if (prop === 'size' && Array.isArray(change)) {
          const widthChange = change[0];
          const heightChange = change[1];

          // Check if both dimensions change the same way
          if (widthChange === heightChange) {
            const action = widthChange > 0 ? 'expands' : 'shrinks';
            description = action;
          } else {
            const widthAction = widthChange > 0 ? 'expands' : 'shrinks';
            const heightAction = heightChange > 0 ? 'expands' : 'shrinks';
            description = `width ${widthAction}, height ${heightAction}`;
          }
        }
        else if (prop.includes('width')) {
          const action = changeValue > 0 ? 'expands' : 'shrinks';
          description = `width ${action}`;
        }
        else if (prop.includes('height')) {
          const action = changeValue > 0 ? 'expands' : 'shrinks';
          description = `height ${action}`;
        }
        else if (prop.includes('blur radius')) {
          const action = changeValue > 0 ? 'blurs' : 'unblurs';
          description = action;
        }
        else if (prop.includes('amount to tint')) {
          const action = changeValue > 0 ? 'tints' : 'untints';
          description = action;
        }
        else if (prop.includes('scale')) {
          if (values.formatted) {
            // Extract just the first value if x and y are the same
            let startVal = values.formatted.startValue;
            let endVal = values.formatted.endValue;

            // Check if it's a format like "100%, 100%" and extract first value
            if (typeof startVal === 'string' && startVal.includes(',')) {
              const startParts = startVal.split(',').map(s => s.trim());
              if (startParts[0] === startParts[1]) {
                startVal = startParts[0];
              }
            }
            if (typeof endVal === 'string' && endVal.includes(',')) {
              const endParts = endVal.split(',').map(s => s.trim());
              if (endParts[0] === endParts[1]) {
                endVal = endParts[0];
              }
            }

            // Format decimal values
            startVal = formatDecimalValue(startVal);
            endVal = formatDecimalValue(endVal);

            if (startVal === endVal) {
              description = `scales to ${endVal}`;
            } else {
              description = `scales ${changeValue > 0 ? 'up' : 'down'} from ${startVal} to ${endVal}`;
            }
          } else {
            description = changeValue > 0 ? 'scales up' : 'scales down';
          }
        }
        else if (prop.includes('rotation') || prop.includes('rotate')) {
          const direction = changeValue < 0 ? 'counter-clockwise' : 'clockwise';
          description = `rotates ${direction} ${Math.round(absChange)}¬∞`;
        }
        else if (prop.includes('opacity')) {
          if (values.formatted) {
            description = `fades ${changeValue > 0 ? 'in' : 'out'} from ${formatDecimalValue(values.formatted.startValue)} to ${formatDecimalValue(values.formatted.endValue)}`;
          } else {
            description = changeValue > 0 ? 'fades in' : 'fades out';
          }
        }
        else {
          description = property;
        }
      }

      // Capitalize first letter
      return description.charAt(0).toUpperCase() + description.slice(1);
    }

    // Generate nice time divisions
    function getNiceTimeIntervals(duration) {
      const niceIntervals = [100, 200, 250, 500, 1000, 2000, 2500, 5000];
      const targetDivisions = 8;

      for (const interval of niceIntervals) {
        const divisions = Math.floor(duration / interval);
        if (divisions >= 6 && divisions <= 10) {
          return { interval, count: divisions };
        }
      }

      // Fallback: divide by 8
      return { interval: duration / 8, count: 8 };
    }

    // Render the timeline
    function renderTimeline() {
      console.log('[RENDER] renderTimeline called, specData:', specData);
      if (!specData) {
        console.log('[RENDER] No specData, returning');
        return;
      }

      const content = document.getElementById('timelineContent');
      console.log('[RENDER] timelineContent element:', content);

      // Update the main title with the spec name
      document.querySelector('h1').textContent = specData.compName;
      // Update the page title
      document.title = `Motion Inspector - ${specData.compName}`;

      let html = '';

      // Timeline container
      html += `<div class="timeline-container">`;

      // Left column - labels
      html += `<div class="timeline-labels-column">`;
      html += `<div class="playhead-time">
        <button id="playPauseBtn" onclick="togglePlayPause()"><span class="icon">‚ñ∂</span></button>
        <button class="speed-btn selected" data-speed="1" onclick="setPlaybackSpeed(1)">1x</button>
        <button class="speed-btn" data-speed="0.5" onclick="setPlaybackSpeed(0.5)">0.5x</button>
        <button class="speed-btn" data-speed="0.1" onclick="setPlaybackSpeed(0.1)">0.1x</button>
      </div>`; // Play button and speed controls above labels

      let animIndex = 0;
      specData.layers.forEach((layer, layerIndex) => {
        // Layer header label (add divider class if not first layer)
        const dividerClass = layerIndex > 0 ? ' has-divider' : '';
        html += `<div class="timeline-label layer-header${dividerClass}"
                      draggable="${isEditMode}"
                      data-drag-type="layer"
                      data-layer-index="${layerIndex}"
                      data-is-section-divider="${layerIndex > 0 ? 'true' : 'false'}">
          <span class="timeline-label-text">${layer.layerName}</span>
          <button class="timeline-label-add-btn edit-only" draggable="false">+</button>
          ${layerIndex > 0 ? '<button class="section-divider-add-btn edit-only" draggable="false">+</button>' : ''}
        </div>`;

        // Animation labels for this layer
        layer.animations.forEach((anim, animIndexInLayer) => {
          html += `<div class="timeline-label indented"
                        draggable="${isEditMode}"
                        data-drag-type="animation"
                        data-anim-index="${animIndex}"
                        data-layer-index="${layerIndex}"
                        data-anim-in-layer="${animIndexInLayer}">
            <span class="timeline-label-text">${anim.property}</span>
            <button class="timeline-label-add-btn edit-only" draggable="false">+</button>
          </div>`;
          animIndex++;
        });
      });

      // Bottom section divider for adding new sections at the end
      html += `<div class="timeline-bottom-divider">
        <button class="section-divider-add-btn edit-only" draggable="false">+</button>
      </div>`;

      html += `</div>`; // timeline-labels-column

      // Right column - timeline content
      html += `<div class="timeline-content-column">`;

      // Zoom controls
      const specDuration = specData.workArea.duration;
      // Initialize viewDuration to rounded spec duration if not set
      if (!viewDuration) {
        viewDuration = Math.round(specDuration / 100) * 100;
      }
      const currentViewDuration = viewDuration;
      html += `<div class="zoom-controls edit-only">
        <span class="zoom-duration">Timeline duration: ${specDuration}ms</span>
        <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
        <button class="zoom-btn" onclick="zoomIn()">+</button>
      </div>`;

      // Timeline ruler - use view duration for rendering
      const timeIntervals = getNiceTimeIntervals(currentViewDuration);
      const interval = timeIntervals.interval;
      const ticks = [];

      for (let time = 0; time <= currentViewDuration; time += interval) {
        ticks.push(time);
      }
      // Don't add final tick at exact duration - we'll stop before it

      html += `<div class="timeline-ruler">`;
      html += `<div style="position: absolute; top: 0; left: 0; right: 0; height: 100%;">`;
      ticks.forEach((time, index) => {
        // Skip the last tick if it's at the end
        if (time >= currentViewDuration) return;

        // Position based on view time percentage, centered over grid line
        const position = (time / currentViewDuration) * 100;
        html += `<div class="timeline-tick" style="position: absolute; left: ${position}%; height: 100%; transform: translateX(-50%);">${Math.round(time)}ms</div>`;
      });
      html += `</div></div>`;

      // Timeline grid with bars
      html += `<div style="position: relative; padding-right: 80px;">`;
      html += `<div class="timeline-grid-lines" style="display: block; position: absolute; top: -8px; left: 0; right: 0; height: calc(100% + 8px); pointer-events: none; z-index: 5;">`;

      // Main grid lines (taller - extend into ruler, stop at bottom divider)
      ticks.forEach(time => {
        if (time >= currentViewDuration) return;
        const position = (time / currentViewDuration) * 100;
        html += `<div style="position: absolute; left: ${position}%; top: 0; bottom: 15px; width: 1px; background: rgba(255, 255, 255, 0.12);"></div>`;
      });

      // Subtle halfway markers between main grid lines (normal height - start below ruler, stop at bottom divider)
      for (let i = 0; i < ticks.length - 1; i++) {
        const midTime = (ticks[i] + ticks[i + 1]) / 2;
        const position = (midTime / currentViewDuration) * 100;
        html += `<div style="position: absolute; left: ${position}%; top: 8px; bottom: 15px; width: 1px; background: rgba(255, 255, 255, 0.06);"></div>`;
      }

      html += `</div>`;

      // Helper function to find parent layer timing and spring status
      function getParentLayerInfo(containerLayerName) {
        const parentLayer = specData.layers.find(l => l.layerName === containerLayerName);
        if (!parentLayer || !parentLayer.animations || parentLayer.animations.length === 0) {
          return { delay: 0, duration: specData.workArea.duration, hasSpring: false };
        }

        // Find the earliest start and latest end across all parent animations
        let minDelay = Infinity;
        let maxEnd = 0;
        let hasSpring = false;

        parentLayer.animations.forEach(anim => {
          const animStart = anim.timing.delay;
          const animEnd = anim.timing.delay + anim.timing.duration;
          minDelay = Math.min(minDelay, animStart);
          maxEnd = Math.max(maxEnd, animEnd);
          if (anim.easing.type === 'spring') {
            hasSpring = true;
          }
        });

        return {
          delay: minDelay === Infinity ? 0 : minDelay,
          duration: maxEnd - (minDelay === Infinity ? 0 : minDelay),
          hasSpring: hasSpring
        };
      }

      // Timeline tracks
      animIndex = 0;
      specData.layers.forEach((layer, layerIndex) => {
        // Empty track for layer header (add divider class if not first layer)
        const dividerClass = layerIndex > 0 ? ' has-divider' : '';
        html += `<div class="timeline-track layer-header${dividerClass}"></div>`;

        // Animation tracks for this layer
        layer.animations.forEach(anim => {
          let startPercent, widthPercent, description, springClass;

          // Handle Fit to Shape animations - use parent layer's timing
          if (anim.isFitToShape && anim.fitToShape) {
            const parentInfo = getParentLayerInfo(anim.fitToShape.containerLayerName);
            startPercent = (parentInfo.delay / currentViewDuration) * 100;
            widthPercent = (parentInfo.duration / currentViewDuration) * 100;
            description = getAnimationDescription(anim.property, anim.values, anim.fitToShape, anim.description);
            springClass = parentInfo.hasSpring ? ' bar-spring' : '';
          } else {
            // Normal animation - use its own timing
            startPercent = (anim.timing.delay / currentViewDuration) * 100;
            widthPercent = (anim.timing.duration / currentViewDuration) * 100;
            description = getAnimationDescription(anim.property, anim.values, null, anim.description);
            springClass = anim.easing.type === 'spring' ? ' bar-spring' : '';
          }

          // Cap width so bars don't extend past the edge (shows rounded corners naturally)
          const maxWidth = 100 - startPercent;
          widthPercent = Math.min(widthPercent, maxWidth);

          const colorClass = getPropertyColorClass(anim.property);

          // Build inline style for custom colors
          let customStyle = `left: ${startPercent}%; width: ${widthPercent}%;`;
          if (anim.customColor) {
            if (anim.easing.type === 'spring') {
              // Spring gradient with custom color
              const rgb = anim.customColor.match(/\w\w/g).map(x => parseInt(x, 16));
              customStyle += ` background: linear-gradient(90deg, ${anim.customColor} 0%, ${anim.customColor} 50%, rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0) 100%);`;
            } else {
              // Solid custom color
              customStyle += ` background: ${anim.customColor};`;
            }
          }

          html += `<div class="timeline-track">`;
          html += `
            <div class="timeline-bar ${colorClass}${springClass}"
                 style="${customStyle}"
                 data-anim-index="${animIndex}"
                 data-is-spring="${anim.easing.type === 'spring'}">
              <span class="timeline-bar-text">${description}</span>
              <div class="timeline-bar-resize-handle left" data-handle="left"></div>
              ${anim.easing.type !== 'spring' ? '<div class="timeline-bar-resize-handle right" data-handle="right"></div>' : ''}
            </div>
          `;
          html += `</div>`;

          animIndex++;
        });
      });

      // Bottom divider track to match left column
      html += `<div class="timeline-track timeline-bottom-track" style="border-top: 1px solid #4a4a4a; border-bottom: none; margin-top: 15px; height: 15px;"></div>`;

      html += `<div class="playhead" id="playhead"><div class="playhead-handle" id="playheadTimeDisplay">0ms</div></div>`;
      html += `</div>`; // position relative wrapper
      html += `</div>`; // timeline-content-column
      html += `</div>`; // timeline-container

      // Detail panel placeholder
      html += `<div id="detailPanel"></div>`;

      content.innerHTML = html;
      console.log('[RENDER] HTML set, length:', html.length);

      // Setup playhead dragging
      setupPlayheadDragging();

      // Setup animation bar clicks
      document.querySelectorAll('.timeline-bar').forEach(bar => {
        bar.addEventListener('click', (e) => {
          e.stopPropagation();
          const animIndex = parseInt(bar.dataset.animIndex);
          // Toggle: if clicking the same animation, close the info box
          if (selectedAnimation === animIndex) {
            document.getElementById('detailPanel').innerHTML = '';
            selectedAnimation = null;
            // Remove selected class from all bars and labels
            document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected'));
            requestAnimationFrame(() => {
              updatePlayhead();
            });
          } else {
            // Remove selected class from all bars and labels
            document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected'));
            // Add selected class to clicked bar
            bar.classList.add('selected');
            // Add selected class to corresponding label
            const label = document.querySelector(`.timeline-label.indented[data-anim-index="${animIndex}"]`);
            if (label) label.classList.add('selected');
            showAnimationDetails(animIndex);
          }
        });
      });

      // Setup resize handles
      setupResizeHandles();

      // Setup bar dragging (for moving timeline position or reordering)
      setupBarDragging();

      updatePlayhead();

      // Detect text overflow and add fade class
      detectTextOverflow();

      // Setup drag and drop
      setupDragAndDrop();

      // Setup hover zones for add buttons
      setupAddButtonHoverZones();
    }

    // Detect which bars have overflowing text and add fade class
    function detectTextOverflow() {
      const bars = document.querySelectorAll('.timeline-bar');
      bars.forEach(bar => {
        const textElement = bar.querySelector('.timeline-bar-text');
        if (textElement) {
          // Check if text is wider than the container
          const textWidth = textElement.scrollWidth;
          const containerWidth = bar.clientWidth - 16; // Subtract padding (8px * 2)

          if (textWidth > containerWidth) {
            bar.classList.add('has-text-overflow');
          } else {
            bar.classList.remove('has-text-overflow');
          }
        }
      });
    }

    // Setup drag and drop for timeline labels
    let draggedElement = null;
    let draggedType = null;
    let draggedLayerIndex = null;
    let draggedAnimIndex = null;

    function setupDragAndDrop() {
      const labels = document.querySelectorAll('.timeline-label');

      labels.forEach(label => {
        // Dragstart - record what's being dragged
        label.addEventListener('dragstart', (e) => {
          draggedElement = label;
          draggedType = label.dataset.dragType;
          draggedLayerIndex = parseInt(label.dataset.layerIndex);
          draggedAnimIndex = label.dataset.animInLayer ? parseInt(label.dataset.animInLayer) : null;

          label.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/html', label.innerHTML);

          // Hide all add buttons during drag
          document.querySelectorAll('.timeline-label-add-btn, .section-divider-add-btn').forEach(btn => {
            btn.classList.remove('visible');
          });
        });

        // Dragend - cleanup
        label.addEventListener('dragend', (e) => {
          label.classList.remove('dragging');
          // Remove all drop indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });
          const bottomDivider = document.querySelector('.timeline-bottom-divider');
          const bottomTrack = document.querySelector('.timeline-bottom-track');
          if (bottomDivider) bottomDivider.classList.remove('drag-over-top');
          if (bottomTrack) bottomTrack.classList.remove('drag-over-top');
          draggedElement = null;
          draggedType = null;
          draggedLayerIndex = null;
          draggedAnimIndex = null;
        });

        // Dragover - show drop indicator
        label.addEventListener('dragover', (e) => {
          if (!draggedElement || draggedElement === label) return;

          const targetType = label.dataset.dragType;
          const targetLayerIndex = parseInt(label.dataset.layerIndex);

          // Check if this drop is valid
          let isValidDrop = false;
          let isLastLayerParam = false;
          let isDropOnLayerHeader = false;

          if (draggedType === 'animation' && targetType === 'animation') {
            // Animation can be dropped in any layer
            isValidDrop = true;
          } else if (draggedType === 'animation' && targetType === 'layer') {
            // Allow dropping animations on layer headers (for empty sections or adding to top)
            isValidDrop = true;
            isDropOnLayerHeader = true;
          } else if (draggedType === 'layer' && targetType === 'layer') {
            isValidDrop = true;
          }
          // Note: We don't allow dropping layers on animation rows anymore
          // because the bottom divider provides a clearer drop target for that

          if (!isValidDrop) return;

          e.preventDefault();

          // Calculate if this drop would actually change the position
          const rect = label.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          let dropPosition = e.clientY < midpoint ? 'before' : 'after';
          let wouldChangePosition = false;

          if (isDropOnLayerHeader) {
            // Dropping animation on layer header - always valid unless it's already first in that layer
            if (draggedLayerIndex !== targetLayerIndex) {
              // Moving to a different layer - always valid
              wouldChangePosition = true;
            } else {
              // Same layer - only valid if not already first
              wouldChangePosition = draggedAnimIndex !== 0;
            }
          } else if (isLastLayerParam) {
            const targetAnimInLayer = parseInt(label.dataset.animInLayer);
            const lastAnimIndex = specData.layers[targetLayerIndex].animations.length - 1;
            // Check if dropping on last param row would change position
            if (targetAnimInLayer === lastAnimIndex) {
              let targetIndex = targetLayerIndex + 1;
              if (draggedLayerIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedLayerIndex !== targetIndex;
            }
          } else if (draggedType === 'layer' && targetType === 'layer') {
            // Only very close to the top divider line is valid for layer drops (within 10px)
            const distanceFromTop = e.clientY - rect.top;
            if (distanceFromTop <= 10) {
              let targetIndex = targetLayerIndex;
              if (draggedLayerIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedLayerIndex !== targetIndex;
            }
          } else if (draggedType === 'animation' && targetType === 'animation') {
            // Check if animation drop would change position
            if (draggedLayerIndex !== targetLayerIndex) {
              // Moving to a different layer - always a valid change
              wouldChangePosition = true;
            } else {
              // Moving within same layer - check if position changes
              const targetAnimIndex = parseInt(label.dataset.animInLayer);
              let targetIndex = targetAnimIndex;
              if (dropPosition === 'after') targetIndex++;
              if (draggedAnimIndex < targetIndex) targetIndex--;
              wouldChangePosition = draggedAnimIndex !== targetIndex;
            }
          }

          // Only show indicators if the drop would actually change the position
          if (!wouldChangePosition) return;

          // Clear previous indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });
          const bottomDivider = document.querySelector('.timeline-bottom-divider');
          const bottomTrack = document.querySelector('.timeline-bottom-track');
          if (bottomDivider) bottomDivider.classList.remove('drag-over-top');
          if (bottomTrack) bottomTrack.classList.remove('drag-over-top');

          // For animations dropping on layer headers: show bottom indicator
          if (isDropOnLayerHeader) {
            // Find corresponding track and add indicator to both
            const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
            const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
            const labelIndex = allLabels.indexOf(label);

            label.classList.add('drag-over-bottom');
            if (labelIndex >= 0 && allTracks[labelIndex]) {
              allTracks[labelIndex].classList.add('drag-over-bottom');
            }
          }
          // For layers dropping on last layer parameters: only show bottom indicator
          else if (isLastLayerParam) {
            const targetAnimInLayer = parseInt(label.dataset.animInLayer);
            const lastAnimIndex = specData.layers[targetLayerIndex].animations.length - 1;
            // Only show indicator on the last parameter row, and not on the dragged layer's own parameters
            if (targetAnimInLayer === lastAnimIndex && targetLayerIndex !== draggedLayerIndex) {
              // Find corresponding track and add indicator to both
              const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
              const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
              const labelIndex = allLabels.indexOf(label);

              label.classList.add('drag-over-bottom');
              if (labelIndex >= 0 && allTracks[labelIndex]) {
                allTracks[labelIndex].classList.add('drag-over-bottom');
              }
            }
          }
          // For layers: section headers only respond very close to the divider line at the top
          else if (draggedType === 'layer' && targetType === 'layer') {
            // Only show indicator when hovering very close to the divider line (within 10px of top)
            const rect = label.getBoundingClientRect();
            const distanceFromTop = e.clientY - rect.top;
            if (distanceFromTop <= 10) {
              // Find all labels and tracks
              const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
              const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
              const labelIndex = allLabels.indexOf(label);

              // Show indicator on both label and corresponding track
              label.classList.add('drag-over-top');
              if (labelIndex >= 0 && allTracks[labelIndex]) {
                allTracks[labelIndex].classList.add('drag-over-top');
              }
            }
          } else {
            // For animations, show both top and bottom indicators normally
            const dropPositionDisplay = e.clientY < midpoint ? 'top' : 'bottom';

            // Find corresponding track and add indicator to both
            const allLabels = Array.from(document.querySelectorAll('.timeline-label'));
            const allTracks = Array.from(document.querySelectorAll('.timeline-track'));
            const labelIndex = allLabels.indexOf(label);

            if (dropPositionDisplay === 'top') {
              label.classList.add('drag-over-top');
              if (labelIndex >= 0 && allTracks[labelIndex]) {
                allTracks[labelIndex].classList.add('drag-over-top');
              }
            } else {
              label.classList.add('drag-over-bottom');
              if (labelIndex >= 0 && allTracks[labelIndex]) {
                allTracks[labelIndex].classList.add('drag-over-bottom');
              }
            }
          }

          e.dataTransfer.dropEffect = 'move';
        });

        // Drop - perform the move
        label.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();

          if (!draggedElement || draggedElement === label) return;

          const targetType = label.dataset.dragType;
          const targetLayerIndex = parseInt(label.dataset.layerIndex);
          const targetAnimIndex = label.dataset.animInLayer ? parseInt(label.dataset.animInLayer) : null;

          // Calculate drop position
          const rect = label.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          let dropPosition = e.clientY < midpoint ? 'before' : 'after';

          // Check if dropping layer on last layer's parameter row (to drop at bottom)
          const isLastLayer = targetLayerIndex === specData.layers.length - 1;
          const isLastLayerParam = draggedType === 'layer' && targetType === 'animation' && isLastLayer;

          if (isLastLayerParam) {
            // Dropping on last layer's parameter row = insert after last layer
            const lastAnimInLayer = specData.layers[targetLayerIndex].animations.length - 1;
            if (targetAnimIndex === lastAnimInLayer) {
              performLayerMove(draggedLayerIndex, targetLayerIndex, 'after');
            }
          }
          // For layer drops: only allow drops in top half (before)
          else if (draggedType === 'layer' && targetType === 'layer') {
            if (dropPosition === 'after') {
              // Don't allow drops on bottom half of any section header
              return;
            }
            // Moving a layer
            performLayerMove(draggedLayerIndex, targetLayerIndex, dropPosition);
          }
          // For dropping animations on layer headers (empty sections or add to top)
          else if (draggedType === 'animation' && targetType === 'layer') {
            const sourceLayer = specData.layers[draggedLayerIndex];
            const targetLayer = specData.layers[targetLayerIndex];
            const anim = sourceLayer.animations.splice(draggedAnimIndex, 1)[0];

            // Insert at the beginning of the target layer
            targetLayer.animations.splice(0, 0, anim);
            renderTimeline();
          }
          else if (draggedType === 'animation' && targetType === 'animation') {
            // Moving an animation (within same layer or across layers)
            if (draggedLayerIndex === targetLayerIndex) {
              // Moving within the same layer
              performAnimationMove(draggedLayerIndex, draggedAnimIndex, targetAnimIndex, dropPosition);
            } else {
              // Moving to a different layer
              const sourceLayer = specData.layers[draggedLayerIndex];
              const targetLayer = specData.layers[targetLayerIndex];
              const anim = sourceLayer.animations.splice(draggedAnimIndex, 1)[0];

              let targetIndex = targetAnimIndex;
              if (dropPosition === 'after') targetIndex++;

              targetLayer.animations.splice(targetIndex, 0, anim);
              renderTimeline();
            }
          }

          // Clear indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });
          const bottomDivider = document.querySelector('.timeline-bottom-divider');
          const bottomTrack = document.querySelector('.timeline-bottom-track');
          if (bottomDivider) bottomDivider.classList.remove('drag-over-top');
          if (bottomTrack) bottomTrack.classList.remove('drag-over-top');
        });
      });

      // Set up drag handlers for bottom divider
      const bottomDivider = document.querySelector('.timeline-bottom-divider');
      const bottomTrack = document.querySelector('.timeline-bottom-track');
      if (bottomDivider && bottomTrack) {
        bottomDivider.addEventListener('dragover', (e) => {
          if (!draggedElement || draggedType !== 'layer') return;

          // Check if dragged layer is already the last layer
          const isLastLayer = draggedLayerIndex === specData.layers.length - 1;
          if (isLastLayer) {
            // Don't show indicator if already at the end
            return;
          }

          e.preventDefault();
          e.stopPropagation();

          // Clear previous indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });

          // Show indicator on both bottom elements
          bottomDivider.classList.add('drag-over-top');
          bottomTrack.classList.add('drag-over-top');
          e.dataTransfer.dropEffect = 'move';
        });

        bottomDivider.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();

          if (!draggedElement || draggedType !== 'layer') return;

          // Move layer to end
          performLayerMove(draggedLayerIndex, specData.layers.length - 1, 'after');

          // Clear indicators
          document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
            l.classList.remove('drag-over-top', 'drag-over-bottom');
          });
          bottomDivider.classList.remove('drag-over-top');
          bottomTrack.classList.remove('drag-over-top');
        });

        bottomDivider.addEventListener('dragleave', (e) => {
          bottomDivider.classList.remove('drag-over-top');
          bottomTrack.classList.remove('drag-over-top');
        });
      }

      // Set up + button handlers
      const addButtons = document.querySelectorAll('.timeline-label-add-btn');
      addButtons.forEach(btn => {
        // Prevent drag when clicking the + button
        btn.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();

          // Get the parent label to find which layer and position
          const label = btn.closest('.timeline-label');
          if (!label) return;

          const layerIndex = parseInt(label.dataset.layerIndex);
          const layer = specData.layers[layerIndex];
          if (!layer) return;

          // Determine insert position
          let insertIndex;
          if (label.classList.contains('layer-header')) {
            // If clicking on header, add to end of layer
            insertIndex = layer.animations.length;
          } else {
            // If clicking on animation row, add after it
            const animInLayer = parseInt(label.dataset.animInLayer);
            insertIndex = animInLayer + 1;
          }

          // Create new animation with default values
          const newAnimation = {
            property: "Add parameter",
            description: "Add description",
            timing: {
              delay: 0,
              duration: 300
            },
            easing: {
              type: "-",
              cubicBezier: ""
            },
            values: {
              formatted: {
                startValue: "-",
                endValue: "-"
              }
            }
          };

          // Insert the new animation
          layer.animations.splice(insertIndex, 0, newAnimation);

          // Re-render timeline
          renderTimeline();

          // Calculate the global animation index for the newly added animation
          let globalAnimIndex = 0;
          for (let i = 0; i < layerIndex; i++) {
            globalAnimIndex += specData.layers[i].animations.length;
          }
          globalAnimIndex += insertIndex;

          // Show the info box for the newly added animation
          setTimeout(() => {
            showAnimationDetails(globalAnimIndex);

            // Add selected class to the new bar and label
            const newBar = document.querySelector(`.timeline-bar[data-anim-index="${globalAnimIndex}"]`);
            const newLabel = document.querySelector(`.timeline-label.indented[data-anim-index="${globalAnimIndex}"]`);
            if (newBar) newBar.classList.add('selected');
            if (newLabel) newLabel.classList.add('selected');
          }, 0);
        });
      });

      // Set up section divider button handlers
      const sectionDividerButtons = document.querySelectorAll('.section-divider-add-btn');
      sectionDividerButtons.forEach(btn => {
        btn.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();

          // Determine insert position
          let insertIndex;
          const parentLabel = btn.closest('.timeline-label');
          const isBottomDivider = btn.closest('.timeline-bottom-divider');

          if (isBottomDivider) {
            // Bottom divider - add to end
            insertIndex = specData.layers.length;
          } else if (parentLabel) {
            // Section header button - insert before this layer
            const layerIndex = parseInt(parentLabel.dataset.layerIndex);
            insertIndex = layerIndex;
          } else {
            return;
          }

          // Create new layer with one default animation
          const newLayer = {
            layerName: "New section",
            animations: [
              {
                property: "Add parameter",
                description: "Add description",
                timing: {
                  delay: 0,
                  duration: 300
                },
                easing: {
                  type: "-",
                  cubicBezier: ""
                },
                values: {
                  formatted: {
                    startValue: "-",
                    endValue: "-"
                  }
                }
              }
            ]
          };

          // Insert the new layer
          specData.layers.splice(insertIndex, 0, newLayer);

          // Re-render timeline
          renderTimeline();

          // Calculate the global animation index for the newly added parameter
          let globalAnimIndex = 0;
          for (let i = 0; i < insertIndex; i++) {
            globalAnimIndex += specData.layers[i].animations.length;
          }
          // The new parameter is at index 0 in the new layer

          // Show the info box for the newly added animation
          setTimeout(() => {
            showAnimationDetails(globalAnimIndex);

            // Add selected class to the new bar and label
            const newBar = document.querySelector(`.timeline-bar[data-anim-index="${globalAnimIndex}"]`);
            const newLabel = document.querySelector(`.timeline-label.indented[data-anim-index="${globalAnimIndex}"]`);
            if (newBar) newBar.classList.add('selected');
            if (newLabel) newLabel.classList.add('selected');
          }, 0);
        });
      });
    }

    // Setup hover zones for add buttons
    function setupAddButtonHoverZones() {
      const labelsColumn = document.querySelector('.timeline-labels-column');
      const labels = document.querySelectorAll('.timeline-label');
      const bottomDivider = document.querySelector('.timeline-bottom-divider');

      if (!labelsColumn) return;

      labelsColumn.addEventListener('mousemove', (e) => {
        const columnRect = labelsColumn.getBoundingClientRect();
        const mouseY = e.clientY;

        // Find all buttons and their distances
        let closestButton = null;
        let closestDistance = Infinity;

        // Check each label's divider line
        labels.forEach(label => {
          const btn = label.querySelector('.timeline-label-add-btn');
          const sectionBtn = label.querySelector('.section-divider-add-btn');
          const rect = label.getBoundingClientRect();
          const halfCellHeight = rect.height / 2;

          // Check regular divider line (at bottom of cell)
          if (btn) {
            const dividerY = rect.bottom;
            const distanceFromDivider = Math.abs(mouseY - dividerY);
            if (distanceFromDivider <= halfCellHeight) {
              if (distanceFromDivider < closestDistance) {
                closestDistance = distanceFromDivider;
                closestButton = btn;
              }
            }
          }

          // Check section divider line (at top of cell, for elements with has-divider)
          if (sectionBtn) {
            const sectionDividerY = rect.top; // Border-top is at element's top edge
            const distanceFromSectionDivider = Math.abs(mouseY - sectionDividerY);
            // Use a larger hover zone for section dividers (about 15px total margin-top / 2)
            if (distanceFromSectionDivider <= 15) {
              if (distanceFromSectionDivider < closestDistance) {
                closestDistance = distanceFromSectionDivider;
                closestButton = sectionBtn;
              }
            }
          }
        });

        // Check bottom divider
        if (bottomDivider) {
          const bottomBtn = bottomDivider.querySelector('.section-divider-add-btn');
          if (bottomBtn) {
            const rect = bottomDivider.getBoundingClientRect();
            const dividerY = rect.top; // Border-top is at element's top edge
            const distanceFromDivider = Math.abs(mouseY - dividerY);
            if (distanceFromDivider <= 15) {
              if (distanceFromDivider < closestDistance) {
                closestDistance = distanceFromDivider;
                closestButton = bottomBtn;
              }
            }
          }
        }

        // Hide all buttons first
        labels.forEach(label => {
          const btn = label.querySelector('.timeline-label-add-btn');
          const sectionBtn = label.querySelector('.section-divider-add-btn');
          if (btn) btn.classList.remove('visible');
          if (sectionBtn) sectionBtn.classList.remove('visible');
        });
        if (bottomDivider) {
          const bottomBtn = bottomDivider.querySelector('.section-divider-add-btn');
          if (bottomBtn) bottomBtn.classList.remove('visible');
        }

        // Show only the closest button
        if (closestButton) {
          closestButton.classList.add('visible');
        }
      });

      labelsColumn.addEventListener('mouseleave', () => {
        // Hide all buttons when mouse leaves the column
        labels.forEach(label => {
          const btn = label.querySelector('.timeline-label-add-btn');
          const sectionBtn = label.querySelector('.section-divider-add-btn');
          if (btn) btn.classList.remove('visible');
          if (sectionBtn) sectionBtn.classList.remove('visible');
        });

        // Hide bottom divider button
        if (bottomDivider) {
          const bottomBtn = bottomDivider.querySelector('.section-divider-add-btn');
          if (bottomBtn) bottomBtn.classList.remove('visible');
        }
      });
    }

    // Setup resize handles for timeline bars
    function setupResizeHandles() {
      const handles = document.querySelectorAll('.timeline-bar-resize-handle');

      handles.forEach(handle => {
        handle.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          e.preventDefault();

          const bar = handle.closest('.timeline-bar');
          const animIndex = parseInt(bar.dataset.animIndex);
          const handleType = handle.dataset.handle; // 'left' or 'right'
          const isSpring = bar.dataset.isSpring === 'true';

          // Find the animation in specData
          let currentAnimIndex = 0;
          let targetLayer = null;
          let targetAnim = null;
          let layerIndex = -1;
          let animInLayerIndex = -1;

          for (let i = 0; i < specData.layers.length; i++) {
            const layer = specData.layers[i];
            for (let j = 0; j < layer.animations.length; j++) {
              if (currentAnimIndex === animIndex) {
                targetLayer = layer;
                targetAnim = layer.animations[j];
                layerIndex = i;
                animInLayerIndex = j;
                break;
              }
              currentAnimIndex++;
            }
            if (targetAnim) break;
          }

          if (!targetAnim) return;

          const startDelay = targetAnim.timing.delay;
          const startDuration = targetAnim.timing.duration;
          const startX = e.clientX;
          const timelineGrid = document.querySelector('.timeline-grid-lines').parentElement;
          const gridRect = timelineGrid.getBoundingClientRect();
          const specDuration = specData.workArea.duration;
          const currentViewDuration = viewDuration || specDuration;

          // Add dragging class to maintain hover state
          bar.classList.add('dragging-resize');

          // Function to snap to 25ms increments
          function snapToIncrement(value) {
            return Math.round(value / 25) * 25;
          }

          function onMouseMove(moveEvent) {
            const deltaX = moveEvent.clientX - startX;
            const deltaTime = (deltaX / gridRect.width) * currentViewDuration;

            let newDelay, newDuration;

            if (handleType === 'left') {
              // Adjust delay (start time)
              newDelay = snapToIncrement(startDelay + deltaTime);
              newDelay = Math.max(0, newDelay); // Can't go below 0

              // Adjust duration to compensate (keep end time the same)
              newDuration = startDelay + startDuration - newDelay;
              newDuration = Math.max(25, newDuration); // Minimum 25ms duration

              // Update animation data
              targetAnim.timing.delay = newDelay;
              targetAnim.timing.duration = newDuration;
            } else {
              // Adjust duration (end time)
              newDelay = targetAnim.timing.delay;
              newDuration = snapToIncrement(startDuration + deltaTime);
              newDuration = Math.max(25, newDuration); // Minimum 25ms duration

              // Update animation data
              targetAnim.timing.duration = newDuration;
            }

            // Update bar position and width directly without full re-render
            const startPercent = (newDelay / currentViewDuration) * 100;
            const widthPercent = (newDuration / currentViewDuration) * 100;
            bar.style.left = `${startPercent}%`;
            bar.style.width = `${widthPercent}%`;

            // Update info box if this animation is selected
            if (selectedAnimation === animIndex) {
              showAnimationDetails(animIndex);
            }
          }

          function onMouseUp() {
            // Remove dragging class
            bar.classList.remove('dragging-resize');

            // Store whether this animation was selected before re-render
            const wasSelected = selectedAnimation === animIndex;

            // Do a full re-render to ensure everything is consistent
            renderTimeline();

            // Restore info box if it was showing (renderTimeline clears the detail panel)
            if (wasSelected) {
              showAnimationDetails(animIndex);
            }

            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          }

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
      });
    }

    // Setup bar dragging for moving timeline position or reordering
    function setupBarDragging() {
      const bars = document.querySelectorAll('.timeline-bar');

      bars.forEach(bar => {
        bar.addEventListener('mousedown', (e) => {
          // Don't interfere with resize handles
          if (e.target.classList.contains('timeline-bar-resize-handle')) return;

          const animIndex = parseInt(bar.dataset.animIndex);
          const startX = e.clientX;
          const startY = e.clientY;
          const threshold = 5; // pixels to move before determining direction
          let dragDirection = null; // 'horizontal', 'vertical', or null
          let isDragging = false;

          // Find the animation in specData
          let currentAnimIndex = 0;
          let targetAnim = null;
          let layerIndex = -1;
          let animInLayerIndex = -1;

          for (let i = 0; i < specData.layers.length; i++) {
            const layer = specData.layers[i];
            for (let j = 0; j < layer.animations.length; j++) {
              if (currentAnimIndex === animIndex) {
                targetAnim = layer.animations[j];
                layerIndex = i;
                animInLayerIndex = j;
                break;
              }
              currentAnimIndex++;
            }
            if (targetAnim) break;
          }

          if (!targetAnim) return;

          const startDelay = targetAnim.timing.delay;
          const timelineGrid = document.querySelector('.timeline-grid-lines').parentElement;
          const gridRect = timelineGrid.getBoundingClientRect();
          const specDuration = specData.workArea.duration;
          const currentViewDuration = viewDuration || specDuration;

          function snapToIncrement(value) {
            return Math.round(value / 25) * 25;
          }

          function onMouseMove(moveEvent) {
            const deltaX = moveEvent.clientX - startX;
            const deltaY = moveEvent.clientY - startY;

            // Determine drag direction if not yet determined
            if (!dragDirection && (Math.abs(deltaX) > threshold || Math.abs(deltaY) > threshold)) {
              moveEvent.preventDefault(); // Prevent default behavior once we start dragging

              if (Math.abs(deltaX) > Math.abs(deltaY)) {
                dragDirection = 'horizontal';
                bar.classList.add('dragging-resize');
              } else {
                dragDirection = 'vertical';
                // Start vertical drag - add visual feedback
                bar.classList.add('dragging-vertical');
                const label = document.querySelector(`.timeline-label.indented[data-anim-index="${animIndex}"]`);
                if (label) {
                  // Programmatically trigger dragstart on the label
                  label.classList.add('dragging');
                  document.querySelectorAll('.timeline-label-add-btn, .section-divider-add-btn').forEach(btn => {
                    btn.classList.remove('visible');
                  });
                }
              }
              isDragging = true;
            }

            if (!isDragging) return;

            if (dragDirection === 'horizontal') {
              // Horizontal drag - move the bar's position in time
              const deltaTime = (deltaX / gridRect.width) * currentViewDuration;
              let newDelay = snapToIncrement(startDelay + deltaTime);
              newDelay = Math.max(0, newDelay);

              // Update animation data
              targetAnim.timing.delay = newDelay;

              // Update bar position directly
              const startPercent = (newDelay / currentViewDuration) * 100;
              bar.style.left = `${startPercent}%`;

              // Update info box if selected
              if (selectedAnimation === animIndex) {
                showAnimationDetails(animIndex);
              }
            } else if (dragDirection === 'vertical') {
              // Vertical drag - show drop indicators
              const animLabels = document.querySelectorAll('.timeline-label.indented');
              const layerHeaders = document.querySelectorAll('.timeline-label.layer-header');
              let closestElement = null;
              let closestDistance = Infinity;
              let isLayerHeader = false;

              // Check animation labels
              animLabels.forEach(label => {
                const rect = label.getBoundingClientRect();
                const distance = Math.abs(rect.top + rect.height / 2 - moveEvent.clientY);
                if (distance < closestDistance) {
                  closestDistance = distance;
                  closestElement = label;
                  isLayerHeader = false;
                }
              });

              // Also check layer headers (for empty sections)
              layerHeaders.forEach(header => {
                const rect = header.getBoundingClientRect();
                const distance = Math.abs(rect.top + rect.height / 2 - moveEvent.clientY);
                if (distance < closestDistance) {
                  closestDistance = distance;
                  closestElement = header;
                  isLayerHeader = true;
                }
              });

              // Remove all drop indicators first
              document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
                l.classList.remove('drag-over-top', 'drag-over-bottom');
              });

              // Show drop indicator on closest element only (extends across full timeline)
              if (closestElement) {
                if (isLayerHeader) {
                  // For layer headers, always show bottom indicator (add to section)
                  const headerLayerIndex = parseInt(closestElement.dataset.layerIndex);
                  if (headerLayerIndex !== layerIndex) {
                    // Only show if dropping into a different section
                    closestElement.classList.add('drag-over-bottom');
                  }
                } else if (closestElement.dataset.animIndex !== String(animIndex)) {
                  // For animation labels, show top/bottom based on position
                  const rect = closestElement.getBoundingClientRect();
                  const midpoint = rect.top + rect.height / 2;

                  if (moveEvent.clientY < midpoint) {
                    closestElement.classList.add('drag-over-top');
                  } else {
                    closestElement.classList.add('drag-over-bottom');
                  }
                }
              }
            }
          }

          function onMouseUp(upEvent) {
            // If we dragged, prevent the click event from firing
            if (isDragging) {
              const preventClick = (e) => {
                e.stopPropagation();
                e.preventDefault();
                bar.removeEventListener('click', preventClick, true);
              };
              bar.addEventListener('click', preventClick, true);
            }

            if (dragDirection === 'horizontal') {
              bar.classList.remove('dragging-resize');

              // Store selection state
              const wasSelected = selectedAnimation === animIndex;

              // Re-render to finalize
              renderTimeline();

              // Restore info box if needed
              if (wasSelected) {
                showAnimationDetails(animIndex);
              }
            } else if (dragDirection === 'vertical') {
              // Complete the drop
              const animLabels = document.querySelectorAll('.timeline-label.indented');
              const layerHeaders = document.querySelectorAll('.timeline-label.layer-header');
              let targetElement = null;
              let dropPosition = null;
              let isLayerHeader = false;

              // Check animation labels
              animLabels.forEach(label => {
                if (label.classList.contains('drag-over-top') || label.classList.contains('drag-over-bottom')) {
                  targetElement = label;
                  dropPosition = label.classList.contains('drag-over-top') ? 'before' : 'after';
                  isLayerHeader = false;
                }
              });

              // Check layer headers
              layerHeaders.forEach(header => {
                if (header.classList.contains('drag-over-bottom')) {
                  targetElement = header;
                  isLayerHeader = true;
                }
              });

              if (targetElement) {
                if (isLayerHeader) {
                  // Dropping on a layer header - add to beginning of that section
                  const targetLayerIndex = parseInt(targetElement.dataset.layerIndex);
                  const sourceLayer = specData.layers[layerIndex];
                  const targetLayer = specData.layers[targetLayerIndex];
                  const anim = sourceLayer.animations.splice(animInLayerIndex, 1)[0];

                  // Insert at beginning of target layer
                  targetLayer.animations.splice(0, 0, anim);
                  renderTimeline();
                } else if (targetElement.dataset.animIndex !== String(animIndex)) {
                  // Dropping on an animation label
                  const targetAnimIndex = parseInt(targetElement.dataset.animIndex);
                  const targetLayerIndex = parseInt(targetElement.dataset.layerIndex);
                  const targetAnimInLayerIndex = parseInt(targetElement.dataset.animInLayer);

                  // Perform the move
                  if (layerIndex === targetLayerIndex) {
                    // Moving within the same layer
                    let targetIndex = targetAnimInLayerIndex;
                    if (dropPosition === 'after') targetIndex++;
                    if (animInLayerIndex < targetIndex) targetIndex--;

                    if (animInLayerIndex !== targetIndex) {
                      const layer = specData.layers[layerIndex];
                      const anim = layer.animations.splice(animInLayerIndex, 1)[0];
                      layer.animations.splice(targetIndex, 0, anim);
                      renderTimeline();
                    }
                  } else {
                    // Moving to a different layer
                    const sourceLayer = specData.layers[layerIndex];
                    const targetLayer = specData.layers[targetLayerIndex];
                    const anim = sourceLayer.animations.splice(animInLayerIndex, 1)[0];

                    let targetIndex = targetAnimInLayerIndex;
                    if (dropPosition === 'after') targetIndex++;

                    targetLayer.animations.splice(targetIndex, 0, anim);
                    renderTimeline();
                  }
                }
              }

              // Cleanup
              bar.classList.remove('dragging-vertical');
              const label = document.querySelector(`.timeline-label.indented[data-anim-index="${animIndex}"]`);
              if (label) label.classList.remove('dragging');

              document.querySelectorAll('.timeline-label, .timeline-track').forEach(l => {
                l.classList.remove('drag-over-top', 'drag-over-bottom');
              });
            }

            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
          }

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
      });
    }

    // Perform layer move
    function performLayerMove(fromIndex, toIndex, position) {
      // Calculate the actual target index
      let targetIndex = toIndex;
      if (position === 'after') targetIndex++;
      if (fromIndex < targetIndex) targetIndex--;

      if (fromIndex === targetIndex) return;

      // Remove from old position
      const layer = specData.layers.splice(fromIndex, 1)[0];

      // Insert at new position
      specData.layers.splice(targetIndex, 0, layer);

      // Re-render
      renderTimeline();

      // Maintain selection if needed
      if (selectedAnimation !== null) {
        // Recalculate selected animation index
        setTimeout(() => {
          updatePlayhead();
        }, 0);
      }
    }

    // Perform animation move within layer
    function performAnimationMove(layerIndex, fromAnimIndex, toAnimIndex, position) {
      // Calculate the actual target index
      let targetIndex = toAnimIndex;
      if (position === 'after') targetIndex++;
      if (fromAnimIndex < targetIndex) targetIndex--;

      if (fromAnimIndex === targetIndex) return;

      const layer = specData.layers[layerIndex];

      // Remove from old position
      const anim = layer.animations.splice(fromAnimIndex, 1)[0];

      // Insert at new position
      layer.animations.splice(targetIndex, 0, anim);

      // Re-render
      renderTimeline();

      // Maintain selection if needed
      if (selectedAnimation !== null) {
        setTimeout(() => {
          updatePlayhead();
        }, 0);
      }
    }

    // Setup playhead dragging
    let playheadListenersAdded = false;
    function setupPlayheadDragging() {
      const playhead = document.getElementById('playhead');
      if (!playhead) return;

      const timelineContainer = document.querySelector('.timeline-container');
      const timelineContent = document.querySelector('.timeline-content-column');

      function onMouseDown(e) {
        isDraggingPlayhead = true;
        video.pause();
        const playPauseBtn = document.getElementById('playPauseBtn');
        if (playPauseBtn) playPauseBtn.innerHTML = '<span class="icon">‚ñ∂</span>';
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        onMouseMove(e);
      }

      function onMouseMove(e) {
        const containerRect = timelineContainer.getBoundingClientRect();
        const contentRect = timelineContent.getBoundingClientRect();
        let x = e.clientX - contentRect.left;

        // Calculate percentage of full width (not content width)
        let percentage = x / contentRect.width;

        // Clamp percentage between 0 and 1 (allow full range)
        percentage = Math.max(0, Math.min(percentage, 1.0));

        // Calculate pixel position relative to viewport
        const leftPosition = contentRect.left + (percentage * contentRect.width);
        playhead.style.left = `${leftPosition}px`;
        playhead.style.top = `${containerRect.top + 44}px`;
        playhead.style.bottom = `${window.innerHeight - containerRect.bottom}px`;

        if (video.duration && specData) {
          // Convert drag percentage to spec time (use current view duration for zoom)
          const currentViewDuration = viewDuration || specData.workArea.duration;
          const specTimeMs = (percentage * currentViewDuration);

          // Store this position for when we release
          lastDraggedSpecTimeMs = specTimeMs;

          // Calculate target video time - direct mapping without offset
          // (offset is only for display during playback, not for seeking)
          const videoProgress = specTimeMs / specData.workArea.duration;
          const targetVideoTime = videoProgress * video.duration;
          lastDraggedVideoTime = Math.min(targetVideoTime, video.duration);

          // Use throttled seek to prevent multiple competing seeks
          scheduleVideoSeek(lastDraggedVideoTime);

          // Display the exact spec time we're dragging to
          const playheadTimeDisplay = document.getElementById('playheadTimeDisplay');
          if (playheadTimeDisplay) {
            playheadTimeDisplay.textContent = `${specTimeMs.toFixed(0)}ms`;
          }
        }
      }

      function onMouseUp() {
        isDraggingPlayhead = false;
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);

        // Set flag IMMEDIATELY to freeze display updates (before RAF executes)
        justFinishedDragging = true;

        // Schedule final seek in its own RAF to ensure it executes AFTER any pending drag RAF
        requestAnimationFrame(() => {
          // Now set the final video time - this will be the last seek
          if (lastDraggedVideoTime !== null) {
            video.currentTime = lastDraggedVideoTime;
          }

          // Clear the flag after everything settles
          setTimeout(() => {
            justFinishedDragging = false;
            lastDraggedSpecTimeMs = null;
            lastDraggedVideoTime = null;
          }, 100);
        });
      }

      playhead.addEventListener('mousedown', onMouseDown);

      // Only add window/container listeners once to avoid duplicates
      if (!playheadListenersAdded) {
        playheadListenersAdded = true;

        // Update playhead position on window resize and scroll
        window.addEventListener('resize', () => {
          if (!isDraggingPlayhead) {
            updatePlayhead();
          }
        });

        // Update playhead position on scroll
        window.addEventListener('scroll', () => {
          if (!isDraggingPlayhead) {
            updatePlayhead();
          }
        });

        // Also update on timeline container scroll
        const timelineContainer = document.querySelector('.timeline-container');
        if (timelineContainer) {
          timelineContainer.addEventListener('scroll', () => {
            if (!isDraggingPlayhead) {
              updatePlayhead();
            }
          });
        }
      }
    }

    // Toggle color picker panel
    function toggleColorPicker(event, animIndex) {
      event.stopPropagation();
      const panel = document.getElementById('colorPickerPanel');
      const dot = document.getElementById('colorPickerDot');

      if (panel.classList.contains('visible')) {
        panel.classList.remove('visible');
      } else {
        panel.classList.add('visible');

        // Position panel above the dot
        const dotRect = dot.getBoundingClientRect();
        panel.style.left = '-60px';
        panel.style.bottom = 'calc(100% + 12px)';
      }
    }

    // Change animation color
    function changeAnimationColor(animIndex, color) {
      // Find the animation in specData
      let currentIndex = 0;
      let targetAnim = null;

      for (let i = 0; i < specData.layers.length; i++) {
        const layer = specData.layers[i];
        for (let j = 0; j < layer.animations.length; j++) {
          if (currentIndex === animIndex) {
            targetAnim = layer.animations[j];
            break;
          }
          currentIndex++;
        }
        if (targetAnim) break;
      }

      if (targetAnim) {
        targetAnim.customColor = color;
        renderTimeline();

        // Re-show the info box with updated color
        setTimeout(() => {
          showAnimationDetails(animIndex);
        }, 0);
      }
    }

    // Close color picker when clicking outside
    document.addEventListener('click', (e) => {
      const panel = document.getElementById('colorPickerPanel');
      const dot = document.getElementById('colorPickerDot');
      if (panel && !panel.contains(e.target) && e.target !== dot) {
        panel.classList.remove('visible');
      }
    });

    // Show animation details
    function showAnimationDetails(animIndex) {
      // Store the selected animation index
      selectedAnimation = animIndex;

      let currentIndex = 0;
      let anim = null;
      let layer = null;
      let layerIndex = -1;

      for (let lIdx = 0; lIdx < specData.layers.length; lIdx++) {
        const l = specData.layers[lIdx];
        for (const a of l.animations) {
          if (currentIndex === animIndex) {
            anim = a;
            layer = l;
            layerIndex = lIdx;
            break;
          }
          currentIndex++;
        }
        if (anim) break;
      }

      if (!anim) return;

      const detailPanel = document.getElementById('detailPanel');
      const description = getAnimationDescription(anim.property, anim.values, anim.fitToShape, anim.description);

      // Get the color for this animation type (use custom color if set)
      const colorClass = getPropertyColorClass(anim.property);
      const defaultBarColor = getPropertyColor(colorClass);
      const barColor = anim.customColor || defaultBarColor;
      const brightColor = brightenColor(barColor);

      // Define available colors for picker (sorted cool to warm)
      const colorOptions = [
        '#045c7d', // blue (coolest)
        '#045c45', // teal
        '#4c7a4c', // green
        '#5a1778', // purple
        '#a82968', // pink
        '#a82929', // red
        '#ae4715', // orange
        '#4a4a4a'  // dark grey
      ];

      let html = `<div class="detail-panel" style="border-left-color: ${brightColor};">`;
      html += `<div class="detail-panel-header">`;
      html += `<div class="detail-panel-title">`;
      html += `<div class="color-picker-dot" id="colorPickerDot" style="background: ${brightColor};" onclick="toggleColorPicker(event, ${animIndex})"></div>`;
      html += `<span>${layer.layerName} ‚Ä∫ ${anim.property}</span>`;

      // Color picker panel
      html += `<div class="color-picker-panel" id="colorPickerPanel">`;
      html += `<div class="color-picker-grid">`;
      colorOptions.forEach(color => {
        const selected = color === barColor ? 'selected' : '';
        html += `<div class="color-option ${selected}" style="background: ${color};" onclick="changeAnimationColor(${animIndex}, '${color}')"></div>`;
      });
      html += `</div></div>`;
      html += `</div>`;

      if (isEditMode) {
        html += `<div class="detail-panel-actions">`;
        html += `<button class="detail-panel-action-btn delete" onclick="deleteAnimation(${animIndex})"><span style="font-size: 11px; position: relative; top: -1px; margin-right: -2px;">üóëÔ∏è</span>&nbsp; Delete</button>`;
        html += `<button class="detail-panel-close" onclick="document.getElementById('detailPanel').innerHTML=''; selectedAnimation = null; document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected')); document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected')); requestAnimationFrame(() => updatePlayhead());">&times;</button>`;
        html += `</div>`;
      } else {
        html += `<button class="detail-panel-close" onclick="document.getElementById('detailPanel').innerHTML=''; selectedAnimation = null; document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected')); document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected')); requestAnimationFrame(() => updatePlayhead());">&times;</button>`;
      }

      html += `</div>`;

      // Description - full width above other fields (no label, just as subheader)
      html += `
        <div class="detail-description">${description}</div>
      `;

      html += `<div class="detail-grid">`;

      // Handle Fit to Shape animations differently
      if (anim.isFitToShape && anim.fitToShape) {
        html += `
          <div class="detail-item">
            <div class="detail-label">Parent Layer</div>
            <div class="detail-value">${anim.fitToShape.containerLayerName}</div>
          </div>
          <div class="detail-item">
            <div class="detail-label">Alignment</div>
            <div class="detail-value">${getAlignmentText(anim.fitToShape.alignment)}</div>
          </div>
          <div class="detail-item">
            <div class="detail-label">Scale To</div>
            <div class="detail-value">${getScaleToText(anim.fitToShape.scaleTo)}</div>
          </div>
        `;
      } else {
        // Normal animation details
        // Delay
        html += `
          <div class="detail-item">
            <div class="detail-label">Delay</div>
            <div class="detail-value">${anim.timing.delay}ms</div>
          </div>
        `;

        // Duration
        const durationValue = anim.easing.type === 'spring' ? '-' : `${anim.timing.duration}ms`;
        html += `
          <div class="detail-item">
            <div class="detail-label">Duration</div>
            <div class="detail-value">${durationValue}</div>
          </div>
        `;
      }

      // Easing (skip for Fit to Shape since it doesn't have meaningful easing)
      if (!anim.isFitToShape && anim.easing.type === 'spring') {
        const spring = anim.easing.spring;
        const presetSprings = ['Standard Spring', 'Slow Spring', 'Fast Spring', 'Slow Bounce Spring', 'Medium Bounce Spring', 'Fast Bounce Spring'];
        const springLinks = {
          'Standard Spring': 'https://air.bb/standard-spring',
          'Slow Spring': 'https://air.bb/slow-spring',
          'Fast Spring': 'https://air.bb/fast-spring',
          'Slow Bounce Spring': 'https://air.bb/slow-bounce-spring',
          'Medium Bounce Spring': 'https://air.bb/medium-bounce-spring',
          'Fast Bounce Spring': 'https://air.bb/fast-bounce-spring'
        };
        const isPreset = presetSprings.includes(spring.preset);

        if (isPreset) {
          // Just show the preset name for standard presets with link
          const link = springLinks[spring.preset];
          html += `
            <div class="detail-item">
              <div class="detail-label">Easing</div>
              <div class="detail-value"><a href="${link}" target="_blank" rel="noopener noreferrer" class="spring-link">${spring.preset}</a></div>
            </div>
          `;
        } else {
          // Show custom spring values
          html += `
            <div class="detail-item">
              <div class="detail-label">Easing</div>
              <div class="spring-params"><strong>Stiffness:</strong> ${spring.custom.stiffness}
<strong>Damping:</strong> ${spring.custom.damping}
<strong>Damping Ratio:</strong> ${spring.custom.dampingRatio}
<strong>Mass:</strong> ${spring.custom.mass}</div>
            </div>
          `;
        }
      } else if (!anim.isFitToShape && anim.easing.type === 'cubic-bezier') {
        html += `
          <div class="detail-item">
            <div class="detail-label">Easing</div>
            <div class="bezier-curve">${anim.easing.cubicBezier}</div>
          </div>
        `;
      } else if (!anim.isFitToShape) {
        html += `
          <div class="detail-item">
            <div class="detail-label">Easing</div>
            <div class="detail-value">${anim.easing.type}</div>
          </div>
        `;
      }

      // Values (skip for Fit to Shape)
      if (!anim.isFitToShape && anim.values && anim.values.formatted) {
        html += `
          <div class="detail-item">
            <div class="detail-label">Start Value</div>
            <div class="detail-value">${formatDecimalValue(anim.values.formatted.startValue)}</div>
          </div>
          <div class="detail-item">
            <div class="detail-label">End Value</div>
            <div class="detail-value">${formatDecimalValue(anim.values.formatted.endValue)}</div>
          </div>
        `;
      }

      html += `</div></div>`;
      detailPanel.innerHTML = html;

      // Update playhead position after info box is shown
      requestAnimationFrame(() => {
        updatePlayhead();

        // Smart scroll: ensure the selected row isn't hidden by the detail panel
        const timelineContainer = document.querySelector('.timeline-container');
        const selectedBar = document.querySelector('.timeline-bar.selected');

        if (timelineContainer && selectedBar && detailPanel) {
          const containerRect = timelineContainer.getBoundingClientRect();
          const barRect = selectedBar.getBoundingClientRect();
          const panelRect = detailPanel.getBoundingClientRect();

          // Calculate the bottom edge of visible area (above the detail panel)
          const visibleBottom = panelRect.top - 20; // 20px margin

          // If the selected bar is below the visible area or will be covered by the panel
          if (barRect.bottom > visibleBottom) {
            // Calculate how much to scroll
            const scrollAmount = barRect.bottom - visibleBottom;
            timelineContainer.scrollTop += scrollAmount;
          }
        }
      });
    }

    // Move entire layer up in the timeline
    function moveLayerUp(layerIndex) {
      if (layerIndex === 0) return; // Already at top

      // Swap layers
      const temp = specData.layers[layerIndex];
      specData.layers[layerIndex] = specData.layers[layerIndex - 1];
      specData.layers[layerIndex - 1] = temp;

      // Re-render timeline
      renderTimeline();

      // If an animation was selected, update the selection
      if (selectedAnimation !== null) {
        // Calculate new animation index after the swap
        let animsBefore = 0;
        for (let i = 0; i < layerIndex - 1; i++) {
          animsBefore += specData.layers[i].animations.length;
        }

        // Find which animation in the layer was selected
        let currentIndex = 0;
        let animIndexInLayer = -1;
        for (let lIdx = 0; lIdx < specData.layers.length; lIdx++) {
          const layer = specData.layers[lIdx];
          for (let aIdx = 0; aIdx < layer.animations.length; aIdx++) {
            if (currentIndex === selectedAnimation) {
              if (lIdx === layerIndex) {
                animIndexInLayer = aIdx;
              }
            }
            currentIndex++;
          }
        }

        if (animIndexInLayer !== -1) {
          const newAnimIndex = animsBefore + animIndexInLayer;
          setTimeout(() => {
            showAnimationDetails(newAnimIndex);
            const bar = document.querySelector(`.timeline-bar[data-anim-index="${newAnimIndex}"]`);
            const label = document.querySelector(`.timeline-label.indented[data-anim-index="${newAnimIndex}"]`);
            if (bar) bar.classList.add('selected');
            if (label) label.classList.add('selected');
          }, 0);
        }
      }
    }

    // Move entire layer down in the timeline
    function moveLayerDown(layerIndex) {
      if (layerIndex === specData.layers.length - 1) return; // Already at bottom

      // Swap layers
      const temp = specData.layers[layerIndex];
      specData.layers[layerIndex] = specData.layers[layerIndex + 1];
      specData.layers[layerIndex + 1] = temp;

      // Re-render timeline
      renderTimeline();

      // If an animation was selected, update the selection
      if (selectedAnimation !== null) {
        // Calculate new animation index after the swap
        let animsBefore = 0;
        for (let i = 0; i < layerIndex; i++) {
          animsBefore += specData.layers[i].animations.length;
        }

        // Find which animation in the layer was selected
        let currentIndex = 0;
        let animIndexInLayer = -1;
        for (let lIdx = 0; lIdx < specData.layers.length; lIdx++) {
          const layer = specData.layers[lIdx];
          for (let aIdx = 0; aIdx < layer.animations.length; aIdx++) {
            if (currentIndex === selectedAnimation) {
              if (lIdx === layerIndex) {
                animIndexInLayer = aIdx;
              }
            }
            currentIndex++;
          }
        }

        if (animIndexInLayer !== -1) {
          const newAnimIndex = animsBefore + specData.layers[layerIndex + 1].animations.length + animIndexInLayer;
          setTimeout(() => {
            showAnimationDetails(newAnimIndex);
            const bar = document.querySelector(`.timeline-bar[data-anim-index="${newAnimIndex}"]`);
            const label = document.querySelector(`.timeline-label.indented[data-anim-index="${newAnimIndex}"]`);
            if (bar) bar.classList.add('selected');
            if (label) label.classList.add('selected');
          }, 0);
        }
      }
    }

    // Move individual animation up within its layer
    function moveAnimationUp(layerIndex, animIndexInLayer) {
      if (animIndexInLayer === 0) return; // Already at top of layer

      const layer = specData.layers[layerIndex];

      // Swap animations within the layer
      const temp = layer.animations[animIndexInLayer];
      layer.animations[animIndexInLayer] = layer.animations[animIndexInLayer - 1];
      layer.animations[animIndexInLayer - 1] = temp;

      // Re-render timeline
      renderTimeline();

      // Update selection if this animation was selected
      if (selectedAnimation !== null) {
        // Calculate the new global animation index
        let animsBefore = 0;
        for (let i = 0; i < layerIndex; i++) {
          animsBefore += specData.layers[i].animations.length;
        }
        const newAnimIndex = animsBefore + (animIndexInLayer - 1);

        setTimeout(() => {
          showAnimationDetails(newAnimIndex);
          const bar = document.querySelector(`.timeline-bar[data-anim-index="${newAnimIndex}"]`);
          const label = document.querySelector(`.timeline-label.indented[data-anim-index="${newAnimIndex}"]`);
          if (bar) bar.classList.add('selected');
          if (label) label.classList.add('selected');
        }, 0);
      }
    }

    // Move individual animation down within its layer
    function moveAnimationDown(layerIndex, animIndexInLayer) {
      const layer = specData.layers[layerIndex];
      if (animIndexInLayer === layer.animations.length - 1) return; // Already at bottom of layer

      // Swap animations within the layer
      const temp = layer.animations[animIndexInLayer];
      layer.animations[animIndexInLayer] = layer.animations[animIndexInLayer + 1];
      layer.animations[animIndexInLayer + 1] = temp;

      // Re-render timeline
      renderTimeline();

      // Update selection if this animation was selected
      if (selectedAnimation !== null) {
        // Calculate the new global animation index
        let animsBefore = 0;
        for (let i = 0; i < layerIndex; i++) {
          animsBefore += specData.layers[i].animations.length;
        }
        const newAnimIndex = animsBefore + (animIndexInLayer + 1);

        setTimeout(() => {
          showAnimationDetails(newAnimIndex);
          const bar = document.querySelector(`.timeline-bar[data-anim-index="${newAnimIndex}"]`);
          const label = document.querySelector(`.timeline-label.indented[data-anim-index="${newAnimIndex}"]`);
          if (bar) bar.classList.add('selected');
          if (label) label.classList.add('selected');
        }, 0);
      }
    }

    // Delete parameter row from timeline
    function deleteAnimation(animIndex) {
      // Find which layer and animation this belongs to
      let currentIndex = 0;
      let layerIndex = -1;
      let animInLayerIndex = -1;

      for (let lIdx = 0; lIdx < specData.layers.length; lIdx++) {
        const layer = specData.layers[lIdx];
        for (let aIdx = 0; aIdx < layer.animations.length; aIdx++) {
          if (currentIndex === animIndex) {
            layerIndex = lIdx;
            animInLayerIndex = aIdx;
            break;
          }
          currentIndex++;
        }
        if (layerIndex !== -1) break;
      }

      if (layerIndex === -1) return;

      const layer = specData.layers[layerIndex];
      const animation = layer.animations[animInLayerIndex];
      const propertyName = animation.property;
      const layerName = layer.layerName;

      // Check if this is the last parameter in the section
      const isLastParam = layer.animations.length === 1;

      if (isLastParam) {
        if (!confirm(`This is the last parameter in "${layerName}". Delete this parameter and the entire section?`)) {
          return;
        }
        // Remove the entire layer
        specData.layers.splice(layerIndex, 1);
      } else {
        if (!confirm(`Delete "${propertyName}" parameter from "${layerName}"?`)) {
          return;
        }
        // Remove just this animation
        layer.animations.splice(animInLayerIndex, 1);
      }

      // Close detail panel
      document.getElementById('detailPanel').innerHTML = '';
      selectedAnimation = null;
      document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('selected'));
      document.querySelectorAll('.timeline-label.indented').forEach(l => l.classList.remove('selected'));

      // Re-render timeline
      renderTimeline();
    }

    // Initialize with default spec
    specData = {
      compName: "Motion Inspector",
      workArea: {
        duration: 2000
      },
      layers: [
        {
          layerName: "Section 1",
          animations: [
            {
              property: "Add parameter",
              description: "Add description",
              timing: {
                delay: 0,
                duration: 300
              },
              easing: {
                type: "-",
                cubicBezier: ""
              },
              values: {
                formatted: {
                  startValue: "-",
                  endValue: "-"
                }
              }
            }
          ]
        }
      ]
    };

    // Render the default timeline
    renderTimeline();
  </script>
</body>
</html>
